<!DOCTYPE html><html lang="zh-CN" data-theme="light"><script>((function() {var callbacks = [],timeLimit = 50,open = false;setInterval(loop, 1);return {addListener: function(fn) {callbacks.push(fn);},cancleListenr: function(fn) {callbacks = callbacks.filter(function(v) {return v !== fn;});}}
function loop() {var startTime = new Date();debugger;if (new Date() - startTime > timeLimit) {if (!open) {callbacks.forEach(function(fn) {fn.call(null);});}open = true;window.stop();alert('你真坏，请关闭控制台！');document.body.innerHTML = "";} else {open = false;}}})()).addListener(function() {window.location.reload();});</script><script>function toDevtools(){
  let num = 0; 
  let devtools = new Date();
  devtools.toString = function() {
    num++;
    if (num > 1) {
        alert('你真坏，请关闭控制台！')
        window.location.href = "about:blank"
        blast();
    }
  }
  console.log('', devtools);
}
toDevtools();</script><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>计组-实验-Pre | 浮泛之舟</title><meta name="author" content="pigKiller"><meta name="copyright" content="pigKiller"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="计组实验Pre的笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="计组-实验-Pre">
<meta property="og:url" content="https://pigkillermaster.github.io/2023/08/11/CO-preview/index.html">
<meta property="og:site_name" content="浮泛之舟">
<meta property="og:description" content="计组实验Pre的笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202307251641570.jpg">
<meta property="article:published_time" content="2023-08-10T16:00:00.000Z">
<meta property="article:modified_time" content="2023-10-22T09:56:18.055Z">
<meta property="article:author" content="pigKiller">
<meta property="article:tag" content="计组实验">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202307251641570.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://pigkillermaster.github.io/2023/08/11/CO-preview/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '计组-实验-Pre',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2023-10-22 17:56:18'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202307102227559.png" onerror="onerror=null;src='https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202309212200810.jpg'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">41</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">29</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">19</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-categories"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202307251641570.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="浮泛之舟"><span class="site-name">浮泛之舟</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-categories"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">计组-实验-Pre</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-08-10T16:00:00.000Z" title="发表于 2023-08-11 00:00:00">2023-08-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-10-22T09:56:18.055Z" title="更新于 2023-10-22 17:56:18">2023-10-22</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/">计算机组成</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/%E8%AE%A1%E7%BB%84%E5%AE%9E%E9%AA%8C/">计组实验</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">24.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>83分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="计组-实验-Pre"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>虚拟机</h1>
<h2 id="基本命令">基本命令</h2>
<p>shell中，输入命令的格式为<code>&lt;命令名称&gt;&lt;参数1&gt;&lt;参数2&gt;&lt;参数n&gt;...</code>。其中，“命令名称”有两种类型：<strong>系统命令</strong>和<strong>路径命令</strong>。</p>
<p>系统命令直接由命令名表示。如，<code>cd</code>和<code>ls</code>，<code>vcs</code>皆为系统命令。</p>
<p>路径命令的格式则为<code>路径/程序文件名</code>，程序可以位于任何地方，不一定是系统程序目录。</p>
<p>例如，用户主目录中有<code>hello.sh</code>文件。在shell中输入<code>~/hello.sh</code>或<code>./hello.sh</code>，即可执行这个文件（注意后者只能在用户主目录下执行）。</p>
<p><strong>只有特定的文件（例如脚本、可执行文件）才能被执行，文本文件、Verilog源代码文件等都是不能执行的。</strong></p>
<ul>
<li><code>ls</code>:查看当前目录下的所有文件。</li>
<li><code>cd</code>:进入其他目录。</li>
<li><code>date</code>:查看当前日期时间。</li>
<li><code>cp&lt;源文件名&gt;&lt;目标文件名&gt;</code>:复制文件。</li>
<li><code>rm&lt;文件名&gt;</code>:删除文件。</li>
<li><code>echo&lt;文本&gt;</code>:原样显示文本。</li>
<li><code>cat&lt;文件名&gt;</code>:查看文件内容。</li>
</ul>
<h3 id="主目录">主目录</h3>
<p><code>~</code>是一个缩写，代表用户的主目录(home)。在表示文件路径时，我们常用这个缩写，例如<code>~/VCS-Example</code>表示<code>/home/co-eda/VCS-Example</code>。</p>
<p>目录(directory)又称文件夹(folder)，这两者一般表示相同的含义。</p>
<h3 id="当前目录">当前目录</h3>
<p>Linux中，有两个特殊的目录：</p>
<ol>
<li><code>.</code>（一个点）表示当前所在目录；</li>
<li><code>..</code>（两个点）表示当前目录的上一级目录。</li>
</ol>
<p>执行<code>cd.</code>不会有任何作用；执行<code>cd..</code>可返回上一级目录。</p>
<p>上面的“目录名”是<strong>相对路径</strong>，即相对于当前目录的路径。<code>cd</code>命令也可直接到达<strong>绝对路径</strong>。例如，无论当前目录在何处，输入<code>cd~</code>都可到达用户主目录下。</p>
<p>若觉得使用<code>cd</code>命令进入目录太麻烦，也可在文件管理器中打开想进入的地方，然后按下F4键，即打开终端并直接进入该目录。</p>
<h1>Logisim</h1>
<p>Logisim提供图形界面，以鼠标拖拽的形式可以新建部件以及进行部件间连线。</p>
<p>数字电路中最基础的内容就是逻辑电路门。普通的电路门如<strong>与门、或门、非门</strong>（真值表）。</p>
<h2 id="组件">组件</h2>
<p>在数字电路中，加法器是一种用于执行加法运算的数字电路部件，是构成电子计算机核心微处理器（CPU）中算术逻辑单元（ALU）的基础。在这些数字电路系统中，加法器主要负责计算地址、索引等数据。除此之外，加法器也是其他一些硬件，例如二进制数乘法器的重要组成部分。</p>
<p>尽管可以为不同计数系统设计专门的加法器，但是由于数字电路通常以二进制为基础，因此二进制加法器在实际应用中最为普遍。在数字电路中，二进制数的减法可以通过加一个负数来间接完成。为了使负数的计算能够直接用加法器来完成，计算中的负数可以使用补码来表示。</p>
<h3 id="组件图标">组件图标</h3>
<p>下面是Logisim中</p>
<h4 id="Wiring-线路-组件">Wiring(线路)组件</h4>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202308281102571.png" alt="logisim_2_1_wiring"></p>
<h4 id="Gates-逻辑门-组件">Gates(逻辑门)组件</h4>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202308281102301.png" alt="2"></p>
<h4 id="Plexers-复用器-组件">Plexers(复用器)组件</h4>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202308281103806.png" alt="3"></p>
<h4 id="Arithmetic-运算器-组件">Arithmetic(运算器)组件</h4>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202308281103560.jpg" alt="4"></p>
<h4 id="Memory-存储-组件">Memory(存储)组件</h4>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202308281103978.png" alt="5"></p>
<h4 id="Input-Output-输入-输出-组件">Input/Output(输入/输出)组件</h4>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202308281103982.png" alt="6"></p>
<h4 id="Base-基本-组件">Base(基本)组件</h4>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202308281103657.png" alt="7"></p>
<h3 id="Tunnel">Tunnel</h3>
<p>用于简化布线，省略了中部的连线，是一种抽象</p>
<p>tunnel通过标签名来作为数据两端的联通，只能有一个输入，但可以有多个输出，需要修改其<code>databits</code></p>
<h3 id="Pull-Register-上下拉电阻">Pull Register 上下拉电阻</h3>
<p><strong>只有当该点的值是x时</strong>，上下拉电阻将其连接的电线拉向其属性中指示的值0，1，X。</p>
<p>如果原先有值了，由于上下拉效果较弱，不影响原先的值，即只对不定值X进行上下拉</p>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202308301954851.png" alt="img"></p>
<h3 id="时钟">时钟</h3>
<p>时钟的本质是按照固定频率输出高低点位。Logisim中对时钟的模拟是相当不现实的：<strong>在真实的电路中，多个时钟会漂移，永远不会同步移动</strong>。但在逻辑上，所有的时钟都以相同的频率改变。</p>
<p>一个时钟只有一个引脚**，**为位宽为1的输出，其值代表时钟的当前值。</p>
<h3 id="Power电源-Ground地线">Power电源/Ground地线</h3>
<p>输出位全为1/0，与上下拉不同的是会与原先有值形成冲突</p>
<h3 id="Transistor晶体管">Transistor晶体管</h3>
<p>分为P型和N型：</p>
<table>
<thead>
<tr>
<th>真值</th>
<th>source</th>
<th>gate</th>
<th>output</th>
</tr>
</thead>
<tbody>
<tr>
<td>P</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>P</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>P</td>
<td>0</td>
<td>1</td>
<td>x</td>
</tr>
<tr>
<td>P</td>
<td>1</td>
<td>1</td>
<td>x</td>
</tr>
<tr>
<td>N</td>
<td>0</td>
<td>0</td>
<td>x</td>
</tr>
<tr>
<td>N</td>
<td>1</td>
<td>0</td>
<td>x</td>
</tr>
<tr>
<td>N</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>N</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>可以看出P型和N型中gate的作用相反。P型在低电平时导通，N型在高电平时导通</p>
<h3 id="位扩展器">位扩展器</h3>
<p>将n位输入扩展为m为输入</p>
<ul>
<li>n&lt;=m：对于高位，有四种补全方式可以选择
<ul>
<li>1/0：补充1/0</li>
<li>sign：根据额外的输入决定，补额外的输入</li>
<li>input：根据n位中的最高位补全</li>
</ul>
</li>
<li>n&gt;m：直接截断</li>
</ul>
<h3 id="n位异或门">n位异或门</h3>
<p>对于每一位，当且仅当只有一个1时才输出1，这和一般的n输入异或不一样：奇数个1时为真</p>
<h3 id="奇校验-偶校验">奇校验/偶校验</h3>
<p>对于多个输入的每一位，有奇数/偶数个1时在对应位输出1</p>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202310091635657.png" alt="image-20231009163527556"></p>
<h3 id="Controlled-Buffer-受控缓冲器-三态门">Controlled Buffer 受控缓冲器/三态门</h3>
<p>对于控制位，控制位输入为1时输出为输入，控制位为0时不论输入，<strong>全部输出为x</strong>，可以用上下拉电阻基于默认值。</p>
<p>相当于一个有开关的通路，只有开关打开时才能通过</p>
<h3 id="Multiplexer-多路选择器">Multiplexer 多路选择器</h3>
<p>对于n型的多位选择器，有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span>个可能的输入，通过两个辅助输入决定唯一的输出值</p>
<p>第一个辅助输入决定输出哪一个输入的值，第二个辅助输入 为使能端，一定要为1，可以用常量</p>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202308302051353.png" alt="image-20230830205113285"></p>
<h3 id="Demultiplexer-解复用器">Demultiplexer 解复用器</h3>
<p>唯一输入，多个输出，其他和多路选择器一致。不被选择的输出位输出0</p>
<p>MUX多个输入，唯一输出；Demu唯一输入，多个输出。</p>
<p>都有一个决定是否输出的额外输入和另一个决定选择第几个输入/输出的额外输入</p>
<h3 id="Decoder-译码器">Decoder 译码器</h3>
<p>无输入，有输出。一个输入决定是否输出，另一个输入决定哪一个输出1</p>
<p>译码器最大的功能在于将二进制编码转换为相应的<strong>独热码</strong>（one-hot），如101的3位二进制编码作为输入就会被转换成00100000的8位独热码作为输出。因而该元件得名译码器。</p>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202310091638040.png" alt="image-20231009163817957"></p>
<h3 id="Pirority-Encoder-优先编码器">Pirority Encoder 优先编码器</h3>
<p>组件在其左边有多个输入，第一个输入编号为0，从上往下编号。该组件寻找值为1的输入的编号，并输出值<strong>最大的编号</strong>。</p>
<p>例如，如果输入端编号为0、2、5和6的输入都是1，那么优先级编码器将输出110（也就是编号6的二进制表示）。如果没有输入为1，或者组件被禁用，那么优先级编码器的输出是浮动的。</p>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202308302107571.png" alt="img"></p>
<p>使能端即为开关，可缺省。当使能端为1时。如果输入中无1，则上方输出为1，若有1，则右下输出为1</p>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202310091642998.png" alt="image-20231009164254875"></p>
<h3 id="Bit-Selector-位选择器">Bit Selector 位选择器</h3>
<p>将输入均分为m位，输出第n位。由输出二决定输出中被均分输入的哪一份</p>
<p>可以代替移位+位扩展的截取效果，简化电路</p>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202308302111867.png" alt="img"></p>
<h3 id="加法器-减法器">加法器/减法器</h3>
<p>有进位的区别，上方为进位输入，即最后结果+1；下方为进位输出，若本次两指相加后溢出，则输出为1</p>
<p>一个加法器级联的示例：</p>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202308302115057.png" alt="img"></p>
<p>对于减法器，则上方输入表示最后结果-1；若减后溢出，则下方输出为1，输出为补码</p>
<h3 id="乘法器">乘法器</h3>
<p>上方输入为需要相加的进位值，输出为取（当前能输出最大值+1）模后的结果，下方输出为除（当前能输出最大值+1）后的结果</p>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202308302118385.png" alt="img"></p>
<h3 id="除法器">除法器</h3>
<p>除法器将左边输入的两个值相除，在右边输出商。组件的设计便于它与其他除法器级联。</p>
<p>如果除数为0，则不进行除法运算(即假设除数为1)。</p>
<p>除法器实际上执行无符号除法。商总是一个整数，且商*除数+余数=被除数。</p>
<p>上方输入为被除数在位宽之前的数</p>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202308302121708.png" alt="img"></p>
<h3 id="Negator-求补器">Negator 求补器</h3>
<p>求补码：取反+1</p>
<h3 id="比较器">比较器</h3>
<p>比较两个值（无符号值或<strong>两个补码值</strong>，可选）的大小。比较器有3个输出，通常，其中一个输出为1，另外两个输出为0。</p>
<p>比较从每个数字的最有效位开始，并并行地向下进行，直到找到两个值不一致的位置。但是，如果在下降过程中遇到错误值或浮点值，则所有输出将匹配该错误或浮点值。</p>
<p>比较器可级联。</p>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202308302124036.png" alt="img"></p>
<p>简单的比较器级联示例：</p>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202308302124596.png" alt="img"></p>
<h3 id="移位器">移位器</h3>
<ol>
<li>
<p>逻辑左移</p>
<p>数据中的所有位向左移动<code>dist</code>位，底部空出的位用0填充。例如，11001011逻辑左移两次就是00101100（之前的右边两位丢弃）</p>
</li>
<li>
<p>逻辑右移</p>
<p>数据中的所有位向右移动<code>dist</code>位，左端空出的位用0填充。例如，11001011逻辑右移两次就是00110010（之前的左边两位丢弃)</p>
</li>
<li>
<p>算术右移</p>
<p>数据中的所有位向右移动<code>dist</code>位，左端空出的位用数据中最高位重复填充。例如，11001011算术右移两次就是11110010（之前最高位为1，所以用1填充）</p>
</li>
<li>
<p>循环左移</p>
<p>数据中的所有位都向左移动<code>dist</code>位，左边被“挤出去”的位填充到右边空出的位。例如，将11001011循环左移两次就是00101111。</p>
</li>
<li>
<p>循环右移</p>
<p>数据中的所有位都向右移动<code>dist</code>位，右边被“挤出去”的位填充到左边空出的位。例如，将11001011循环右移两次就是11110010。</p>
</li>
</ol>
<h3 id="Bit-Adder-逐位加法器">Bit Adder 逐位加法器</h3>
<p>逐位加法器计算输入中有多少位是1，并输出中1为的位的数量。</p>
<p>右侧可以有多个输入，统计总共的1的数量</p>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202308302132170.png" alt="img"></p>
<h3 id="Bit-Finder-位查找器">Bit Finder 位查找器</h3>
<p>寻找高位/低位的0/1</p>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202308302133893.png" alt="img"></p>
<h3 id="触发器总体介绍">触发器总体介绍</h3>
<p>触发器可以<strong>存储单比特数据</strong>。右边输出的<strong>Q值</strong>根据左端的输入进行变化（<strong>时钟信号</strong>）。</p>
<p>触发器接受时钟信号，输出的信号（称为状态）改变。将触发器原来的状态（即触发器接收输入信号之前的状态）称为<strong>原态或现态，用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>Q</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">Q^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">Q</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span>表示</strong>。改变后的状态（即触发器接收输入信号之后的状态）称为<strong>次态，用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>Q</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">Q^{n+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0085em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">Q</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>表示</strong>。</p>
<p>具体来说，当时钟输入（在每个触发器时钟输入端口用三角形标记）从0上升到1（或其他配置）时，触发器被触发，Q值可能会根据输入发生变化。一般来说，触发器常用的触发方式为<strong>时钟上升沿触发和下降沿触发</strong>，可在设置中选择需要的触发方式。</p>
<h4 id="异步复位（固定触发器值为0）">异步复位（固定触发器值为0）</h4>
<p>当且仅当端口输入为1时，触发器的值就固定为0。</p>
<p>异步：与当前时钟输入值无关。只要该端口输入是1，其他输入就没有影响。</p>
<h4 id="异步设置（固定触发器值为1）">异步设置（固定触发器值为1）</h4>
<p>当且仅当端口输入为1时，触发器的值就固定为1。</p>
<p>异步：与当前时钟输入值无关。只要该端口输入是1，其他输入就没有影响，<strong>除了具有更高优先级的异步复位</strong>。</p>
<h4 id="使能端（启用时钟信号）">使能端（启用时钟信号）</h4>
<p>当该端口输入值为0时，时钟触发被忽略，Q输出保持不变。当此输入为1或未定义时，时钟触发被启用。</p>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202308310907116.png" alt="img"></p>
<p>异步复位、异步设置、使能端3个端口均可以不连接输入，触发器也可正常工作。</p>
<p>使用Poke工具点击触发器可改变存储在触发器中的值，除非异步设置/复位输入当前锁定了触发器的值。</p>
<h3 id="D-Flip-flop-D触发器">D Flip-flop D触发器</h3>
<p>时钟触发时，D触发器存储的值变为输入值</p>
<h3 id="T-Flip-flop-T触发器">T Flip-flop T触发器</h3>
<p>时钟触发时：</p>
<ol>
<li>如果输入是1，则Q不停变化，在0和1之间切换</li>
<li>如果输入是0，则Q保持不变，Q可能是0或1</li>
</ol>
<h3 id="J-K-Flip-flop-JK触发器">J-K Flip-flop JK触发器</h3>
<p>J为jump信号，k为kill信号</p>
<p>JK触发器在触发时值根据下表的变化：</p>
<table>
<thead>
<tr>
<th>J</th>
<th>K</th>
<th>Q</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>Q</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">Q^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">Q</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span></td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><msup><mi>Q</mi><mi>n</mi></msup><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\overline{Q^n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0778em;vertical-align:-0.1944em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8833em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">Q</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.5904em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span><span style="top:-3.8033em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span></span></span></span>（来回切换）</td>
</tr>
</tbody>
</table>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202308310929435.png" alt="img"></p>
<h3 id="S-R-Flip-flop-SR锁存器">S-R Flip-flop SR锁存器</h3>
<p>R为reset，S为set</p>
<p>最基本的锁存器</p>
<table>
<thead>
<tr>
<th>S</th>
<th>R</th>
<th>Q</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>Q</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">Q^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">Q</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span></td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>未知，但在logisim中表现为不变</td>
</tr>
</tbody>
</table>
<h3 id="Register-寄存器">Register 寄存器</h3>
<p>寄存器存储单个多位值，该值以十六进制形式显示在其矩形内，并在其输出端输出。</p>
<p>在使能端开启后，当时钟信号输入满足寄存器触发条件时，存储在寄存器中的值就会在<strong>该时刻改变</strong>为D输入的值。</p>
<p>时钟信号指示寄存器储存值发生改变的确切条件是通过触发属性配置的，Logisim中一般有时钟上升沿和下降沿，高电平和低电平这四种触发方式。</p>
<p>Reset输入<strong>异步复位</strong>，将寄存器的值重置为0（全部为0），也就是说，只要Reset为1，寄存器值就固定为0，不管时钟和输入是什么。</p>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202308310937755.png" alt="img"></p>
<h3 id="Counter-计数器">Counter 计数器</h3>
<p>计数器持有单个值,其值会在Q端口输出。每次时钟输入（输入端口用三角形标记）根据触发属性触发计数器。</p>
<p>计数器的值将根据元件左边两个输入load和count，左边有3个输入端口，最上方的输入端口称为load，中间的称为D，最下方的称为count</p>
<table>
<thead>
<tr>
<th>load</th>
<th>count</th>
<th>触发情况</th>
</tr>
</thead>
<tbody>
<tr>
<td>0或x</td>
<td>0</td>
<td>计数器值不变</td>
</tr>
<tr>
<td>0或x</td>
<td>1或x</td>
<td>计数器值++</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>计数器载入D输入值</td>
</tr>
<tr>
<td>1</td>
<td>1或x</td>
<td>计数器值减少</td>
</tr>
</tbody>
</table>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202308310954283.png" alt="img"></p>
<p>计数范围可以使用“最大值”属性配置。当计数器达到这个值时，下一个增量将让计数器值回到0；<strong>如果计数器值0</strong>，那么计数器值减少操作将把计数器设置为它的最大值。</p>
<p>除了输出Q外，该组件还包括一位输出：carry（进位）。当计数器达到最大值时，当load和count输入指示计数器在下一步该增加时；或者当计数器为0时，load和count输入指示计数器在下一步该减少时，carry值为1。</p>
<h4 id="溢出时操作">溢出时操作</h4>
<ol>
<li>
<p>Wrap around重新计数</p>
<ul>
<li>
<p>递增时，下一个值是0</p>
</li>
<li>
<p>递减时，下一个值时最大值</p>
</li>
</ul>
</li>
<li>
<p>Stay at value保持当前值</p>
<ul>
<li>
<p>递增时，保持最大值不变</p>
</li>
<li>
<p>递减时，保持0不变</p>
</li>
</ul>
</li>
<li>
<p>Continue counting继续计数</p>
<ul>
<li>计数器继续递增/递减，保持数据位属性提供的位数</li>
</ul>
</li>
<li>
<p>Load next value加载下一个值</p>
<ul>
<li>下一个值从D输入中加载</li>
</ul>
</li>
</ol>
<h3 id="Shift-Register-移位寄存器">Shift Register 移位寄存器</h3>
<ol>
<li>
<p>Clear清空（输入引脚，位宽1）</p>
<p>将所有阶段异步重置为0，也就是说，只要clear输入为1，所有输出值都固定为0，而不管时钟和输入是什么。</p>
</li>
<li>
<p>Shift移位（输入引脚，位宽1）</p>
<p>当断开或输入为1时，所有级通过时钟触发右移左边空出的位由data填充，但如果输入是0，则不会右移。如果Load输入为1，则忽略此输入。</p>
</li>
<li>
<p>Data数据（输入引脚，位宽匹配Data Bits属性）</p>
<p>在推进阶段时，在此输入中找到的值被加载到第一阶段。</p>
</li>
</ol>
<p><strong>只在启用Parallel Load属性时存在的引脚</strong>:</p>
<ol>
<li>
<p>Load加载（输入引脚，位宽1）:加载上方输入的各位</p>
</li>
<li>
<p>Parallel Input并行输入（输入引脚，共Number of Stages个，位宽匹配Data Bits属性）</p>
<p>当Load输入为1时，其他在上方的引脚（即并行输入引脚）输入值在时钟触发是被加载到移位寄存器中。0或断开时，不会加载。</p>
</li>
<li>
<p>Output串行输出（输出，位宽匹配Data Bits属性）</p>
<p>输出存储在最后阶段的值</p>
</li>
<li>
<p>Parallel Output并行输出（输出引脚，共Number of Stages个，位宽匹配Data Bits属性）</p>
<p>输出对应的每个阶段（Stages）的值</p>
</li>
</ol>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202308311018540.png" alt="img"></p>
<h3 id="Random-Generator-随机数生成器">Random Generator 随机数生成器</h3>
<p>遍历一个伪随机数序列，当启用时，每次时钟被触发时，该序列将前进到序列中的下一个数字。从技术上讲，用来计算伪随机序列的算法是一个线性同余生成器：从种子<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>r</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">r_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>开始，下一个的数字<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>r</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">r_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>就是：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>r</mi><mn>1</mn></msub><mo>=</mo><mo stretchy="false">(</mo><mn>25214903917</mn><msub><mi>r</mi><mn>0</mn></msub><mo>+</mo><mn>11</mn><mo stretchy="false">)</mo><mtext>mod</mtext><msup><mn>2</mn><mn>48</mn></msup></mrow><annotation encoding="application/x-tex">r_1=(25214903917r_0+11)\text{mod}2^{48}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">25214903917</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord">11</span><span class="mclose">)</span><span class="mord text"><span class="mord">mod</span></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">48</span></span></span></span></span></span></span></span></span></span></span></span>.下一个值<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>r</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">r_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是用相同的计算方法从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>r</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">r_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>计算出来的，以此类推。从组件中看到的值是其位宽属性配置的低阶位。</p>
<p>除了时钟输入，组件还包括一个使能输入，当使能为0时，该时钟输入将被忽略，以及复位输入，该组件的值将异步重置为初始种子。初始种子是用户可配置的。如果它被配置为0（这是默认值），那么种子将基于当前时间；当指示通过重置输入端口进行重置时，组件根据新的当前时间计算一个新的种子</p>
<h3 id="RAM：随机存取存储器">RAM：随机存取存储器</h3>
<p>RAM组件是Logisim内置库中最复杂的组件，最多可存储16,777,216个值（在地址位宽度/Address Bit Width属性中指定），每个值最多可包含32位（在数据位宽度/Data Bit Width属性中指定）。RAM可加载和存储数据。</p>
<h4 id="几个引脚">几个引脚</h4>
<ol>
<li>sel(Chip Select)（输入引脚，位宽1）：此输入启用或禁用整个RAM模块，基于值是1，浮动还是0。该输入主要用于有多个RAM单元的情况，在任何时候只有一个RAM单元是启用的</li>
<li>clr清除数据/Clear（输入引脚，位宽1）：当该值为1时，RAM中的所有储存值都固定为0，不管其他输入是什么</li>
</ol>
<p>RAM组件支持三种不同的接口，这取决于数据接口(Data Interface)属性:</p>
<blockquote>
<p><strong>三态门很关键</strong></p>
</blockquote>
<h4 id="一个同步加载-存储端口-默认">一个同步加载/存储端口(默认)</h4>
<p>该组件在其右侧包括一个单独的端口，用于加载和存储数据。它的执行取决于标签为ld的单比特输入，ld是load data（加载数据）的缩写。</p>
<p><strong>ld=1（或浮动）表示以A指定的地址加载数据到D输出，ld=0表示存储在D端口上输入的数据。</strong></p>
<p>要在组件之间传输数据，将需要使用<strong>三态门</strong>组件，如下图所示。</p>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202308311040551.png" alt="image-20230831104041429"></p>
<h4 id="一个异步加载-存储端口（消除了时钟信号）">一个异步加载/存储端口（消除了时钟信号）</h4>
<p>这和上面一样，只是没有时钟输入。当ld输入为0时，在数据总线上的值被存储到存储器中。当ld输入为0时，地址或数据发生了变化，则会发生额外的存储。ld为输入为1时，D端口输出当前地址数据的值。</p>
<p>这个选项被用于着更接近地模仿许多可用的随机访问存储器的接口。</p>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202308311043840.png" alt="img"></p>
<h4 id="分离的加载和存储端口（消除了三态门）">分离的加载和存储端口（消除了三态门）</h4>
<p>提供两个数据端口：一个在西面用于存储数据，另一个在东面用于加载数据。该选项<strong>消除了三态门的必要性</strong>，因此更易于使用。</p>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202308311044066.png" alt="img"></p>
<p>其中仅在该状态出现的str储存/Store引脚（输入引脚，位宽1）：此输入仅在为<code>Data Interface</code>属性选择了“分离的加载/存储端口”时出现。当它为1或浮动时，时钟脉冲将导致将左边D的数据存储到RAM中（假设<code>sel</code>输入也是1或浮点）</p>
<h3 id="ROM只读存储器-Read-Only-Memory">ROM只读存储器(Read-Only Memory)</h3>
<p>电路可以访问ROM中的储存值，但不能改变它们。用户可以通过Poke工具交互修改单个值，或者用户可以通过菜单工具修改整个内容。</p>
<p>ROM组件的当前内容是作为组件的属性存储的。因此，如果一个包含ROM组件的电路被使用了两次，这两个ROM组件都持有相同的值。也因为这种行为，ROM的数据存储在Logisim创建的文件中。</p>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202308311048491.png" alt="image-20230831104802407"></p>
<h2 id="时序电路">时序电路</h2>
<p>一个电路，使其输出结果不仅与当前的输入有关，还可能与电路之前的输入有关（即电路能记住之前的状态）</p>
<p>时钟是时序电路中最关键的组件，时钟按照一定的频率输出高频低频信号，所有的时钟都按照相应的频率输出信号。</p>
<h3 id="时钟沿">时钟沿</h3>
<p>时钟上升沿：数字时钟电路中，数字电平从低电平（数字0）变为高电平（数字1）的那一瞬间叫作上升沿。</p>
<p>时钟下降沿：数字时钟电路中，数字电平从高电平（数字1）变为低电平（数字0）的那一瞬间叫作下降沿。</p>
<p>寄存器存储的值，就是在时钟上升沿发生变化的。</p>
<h3 id="复位信号">复位信号</h3>
<p>寄存器会接受一个外部传入的、可以将自身存储数据清零的信号。寄存器的复位信号有两种，分别是同步复位和异步复位。</p>
<p>同步复位：<strong>复位信号只有在时钟上升沿到来时，才能有效</strong>。也就是说，同步复位操作永远发生在时钟上升沿，即便复位信号提前到来，也无法立刻完成复位操作。</p>
<p>异步复位：无论时钟沿是否到来，只要复位信号有效，就对系统进行复位。</p>
<p>关键路径是指同步逻辑电路中，组合逻辑时延最大的路径。</p>
<h3 id="寄存器">寄存器</h3>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202309010003075.png" alt="1"></p>
<p>对于这样的电路，实现了在每个时钟周期内寄存器存储的值++。本电路看似短路，实则利用了时延的特性。</p>
<p><strong>寄存器本质就是一个D触发器</strong>，它是由两个D锁存器构成的。</p>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202309010005780.png" alt="D_ff.png"></p>
<p>D锁存器的功能是当CP为高电平时，Q赋值为D。当时钟低电平时，<strong>左侧的锁存器</strong>将储存值D赋值给N1，当时钟高电平时，右侧的锁存器将N1赋值给Q。</p>
<p>**这个世界上本没有上升沿赋值，只有高低电平赋值。**通过这样两个D锁存器结合形成的D触发器，宏观上就表现为了上升沿的赋值。</p>
<p>先（时钟低电平时）打开第一道关卡，堵第二道关卡，让船（输入数据）到中转站（N1），然后堵上第一道关卡，开第二道关卡（时钟高电平时），让船只通过。</p>
<p>由于两个过程交替进行，宏观上就变成了，<strong>时钟在上升沿时，数据进行赋值</strong>。</p>
<h3 id="step-simulation">step simulation</h3>
<p>Simulate 菜单中有一项 Step Simulation，这个选项在平时我们并不常用，但使用它能看到 Logisim 对电路仿真的细节，所以有时对调试是很有帮助的。这个选项在 Simulation Enable 被选中时是不可用的，所以使用前记得关闭 Simulation Enable。</p>
<p>每当我们点击一次 Step Simulation，电路就会向前仿真一步。注意这里的一步并不是时钟改变一次，而是 Logisim 进行了一次它仿真的最小粒度。</p>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202309021435430.png" alt=""></p>
<p>如这个电路，因为电路中电流传播需要时间的原因，会有一个奇怪的现象：这个电路正常来说应该始终输出 0，但在 Logisim 中，其输入每改变两次，输出就会改变一次。</p>
<p>本质是因为因为非门增加了传播时间，使得与门有机会输出高电平信号，因而对于D触发器是上升沿，载入输入D=1。</p>
<h3 id="一道好题">一道好题</h3>
<p>黄小板同学暗中观察了公司负责人很久，觉得他搭建的电路性能实在太差，他提出只需要 <strong>64</strong> 个周期就能计算出 32 位无符号整数能表示的最大数位置上的斐波那契数的（最后 32bit），在完成搭建这样的电路后，公司负责人五体投地，宣布给黄小板开出了东门烤串无限量供应的实习工资，从此黄小板每日吃串，终于吃成了黄老板…</p>
<p>那么，这个电路是什么样子的呢？</p>
<p><strong>注意：这道题是一个对你的挑战，需要一定的算法和工程能力，请谨慎思考，大胆尝试！</strong></p>
<p>使用 Logisim 搭建一个根据输入序号<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>计算对应序号斐波那契数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>的电路并提交。</p>
<ul>
<li>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn><mo separator="true">,</mo><mi>F</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mi>F</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>F</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mi>F</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>n</mi><mo>&gt;</mo><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">F(0)=0,F(1)=1,F(n)=F(n-1)+F(n-2),n&gt;=2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span></p>
</li>
<li>
<p><strong>输入</strong>： N（32bit无符号数）</p>
</li>
<li>
<p><strong>输出</strong>： Nth（32bit无符号数，表示第 N 个斐波那契数）</p>
</li>
<li>
<p><strong>文件内模块名</strong>: <strong>main</strong></p>
</li>
<li>
<p><strong>测试电路图</strong>：</p>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202309030854087.png" alt="4.4.5.2"></p>
</li>
<li>
<p><strong>测试要求</strong>：在 64 个周期内计算出结果并稳定输出，在结果未计算出之前输出端口输出 0。</p>
</li>
<li>
<p><strong>HINT</strong>：矩阵乘法的快速幂</p>
</li>
</ul>
<p>解答：<a target="_blank" rel="noopener" href="https://blog.csdn.net/JeremyZhao1998/article/details/108938046">https://blog.csdn.net/JeremyZhao1998/article/details/108938046</a></p>
<p>这篇博客写的非常不错，深入浅出</p>
<h1>Verilog与工具仿真</h1>
<p>Verilog 模型可以描述实际电路中不同级别的抽象。所谓不同的抽象级别，是指<strong>同一个物理电路，可以在不同的层次上</strong>用 Verilog 语言来描述它。在这里，不同的层次可以理解为：电路的某个功能部件是由更小的、功能较为简单的部件连接组合而成的。</p>
<p>复杂数字逻辑电路和系统的层次化、结构化设计意味着硬件设计方案的逐次分解。</p>
<p>常用的硬件系统设计方法主要分为自顶向下设计以及自底向上设计两种：</p>
<ul>
<li>
<p>在自顶向下设计（Top-down design）当中，从顶层开始，进行功能划分和结构设计，重写行为建模至结构建模，直到可使用元件/原语（primitive）进行描述；</p>
</li>
<li>
<p>从底向上设计（Bottom-up design）当中，从简单门器件出发（通常复用已制造的标准基本单元模块），逐层搭建更复杂的模块，直到实现顶层行为要求。</p>
</li>
</ul>
<h2 id="结构化建模">结构化建模</h2>
<p>在 Verilog 中，结构化建模的主要表现形式为<strong>实例化（instantiate）</strong>。通俗来讲，实例化就是利用某个模板所创建一个其所对应的实体的过程。我们想要使用一个元件前，需要对其进行实例化。在实例化的同时，我们需要<strong>指定模块输入输出端口与对应的信号</strong>。</p>
<p>对电路元件进行实例化的最常见语法是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">模块名 实例名(端口信号映射);</span><br></pre></td></tr></table></figure>
<p>其中，端口信号映射的格式也有两种：</p>
<ol>
<li><strong>位置映射</strong>：<code>模块名 实例名(信号1, 信号2, ...)</code>，其中信号 n 对应被实例化模块声明时排在第 n 位的端口。</li>
<li><strong>名映射</strong>：<code>模块名 实例名(.端口名a(信号1), .端口名b(信号2), ...)</code>，其中信号 n 对应其前的端口名。</li>
</ol>
<p>值得注意的是，在实例化元件时，<strong>wire 类型信号</strong>可以被连接至<strong>任意端口</strong>上，但 <strong>reg 类型的信号</strong>只能被连接至元件的<strong>输入端口</strong>上。在声明元件时，我们可以将任意端口声明为 wire 类型，但<strong>只能将输出端口声明为 reg 类型</strong>，否则会出现问题。</p>
<p>下面来看一个例子：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> Adder(</span><br><span class="line">    <span class="keyword">input</span> a, </span><br><span class="line">    <span class="keyword">input</span> b, </span><br><span class="line">    <span class="keyword">input</span> cin, </span><br><span class="line">    <span class="keyword">output</span> sum, </span><br><span class="line">    <span class="keyword">output</span> overflow</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">wire</span> s1, s2, s3;</span><br><span class="line">    <span class="comment">//xor 与 and 均为原语，是系统预定义的模块</span></span><br><span class="line">    <span class="keyword">xor</span> xor1(sum, a, b, cin);</span><br><span class="line">    <span class="keyword">and</span> and1(s1, a, b);</span><br><span class="line">    <span class="keyword">and</span> and2(s2, a, cin);</span><br><span class="line">    <span class="keyword">and</span> and3(s3, b, cin);</span><br><span class="line">    <span class="keyword">or</span> or1(overflow, s1, s2, s3);</span><br><span class="line"><span class="keyword">endmodule</span>   </span><br></pre></td></tr></table></figure>
<p>对应的电路图如下所示：</p>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202309042230458.png" alt=""></p>
<p>模块的端口<code>input</code>、<code>output</code>默认为<code>wire</code>型，可以直接声明为reg型：<code>output reg c</code></p>
<h3 id="模块的内部典型结构">模块的内部典型结构</h3>
<p>假设已经有一个定义好的模块Sample，输入输出定义如下：</p>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202309051929080.png" alt="5.3.3.4.png"></p>
<p>我们在设计的过程中，需要引用上述模块，其中变量x对应管脚a，变量y对应管脚b，变量z对应管脚c，<strong>reset管脚没有使用</strong>。即可以使用：<code>Sample uut(.b(y),.a(x),.c(z));</code></p>
<h2 id="实现电路的行为级描述">实现电路的行为级描述</h2>
<p>使用行为级描述设计电路时，主要描述电路输入信号和输出信号间的逻辑关系，关注电路“<strong>干什么</strong>”而不是“<strong>怎么做</strong>”。低层次内部结构和实现细节等的考虑，以及将其转化为物理电路的过程，都由软件自动完成。</p>
<p>行为级描述的方法一般有两种：</p>
<ol>
<li>利用连续赋值语句 <code>assign</code> 描述电路。</li>
<li>利用 <code>initial</code> 结构、<code>always</code> 结构和过程控制语句描述电路。</li>
</ol>
<h3 id="连续赋值语句-assign">连续赋值语句 assign</h3>
<p>一种很重要的行为级描述就是连续赋值语句，其常见形式为：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assign</span> signal = expression;</span><br></pre></td></tr></table></figure>
<p>其中 <code>signal</code> 必须是 <strong><code>wire</code></strong> 型数据，而 <code>expression</code> 则是由数据和运算符组成的表达式。</p>
<p><code>assign</code> 语句的作用是将右侧表达式的值<strong>持续性</strong>的赋给左侧的信号，一般<strong>用于描述一个信号是如何由其他信号生成的</strong>。所谓<strong>持续性，指的是当右侧表达式中的变量发生变化时，左侧信号的值也会随之变化</strong>。</p>
<p><code>assign</code> 语句非常适合简单的组合逻辑的描述，经常与<strong>三目运算符</strong>配合使用。一般来说，<code>assign</code> 语句综合出来的电路是右侧表达式化简后所对应的逻辑门组合。</p>
<h3 id="过程控制语句与有关结构">过程控制语句与有关结构</h3>
<p>我们可以把电路的当前状态（如果有）和电路的输出抽象为一些<strong>变量</strong>。通过描述不同条件下对这些<strong>变量的变化规律</strong>来描述电路，这就是利用过程控制语句与有关结构进行的行为级描述。</p>
<p>变量，是指<code>reg</code>型数据。<strong><code>reg</code> 类型数据只是一个变量，用途是方便的描述，并不一定对应一个真实电路中的寄存器</strong></p>
<h2 id="常见数据类型">常见数据类型</h2>
<h3 id="wire型">wire型</h3>
<p><code>wire</code> 型数据属于线网 <code>nets</code> 型数据，通常用于表示<strong>组合逻辑信号</strong>，可以将它类比为<strong>电路中的导线</strong>。它<strong>本身并不能存储数据</strong>，需要<strong>有输入才有输出</strong>（这里输入的专业术语叫驱动器），且输出随着输入的改变而<strong>即时改变</strong>。一般使用 <code>assign</code> 语句对 <code>wire</code> 型数据进行驱动。在访问时，可以使用形如 <code>a[7:4]</code> 的方式取出 a 的第 7-4 位数据。</p>
<blockquote>
<p>信号定义好之后，不仅决定了位宽还决定了方向。</p>
<p>可以有<code>wire [3:0] a</code>，也可以有<code>wire [0:3] a</code>，在方向上有区分</p>
</blockquote>
<p>需要注意的是，信号变量与 C 语言中的变量有所不同，不能像 C 语言一样随意赋值，一般需要<strong>按照组合逻辑的规则</strong>进行操作。</p>
<h3 id="reg型">reg型</h3>
<p><code>reg</code> 型（register）是寄存器数据类型，具有<strong>存储</strong>功能。一般在 <code>always</code> 块内使用 <code>reg</code> 型变量，通过赋值语句来改变寄存器中的值。为了确定何时进行赋值，我们经常需要用到各种控制结构，包括 <code>while</code>、<code>for</code>、<code>switch</code> 等。</p>
<p>在always过程块中要求被赋值变量必须为reg型。<code>reg</code> 型变量<strong>不能使用</strong> <code>assign</code> 赋值。而且，<code>reg</code> 型并不一定被综合成寄存器，它也可和 <code>always</code> 关键字配合，建模组合逻辑。</p>
<h4 id="利用-reg-数据类型建模存储器">利用 reg 数据类型建模存储器</h4>
<p>可以对 <code>reg</code> 型变量建立数组来对存储器建模，例如 <code>reg [31:0] mem [0:1023];</code>，其中前面的中括号内为位宽，后面的中括号内为<strong>存储器数量</strong>。<code>mem[2]</code> 就是访问 <code>mem</code> 中的第 3 个元素。</p>
<blockquote>
<p>理解 Verilog HDL 的关键在于“<strong>站在硬件的角度</strong>”来看待程序的设计与运行。</p>
</blockquote>
<h3 id="数字字面量">数字字面量</h3>
<p>Verilog 中的数字字面量可以按二进制（b 或 B）、八进制（o 或 O）、十六进制（h 或 H）、十进制（d 或 D）表示。</p>
<p>数字的完整表达为 <code>&lt;位宽&gt;'&lt;进制&gt;&lt;值&gt;</code>，如 <code>10'd100</code>。省略位宽时采用默认位宽（与机器有关，一般为 <strong>32 位</strong>），省略进制时默认为<strong>十进制</strong>，值部分可以用下划线分开提高可读性，如 <code>16'b1010_1011_1111_1010</code>。</p>
<p>Verilog 中除了普通的数字以外，还有两个特殊的值：<strong><code>x</code></strong> 和 <strong><code>z</code></strong>。</p>
<ul>
<li>
<p><code>x</code> 为不定值，当某一二进制位的值不能确定时出现，变量的<strong>默认初始值为 <code>x</code></strong>。</p>
</li>
<li>
<p><code>z</code> 为高阻态，代表<strong>没有连接到有效输入上</strong>。对于位宽大于1的数据类型，<code>x</code> 与 <code>z</code> 均可只在部分位上出现。</p>
</li>
</ul>
<h3 id="integer-型">integer 型</h3>
<p><code>integer</code> 数据类型一般为 32 位，与 C 语言中的 <code>int</code> 类似，<strong>默认为有符号数</strong>，在实验中主要用于 <code>for</code> 循环</p>
<h3 id="parameter-型">parameter 型</h3>
<p><code>parameter</code> 类型用于<strong>在编译时确认值的常量</strong>，通过形如 <code>parameter 标识符 = 表达式;</code> 的语句进行定义，如：<code>parameter width = 8;</code>。在实例化模块时，可通过参数传递改变在被引用模块实例中已定义的参数（模块的实例化将在后面的章节进行介绍）。<code>parameter</code> 虽然看起来可变，但它属于常量，在编译时会有一个确定的值。</p>
<p><code>parameter</code> 可以用于在模块实例化时指定数据位宽等参数，便于在结构相似、位宽不同的模块之间实现代码复用。</p>
<h2 id="组合逻辑建模">组合逻辑建模</h2>
<h3 id="assign-语句">assign 语句</h3>
<p><code>assign</code> 语句是连续赋值语句，是组合逻辑的建模利器，其作用是<strong>用一个信号来驱动另一个信号</strong>。如 <code>assign a = b;</code>，其中 <code>a</code> 为 <code>wire</code> 型（也可由<strong>位拼接</strong>得到，见运算符部分），<code>b</code> 是由数据和运算符组成的表达式。</p>
<p><code>assign</code> 语句与 C 语言的赋值语句有所不同，这里“驱动”的含义类似于<strong>电路的连接</strong>，也就是说，<code>a</code> 的值<strong>时刻</strong>等于 <code>b</code>。这也解释了 <code>assign a = a + 1;</code> 这样的语句为什么是不合法的。由于这样的特性，<strong><code>assign</code> 语句不能在 <code>always</code> 和 <code>initial</code> 块中使用</strong>。assign 意味着左侧的信号值始终等于右侧，因此<code>assign w1=w1 | w1</code>是错误的。</p>
<p>未被驱动的 wire 型变量可以理解为一段没有连接任何信号的导线，它和其他导线相连是没有意义的。</p>
<blockquote>
<p><code>assign</code>连接<code>wire</code>型数据，表示线的直接连接，因而时刻改变</p>
<p><strong>联想实际的电路</strong></p>
</blockquote>
<p><code>assign</code> 语句<strong>经常与三目运算符配合使用建模组合逻辑</strong>。一般来说，<code>assign</code> 语句综合出来的电路是右侧表达式化简后所对应的逻辑门组合。</p>
<h2 id="时序逻辑建模">时序逻辑建模</h2>
<h3 id="always-块">always 块</h3>
<p><code>always</code> 块有如下两种用法：</p>
<ul>
<li>若 <code>always</code> 之后紧跟 <code>@(...)</code>，其中括号内是<strong>敏感条件列表</strong>，表示当<strong>括号中的条件满足</strong>时，将会执行 <code>always</code> 之后紧跟的语句或顺序语句块。这种用法<strong>主要用于建模时序逻辑</strong>。
<ul>
<li><code>always</code> 的敏感条件列表中，条件使用变量名称表示，例如 <code>always @(a)</code> 表示<strong>当变量 <code>a</code> 发生变化时</strong>执行之后的语句；
<ul>
<li>若 <code>always</code> 之后<strong>紧跟 <code>@ *</code> 或 <code>@(*)</code></strong>，则表示对其后<strong>紧跟的语句或语句块内所有信号的变化</strong>敏感。这种用法主要用于与 <code>reg</code> 型数据和阻塞赋值配合，<strong>建模组合逻辑</strong>。</li>
<li>若条件前加上 <code>posedge</code> 关键字，如 <code>always @(posedge a)</code>，表示当 <code>a</code> 达到<strong>上升沿</strong>，即从 <code>0</code> 变为 <code>1</code> 时触发条件，下降沿不触发；加上 <code>negedge</code> 则是<strong>下降沿</strong>触发条件，上升沿不触发。</li>
</ul>
</li>
<li>每个条件使用逗号 <code>,</code> 或 <code>or</code> 隔开，只要有其中一个条件被触发，<code>always</code> 之后的语句都会被执行。</li>
</ul>
</li>
<li>若 <code>always</code> 紧跟语句，则表示在该语句<strong>执行完毕之后立刻再次执行</strong>。这种用法主要配合后面提到的时间控制语句使用，来产生一些<strong>周期性的信号</strong>。</li>
</ul>
<p>在always过程块中要求被赋值变量必须为reg型。</p>
<h3 id="initial-块">initial 块</h3>
<p><code>initial</code> 块后面紧跟的语句或顺序语句块<strong>在硬件仿真开始时就会运行</strong>，且<strong>仅会运行一次</strong>，一般用于<strong>对 <code>reg</code> 型变量的取值</strong>进行初始化。<code>initial</code> 块通常仅用于仿真，是<strong>不可综合的</strong>。</p>
<h3 id="if-else语句"><code>if-else</code>语句</h3>
<p>Verilog 中 <code>if</code> 语句的语法和 <code>C</code> 语言基本相同，也有 <code>else if</code>、<code>else</code> 这样的用法。</p>
<p>但是，<code>if</code> 语句只能出现在<strong>always中的顺序块中</strong>，其后的<strong>分支也只能是语句或顺序块</strong>。</p>
<p><code>if</code>的硬件含义：MUX多路选择器</p>
<h3 id="case-语句"><code>case</code> 语句</h3>
<p><code>case</code> 语句同样<strong>只能出现在顺序块中</strong>，其中的分支也只能是<strong>语句或顺序块</strong>。</p>
<p>与 C 语言不同，<code>case</code> 语句在分支执行结束后<strong>不会落入下一个分支</strong>，而会<strong>自动退出</strong>。</p>
<blockquote>
<p>由实际的硬件含义决定</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">always @(posedge clk) <span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">case</span>(data)</span><br><span class="line">      <span class="number">0</span>: <span class="keyword">out</span> <span class="operator">&lt;=</span> <span class="number">4</span>;</span><br><span class="line">      <span class="number">1</span>: <span class="keyword">out</span> <span class="operator">&lt;=</span> <span class="number">5</span>;</span><br><span class="line">      <span class="number">2</span>: <span class="keyword">out</span> <span class="operator">&lt;=</span> <span class="number">2</span>;</span><br><span class="line">      <span class="number">3</span>: <span class="keyword">begin</span></span><br><span class="line">          <span class="keyword">out</span> <span class="operator">&lt;=</span> <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">default</span>: ;</span><br><span class="line">  endcase</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>需要指出的是，<code>case</code> 语句进行的是<strong>全等比较</strong>，也就是<strong>每一位都相等（包括 <code>x</code> 和 <code>z</code>）才认为相等</strong>。</p>
<h3 id="for-语句">for 语句</h3>
<h4 id="循环变量">循环变量</h4>
<p><strong><code>integer</code> 和 <code>reg</code> 类型的变量均可作为循环变量</strong>，使用 <code>reg</code> 类型变量作为循环变量时需要<strong>合理设置位宽</strong>，防止进入死循环状态。</p>
<blockquote>
<p>此代码会造成 <code>Isim</code> 崩溃，可以发现仿真进入死循环，不会输出 <code>finish!</code> 。</p>
<p>这是因为循环变量 <code>temp</code> 是位宽为 2的 <code>reg</code> 型变量，当循环计数到达 <code>3</code> 时，<code>temp + 1</code> <strong>溢出</strong>，计数将再次从 <code>0</code> 开始，如此重复，不会出现 <code>temp</code> 大于 <code>3</code> 的情况，循环将一直被执行。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>] temp; </span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line"><span class="keyword">for</span> (temp = <span class="number">2&#x27;h0</span>; temp &lt;= <span class="number">2&#x27;h3</span>; temp = temp + <span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">  <span class="built_in">$display</span>(<span class="string">&quot;run the loop&quot;</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">$display</span>(<span class="string">&quot;finish!&quot;</span>);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>循环结束条件最好写为常数而不是变量。</p>
<h4 id="for-语句对应实际线路">for 语句对应实际线路</h4>
<p>实际的电路中是没有循环功能的，<code>for</code>语句实现的循环功能的实质是批量实现硬件功能，用形式上的循环完成了硬件上的多硬件。</p>
<p>以下是一个 <code>for</code> 循环对应的线路示例：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> test(</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">1</span>:<span class="number">0</span>] x,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] ans</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">integer</span> i;</span><br><span class="line">    <span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i = i + <span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">            ans = ans + x;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>对应线路：</p>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202309051508556.png" alt="3-4-1"></p>
<p>如上图所示，示例代码对应一个累加电路形成的组合电路，使用 3 个 LUT2 单元实现。</p>
<h3 id="while-语句">while 语句</h3>
<p>Verilog 中 <code>while</code> 语句的语法和 C 语言基本相同。下面给出一个例子：对一个 8 位二进制数中值为 1 的位进行计数</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> count1s_while(</span><br><span class="line">    <span class="keyword">input</span> clk,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>] rega,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] count</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">     <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span>: count1 <span class="comment">// 命名顺序块，建模时序逻辑</span></span><br><span class="line">        <span class="keyword">reg</span>[<span class="number">7</span>:<span class="number">0</span>] tempreg; <span class="comment">// 用作循环执行条件表达式</span></span><br><span class="line">        count = <span class="number">0</span>; <span class="comment">// count初值为0</span></span><br><span class="line">        tempreg = rega; <span class="comment">// tempreg初值为rega</span></span><br><span class="line">        <span class="keyword">while</span> (tempreg) <span class="keyword">begin</span> <span class="comment">// 若tempreg非0，则执行以下语句</span></span><br><span class="line">            <span class="keyword">if</span> (tempreg[<span class="number">0</span>]) count = count + <span class="number">1</span>; <span class="comment">// 只要trmpreg最低位为1，则count加1</span></span><br><span class="line">            tempreg = tempreg &gt;&gt; <span class="number">1</span>; <span class="comment">// 逻辑右移1位</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>在 Verilog 中所有的<strong>循环语句只能在 always 或 initial 块中使用</strong>，因此 for 语句和 while 语句不能直接出现在语句块外。</p>
<p>循环语句中即<strong>可用非阻塞赋值，也可用阻塞赋值</strong>，所以 for 语句和 while 语句既可以用于建模组合逻辑（非阻塞赋值），也可以用来建模时序逻辑（阻塞赋值）。</p>
<blockquote>
<p>能否用来建立时序逻辑的标准为能否使用阻塞赋值</p>
</blockquote>
<h3 id="时间控制语句">时间控制语句</h3>
<p>时间控制语句通常出现在测试模块中，用来产生符合期望变化的测试信号</p>
<p>这个语句通过关键字 <code>#</code> 实现延时，格式为 <strong><code>#time</code></strong>，当延时语句出现在<strong>顺序块中时它后面的语句会在延时完毕后</strong>继续执行。举例如下：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#<span class="number">3</span>;         <span class="comment">// 延迟 3 个时间单位</span></span><br><span class="line">#<span class="number">5</span> b = a;   <span class="comment">// b 为 reg 型，延迟 5 个时间单位后执行赋值语句</span></span><br><span class="line"><span class="keyword">always</span> #<span class="number">5</span> clk = ~clk;   <span class="comment">// 每过 5 个时间单位触发一次，时钟信号反转，时钟周期为 10 个时间单位</span></span><br><span class="line"><span class="keyword">assign</span> #<span class="number">5</span> b = a;        <span class="comment">// b 为 wire 型，将表达式右边的值延时 5 个时间单位后赋给 b</span></span><br></pre></td></tr></table></figure>
<h2 id="Verilog语言特性">Verilog语言特性</h2>
<h3 id="常用运算符">常用运算符</h3>
<p>Verilog HDL 中有相当多的运算符都与 C 语言基本相同，如：</p>
<ul>
<li>基本运算符：<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code> 等</li>
<li>位运算符：<code>&amp;</code>, <code>|</code>, <code>~</code>, <code>^</code>, <code>&gt;&gt;</code>, <code>&lt;&lt;</code> 等</li>
<li>逻辑运算符：<code>&amp;&amp;</code>, <code>||</code>, <code>!</code> 等</li>
<li>关系运算符：<code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code> 等</li>
<li>条件运算符：<code>? :</code></li>
</ul>
<p>这些运算的运算规则与 C 语言相同，只是在操作数中<strong>出现了不定值 <code>x</code> 和高阻值 <code>z</code> 的话最终结果可能也是带 <code>x</code> 或 <code>z</code> 的</strong>。</p>
<p>另外 Verilog 中没有自增、自减运算符。下面主要介绍其他与 C 不同的部分：</p>
<ul>
<li>
<p>逻辑右移运算符 <code>&gt;&gt;</code> 与算术右移运算符 <code>&gt;&gt;&gt;</code></p>
<p>它们的区别主要在于前者在最高位<strong>补 0</strong>，而后者在最高位<strong>补符号位</strong>，但是需要声明为有符号数<code>$signed(a)&gt;&gt;&gt;b</code>才可以。</p>
</li>
<li>
<p>相等比较运算符 <code>==</code> 与 <code>===</code> 和 <code>!=</code> 与 <code>!==</code></p>
<ul>
<li>
<p><code>==</code> 和 <code>!=</code> 可能由于不定值 <code>x</code> 和高阻值 <code>z</code> 的出现导致结果为<strong>不定值 <code>x</code></strong></p>
</li>
<li>
<p>而 <code>===</code> 和 <code>!==</code> 的结果一定是<strong>确定的 0 或 1</strong>（<code>x</code> 与 <code>z</code> 也参与比较）。</p>
</li>
</ul>
</li>
<li>
<p>阻塞赋值 <code>=</code> 和非阻塞赋值 <code>&lt;=</code></p>
<ul>
<li>
<p>这两种赋值方式被称为<strong>过程赋值</strong>，通常出现在 <code>initial</code> 和 <code>always</code> 块中，为**<code>reg</code> 型变量**赋值。不同于 <code>assign</code> 语句，赋值仅会在一个时刻执行。</p>
</li>
<li>
<p><strong>由于 Verilog 描述硬件的特性，Verilog程序内会有大量的并行</strong>，因而产生了这两种赋值方式。可以联想为寄存器形式的赋值。在<strong>描述时序逻辑</strong>时要使用非阻塞式赋值 <code>&lt;=</code> 。</p>
</li>
<li>
<p>这个是<code>b&lt;=a</code>的示意</p>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202309050859508.png" alt="b&lt;=a"></p>
</li>
</ul>
</li>
<li>
<p>位拼接运算符 <code>&#123;&#125;</code></p>
<ul>
<li>这个运算符可以将几个信号的某些位<strong>拼接</strong>起来，例如 <code>&#123;a, b[3:0], w, 3'b101&#125;;</code>；</li>
<li>可以简化重复的表达式，如 <code>&#123;4&#123;w&#125;&#125;</code> 等价于 <code>&#123;w,w,w,w&#125;</code>；</li>
<li>还可以嵌套，<code>&#123;b, &#123;3&#123;a, b&#125;&#125;&#125;</code> 等价于 <code>&#123;b, &#123;a, b, a, b, a, b&#125;&#125;</code>，也就等价于 <code>&#123;b, a, b, a, b, a, b&#125;</code>。</li>
</ul>
</li>
<li>
<p>缩减运算符</p>
<ul>
<li>运算符 <code>&amp;</code>（与）、<code>|</code>（或）、<code>^</code>（异或）等作为单目运算符是<strong>对操作数的每一位汇总运算</strong>，如对于 <code>reg[31:0] B;</code> 中的 <code>B</code> 来说，<code>&amp;B</code> 代表将 <code>B</code> 的每一位与起来得到的结果。</li>
<li>对多位数据进行运算得到单位数据</li>
</ul>
</li>
</ul>
<h3 id="有符号数和无符号数">有符号数和无符号数</h3>
<p>对于真正想要使用有符号数，需要加上<code>$signed()</code>，如：<code>c=$signed(a)&gt;$signed(b)</code>。如果一个有符号和另一个无符号做运算，则默认类型匹配为无符号数。</p>
<h4 id="原理">原理</h4>
<p>Verilog 对于符号的处理有些特殊，分为<strong>最外层表达式符号的确定</strong>与<strong>向内传播</strong>两个过程。也就是说先确定下来最终结果有无符号，再向内传播进行类型转换，诸多诡异行为的罪魁祸首就是向内传播：只要子式有无符号式，则整体表现为无符号。</p>
<p>自决定：与外部无关，自身决定符号</p>
<p>上下文决定：表达式含有其他常量/变量，符号和位宽由**“上下文”**决定</p>
<ul>
<li>这体现为一个递归问题，从内到位一次决定符号性质</li>
<li><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202309052149030.png" alt="image-20230905214957935"></li>
<li>在Verilog中， 对于数字常量的直接表示（如0，1）会被识别为32-bit的<strong>有符号</strong>整数， 对于指定位宽和进制的会被作为<strong>无符号</strong>整数。如果希望对后者的形式也作为有符号数出现，可以$signed()或者在进制声明前加入&quot;s&quot;, 改写为4’sb0</li>
</ul>
<h4 id="特殊情况">特殊情况</h4>
<p>对于布尔表达式等，Verilog 语言规定关系表达式与等式表达式属于<strong>自确定与上下文决定的中间态</strong>，具体体现为结果是自确定的，但是它们的子表达式需要相互影响。</p>
<p>对于移位运算符，其<strong>右侧的操作数总是被视为无符号数</strong>，并且不会对运算结果的符号性产生任何影响。结果的符号由运算符<strong>左侧的操作数和表达式的其余部分</strong>共同决定。</p>
<p>对于三目运算符，其<code>?</code>前的布尔表达式是自决定的表达式，不会对最外层表达式的符号造成影响。:两边会互相影响。</p>
<p>如果实在担心使用 <code>$signed()</code> 会出现意想不到的 bug，那么最简单的方式就是避开它。比如符号拓展可以写成如下</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span> [<span class="number">1</span>:<span class="number">0</span>] unsignedValue = <span class="number">2&#x27;b11</span>;</span><br><span class="line"><span class="keyword">wire</span> [<span class="number">31</span>:<span class="number">0</span>] extendedValue;</span><br><span class="line"><span class="comment">// use $signed()</span></span><br><span class="line"><span class="keyword">assign</span> extendedValue = <span class="built_in">$signed</span>(unsignedValue);</span><br><span class="line"><span class="comment">// do not use $signed()</span></span><br><span class="line"><span class="keyword">assign</span> extendedValue = &#123;<span class="number">30</span>&#123;unsignedValue[<span class="number">1</span>]&#125;,unsignedValue&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="一道有意思的题：verilog-signed-verified-2">一道有意思的题：<a target="_blank" rel="noopener" href="http://cscore.buaa.edu.cn/tutorial/verilog/verilog-3/verilog-3-7/#_5">verilog-signed_verified-2</a></h5>
<blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> a2(	</span><br><span class="line">	<span class="keyword">input</span> clk,</span><br><span class="line">	<span class="keyword">input</span> reset,</span><br><span class="line">	<span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>] a,</span><br><span class="line">	<span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>] b,</span><br><span class="line">	<span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>] ans1,</span><br><span class="line">	<span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>] ans2,</span><br><span class="line">	<span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>] ans3</span><br><span class="line">);</span><br><span class="line">	 <span class="keyword">assign</span> ans1 = (<span class="number">1&#x27;b1</span>==<span class="number">1&#x27;b1</span>) ? a&gt;&gt;&gt;b : <span class="number">0</span>;</span><br><span class="line">	 <span class="keyword">assign</span> ans2 = (<span class="number">1&#x27;b1</span>==<span class="number">1&#x27;b1</span>) ? <span class="built_in">$signed</span>(a)&gt;&gt;&gt;b : <span class="number">0</span>;</span><br><span class="line">	 <span class="keyword">assign</span> ans3 = (<span class="number">1&#x27;b1</span>==<span class="number">1&#x27;b1</span>) ? <span class="built_in">$signed</span>(a)&gt;&gt;&gt;b : <span class="number">4&#x27;b0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>Testbench部分内容如下所示：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line"><span class="comment">// Initialize Inputs</span></span><br><span class="line">clk = <span class="number">0</span>;</span><br><span class="line">reset = <span class="number">0</span>;</span><br><span class="line">a = <span class="number">0</span>;</span><br><span class="line">b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Wait 100 ns for global reset to finish</span></span><br><span class="line">#<span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add stimulus here</span></span><br><span class="line">a=<span class="number">3</span>;</span><br><span class="line">b=<span class="number">1</span>;</span><br><span class="line">#<span class="number">2</span>;</span><br><span class="line">a=-<span class="number">2</span>;</span><br><span class="line">b=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>T1. 在101ns和103ns时，ans1的值分别为（ ）。</p>
<p>A 4‘b0001;4’b0111	B 4’b0001;4’b1111	C 4’b1001;4’b0111	D 4’b1001;4’b1111</p>
<p>T2. 在101ns和103ns时，ans2的值分别为（ ）。</p>
<p>A 4‘b0001;4’b0111	B 4’b0001;4’b1111	C 4’b1001;4’b0111	D 4’b1001;4’b1111</p>
<p>T3. 在101ns和103ns时，ans3的值分别为（ ）。</p>
<p>A 4‘b0001;4’b0111	B 4’b0001;4’b1111	C 4’b1001;4’b0111	D 4’b1001;4’b1111</p>
</blockquote>
<p>答案：ABA</p>
<p>解析：这道题三种情况表示了有符号数的表达式向内扩散。 &gt;&gt;&gt; 运算符的意义是符号右移。</p>
<ul>
<li>ans1 的性质较好确定，整个表达式都是无符号的，所以最高位不会添加 1。</li>
<li>ans2 与 ans3 的主要区别在于 : 后面是 0 还是 4’b0。
<ul>
<li>若是 0 则<strong>默认当作有符号数</strong>，则整个表达式被决定为有符号表达式。拓展时是符号拓展。</li>
<li>而 ans3 中有一个原子表达式 4’b0 是无符号的，这样整个表达式都决定为无符号表达式，对于有符号的需要强制类型转换。</li>
</ul>
</li>
</ul>
<h3 id="宏定义的简单使用">宏定义的简单使用</h3>
<p>在 Verilog HDL 语言中，为了和一般的语句相区别，编译预处理命令以符号` （反引号，backtick）开头。</p>
<p>宏定义的一般形式为：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">define</span> 标识符(宏名) 字符串(宏内容)</span></span><br></pre></td></tr></table></figure>
<p>注意，<strong>引用宏名</strong>时也必须在宏名前加上符号 `，以表明该名字是经过宏定义的名字。</p>
<h3 id="编写testbench">编写testbench</h3>
<p>Testbench（测试器）其<strong>本质是一个 module</strong>，用于测试已编写好的 module 的正确性，可以将其看作一个“驱动装置”。可以为其添加临时变量，组合逻辑等内容来辅助仿真。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> alu_tb;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Inputs</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">31</span>:<span class="number">0</span>] input_a;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">31</span>:<span class="number">0</span>] input_b;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>] op;</span><br><span class="line">    <span class="keyword">reg</span> clk;</span><br><span class="line">    <span class="keyword">reg</span> en;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Outputs</span></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">31</span>:<span class="number">0</span>] result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Instantiate the Unit Under Test (UUT)</span></span><br><span class="line">    alu uut (</span><br><span class="line">        <span class="variable">.input_a</span>(input_a), </span><br><span class="line">        <span class="variable">.input_b</span>(input_b), </span><br><span class="line">        <span class="variable">.op</span>(op), </span><br><span class="line">        <span class="variable">.clk</span>(clk), </span><br><span class="line">        <span class="variable">.en</span>(en), </span><br><span class="line">        <span class="variable">.result</span>(result)</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">always</span> #<span class="number">10</span> clk=~clk;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// Initialize Inputs</span></span><br><span class="line">        input_a = <span class="number">0</span>;</span><br><span class="line">        input_b = <span class="number">0</span>;</span><br><span class="line">        op = <span class="number">0</span>;</span><br><span class="line">        clk = <span class="number">0</span>;</span><br><span class="line">        en = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Wait 100 ns for global reset to finish</span></span><br><span class="line">        #<span class="number">100</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<ul>
<li>标注有“Inputs”和“Outputs”注释的地方，是我们模块输入输出端口的转化，其中仿真模板将输入用<code>reg</code>变量替代，便于我们直接对其值进行设置。</li>
<li><strong><code>initial</code>语句块</strong>是需要修改的部分，使用关键字“#”开头的延迟控制语句进行<strong>时间控制</strong>，将输入端口在不同的时间赋予我们期望的数据。请注意，该语句声明的是<strong>延迟时间</strong>，而不是整个仿真过程的时间戳。</li>
</ul>
<h3 id="模块实例化">模块实例化</h3>
<p>模块实例化的目的是方便其他模块调用。</p>
<p>对电路元件模块实例化最常见的语法是：<code>&lt;模块名&gt; &lt;实例名&gt;(端口信号映射);</code>。</p>
<p>其中，端口信号映射方式也有两种：</p>
<ul>
<li><strong>位置映射：</strong><code>&lt;模块名&gt; &lt;实例名&gt;(信号 1, 信号 2, ...);</code>，其中信号 n 对应被实例化模块声明时排在第 n 位的端口。</li>
<li><strong>名映射：</strong><code>&lt;模块名&gt; &lt;实例名&gt;(.端口名 a(信号 1), .端口名 b(信号 2), ...);</code>，其中信号 n 对应其前的端口名。</li>
</ul>
<p>值得注意的是，在实例化元件时，<code>wire</code> 类型信号可以被连接至<strong>任意端口</strong>上，但 <code>reg</code> 类型的信号只能被连接至元件的<strong>输入端口</strong>上。在声明元件时，我们可以将任意端口声明为 <code>wire</code> 类型，但只能将输出端口声明为 <code>reg</code> 类型，否则会出现问题。</p>
<p>我们也可以悬空部分不需要连接的端口，下图的<code>uut_0</code>、<code>uut_1</code>、<code>uut_2</code>分别对应位置映射、名映射与悬空端口的实例。建议<strong>每一行只连接一个端口信号</strong>避免混乱。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Instance the Unit Under Test (UUT)</span></span><br><span class="line">alu uut_0 (</span><br><span class="line">    input_a,</span><br><span class="line">    input_b,</span><br><span class="line">    op,</span><br><span class="line">    clk,</span><br><span class="line">    en,</span><br><span class="line">    result</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">alu uut_1 (</span><br><span class="line">    .input_a(input_a),</span><br><span class="line">    <span class="selector-class">.input_b</span>(input_b),</span><br><span class="line">    <span class="selector-class">.op</span>(op),</span><br><span class="line">    <span class="selector-class">.clk</span>(clk),</span><br><span class="line">    <span class="selector-class">.en</span>(en),</span><br><span class="line">    <span class="selector-class">.result</span>(result)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">alu uut_2 (</span><br><span class="line">    .input_a(input_a),</span><br><span class="line">    <span class="selector-class">.clk</span>(clk),</span><br><span class="line">    <span class="selector-class">.result</span>(result)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="编译预处理">编译预处理</h3>
<h4 id="define">define</h4>
<p>编译预处理，可以类比 C 语言中的 <code>#define</code> 等语句。即用一个指定的标识符来代表一个字符串，一般形式为：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">define</span> 标识符(宏名) 字符串(宏内容)</span></span><br></pre></td></tr></table></figure>
<p>如：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">define</span> signal string</span></span><br></pre></td></tr></table></figure>
<p>它的作用是指定用标识符 signal 来代替 string 这个字符串，在编译预处理时，把程序中该命令以后所有的 signal 都替换成 string。</p>
<h4 id="include">include</h4>
<p>在编译的时候，需要对 <code>include</code> 命令进行&quot;文件包含&quot;预处理：将 File2.v 的全部内容复制插入到 <code>include &quot;File2.v&quot;</code> 命令出现的地方，即使 File2.v 被包含到 File1.v 中。在接着往下进行编译中，将&quot;包含&quot;以后的 File1.v 作为一个源文件单位进行编译。</p>
<p><strong>注意</strong>：</p>
<ol>
<li>
<p>可以将多个 <code>include</code> 命令写在一行，这一行除 <code>include</code> 命令以外，只可以含有空格和单行注释。例如下面的写法是合法的：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`<span class="keyword">include</span> <span class="string">&quot;fileB&quot;</span> `<span class="keyword">include</span> <span class="string">&quot;fileC&quot;</span> <span class="comment">// including fileB and fileC</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>如果文件 1 包含文件 2，而文件 2 要用到文件 3 的内容，则可以在文件 1 用两个 ``include` 命令分别包含文件 2 和文件 3，而且文件 3 应出现在文件 2 之前。</p>
</li>
<li>
<p>不能有同名模块，因而在<code>include</code>时要注意</p>
</li>
</ol>
<h4 id="timescale">timescale</h4>
<p><code>timescale</code> 命令用来说明跟在该命令后的模块的时间单位和时间精度。使用 <code>timescale</code> 命令可以在同一个设计里包含采用了不同的时间单位的模块。例如，一个设计中包含了两个模块，其中一个模块的时间延迟单位为纳秒 (ns)，另一个模块的时间延迟单位为皮秒 (ps)。EDA 工具仍然可以对这个设计进行仿真测试。</p>
<p><code>timescale</code> 命令的格式如下：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`<span class="selector-tag">timescale</span> <span class="selector-attr">[时间单位]</span>/<span class="selector-attr">[时间精度]</span></span><br></pre></td></tr></table></figure>
<h4 id="条件编译命令-ifdef-else-elsif-endif-ifndef">条件编译命令 <code>ifdef, else, elsif, endif, ifndef</code></h4>
<p>这些条件编译编译指令用于编译期间的源描述。</p>
<p><code>ifdef</code> 编译器指令检查 text_macro_name 的定义，如果定义了 text_macro_name，那么 <code>ifdef</code> 指令后面的行被包含在内。如果未定义 text_macro_name 并且存在 <code>else</code> 指令，则编译 <code>else</code> 后的源描述。</p>
<p><code>ifndef</code> 编译器指令检查 text_macro_name 的定义。如果未定义 text_macro_name，则包含 <code>ifndef</code> 指令后面的行。</p>
<p>如果定义了 text_macro_name 并且存在 <code>else</code> 指令，则编译 <code>else</code> 后的源描述。如果 <code>elsif</code> 指令存在（注意不是 <code>else</code>），编译器会检查 text_macro_name 的定义。如果定义存在，则包含 <code>elsif</code> 指令后面的行。</p>
<p><code>elseif</code> 指令等同于<strong>编译器指令序列</strong> <code>else,ifdef ...endif</code>。该指令<strong>不需要相应的 <code>endif</code>指令</strong>。该指令必须以 <code>ifdef</code> 或 <code>ifndef</code> 指令开头。</p>
<h3 id="系统任务">系统任务</h3>
<p>Verilog 中还提供了很多系统任务，类似于 C 中的库函数，使用这些系统任务可以方便地<strong>进行测试</strong>。</p>
<p>在此仅对 <code>$display</code>, <code>$monitor</code>, <code>$readmemh</code> 进行介绍。</p>
<h4 id="输出信息">输出信息</h4>
<p>格式：<code>$display(p1, p2, ..., pn)</code>;</p>
<p>这个系统任务的作用是用来输出信息，即将参数 p2 到 pn 按参数 p1 给定的格式输出。用法和 C 语言中的 <code>printf</code> 类似。下面用一个例子简单介绍其用法。</p>
<p>例如：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> disp;</span><br><span class="line">    <span class="keyword">reg</span>[<span class="number">4</span>:<span class="number">0</span>] a;</span><br><span class="line">    <span class="keyword">reg</span>[<span class="number">4</span>:<span class="number">0</span>] b;</span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        a = <span class="number">10</span>;</span><br><span class="line">        b = <span class="number">20</span>;</span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;a = %d,b = %d\n&quot;</span>,a,b);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>其输出结果为： a = 10,b = 20</p>
<p>其中 <code>%d</code> 表示以十进制的形式输出，<code>\n</code> 为换行符。</p>
<p>在此说明几种常用的输出格式：</p>
<table>
<thead>
<tr>
<th>输出格式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>%h 或 %H</td>
<td>以十六进制数的形式输出</td>
</tr>
<tr>
<td>%d 或 %D</td>
<td>以十进制数的形式输出</td>
</tr>
<tr>
<td>%b 或 %B</td>
<td>以二进制数的形式输出</td>
</tr>
<tr>
<td>%c 或 %C</td>
<td>以 ASCII 码字符的形式输出</td>
</tr>
<tr>
<td>%s 或 %S</td>
<td>以字符串的形式输出</td>
</tr>
</tbody>
</table>
<h4 id="监控变量">监控变量</h4>
<p>格式：</p>
<ul>
<li><code>$monitor(p1, p2, ..., pn);</code></li>
<li><code>$monitor;</code></li>
<li><code>$monitoron;</code></li>
<li><code>$monitoroff;</code></li>
</ul>
<p>任务 <code>$monitor</code> 提供了<strong>监控和输出参数列表中的表达式或变量值</strong>的功能。其参数列表中输出控制格式字符串和输出列表的规则和 <code>$display</code> 中的一样。</p>
<p>当启动带有一个或多个参数的 <code>$monitor</code> 任务时，仿真器则建立一个处理机制，使得每当<strong>参数列表中变量或表达式的值发生变化时</strong>，整个参数列表中变量或表达式的值都将输出显示。</p>
<p>如果同一时刻，两个或多个参数的值发生变化，则在该时刻<strong>只输出显示一次</strong>。</p>
<p><code>$monitoron</code> 和 <code>$monitoroff</code> 任务的作用是通过<strong>打开和关闭监控标志来控制监控任务 <code>$monitor</code> 的启动和停止</strong>，这样使得程序员可以很容易地控制 <code>$monitor</code> 何时发生。其中 <code>$monitoroff</code> 任务用于关闭监控标志，停止监控任务 <code>$monitor</code> ， <code>$monitoron</code> 则用于打开监控标志，启动 <code>$monitor</code> 监控任务。</p>
<p><code>$monitor</code> 与 <code>$display</code> 的不同处还在于 <code>$monitor</code> 往往在 <code>initial</code> 块中调用，只要不调用 <code>$monitoroff</code>， <code>$monitor</code> 便<strong>不间断地对所设定的信号进行监视</strong>。</p>
<h4 id="读取文件到存储器">读取文件到存储器</h4>
<p>格式：</p>
<ul>
<li><code>$readmemh(&quot;&lt;数据文件名&gt;&quot;, &lt;存储器名&gt;);</code></li>
<li><code>$readmemh(&quot;&lt;数据文件名&gt;&quot;, &lt;存储器名&gt;, &lt;起始地址&gt;);</code></li>
<li><code>$readmemh(&quot;&lt;数据文件名&gt;&quot;, &lt;存储器名&gt;, &lt;起始地址&gt;, &lt;结束地址&gt;);</code></li>
</ul>
<p>功能： <code>$readmemh</code> 函数会根据绝对/相对路径找到需要访问的文件，<strong>按照 ASCII 的解码方式</strong>将文件字节流解码并读入容器。</p>
<p>文件中的内容<strong>必须是十六进制数字 0~f 或是不定值 x，高阻值 z（字母大小写均可）</strong>，不需要前导 0x，不同的数用空格或换行隔开。</p>
<p>假设存储器名为<code>arr</code>，起始地址为<code>s</code>，结束地址为<code>d</code>，那么文件中用空格隔开的数字会依次读入到 <code>arr[s],arr[s+1]... </code>到 <code>arr[d]</code>。假如数字的位数大于数组元素的位数，那么<strong>只有低位会被读入，剩下的高位会被忽略</strong>。</p>
<p>此系统任务用来从文件中读取数据到存储器中，类似于 C 语言中的 <code>fread</code> 函数。</p>
<p>例如：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> im;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">31</span>:<span class="number">0</span>] im_reg [<span class="number">0</span>:<span class="number">2047</span>];</span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="built_in">$readmemh</span>(<span class="string">&quot;code.txt&quot;</span>, im_reg);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>仿真后即可将 code.txt 中的内容读入 <code>im_reg</code> 存储器中。</p>
<h3 id="层次化事件队列">层次化事件队列</h3>
<p>在 Verilog 的语法中，以 <code>begin-end</code> 为开头结尾的代码块被称作顺序块，也就是说从细节上理解-其中代码执行是按顺序进行的。但是实例中我们又称 <code>always</code> 块中的非阻塞赋值是“<strong>并发执行</strong>”的，从概念上似乎出现了矛盾。</p>
<p>其实，<strong>“并发执行”并不是运行规则，而是运行规则作用后的外在效果，真正的规则实际上是 Verilog 代码运行时的层次化事件队列</strong>。</p>
<p>层次化事件队列是硬件仿真（Simulation）时，用于规定“不同事件执行的优先级关系”。根据事件的优先级，Verilog 将其分为 4 个队列：队列间的优先级不同，从上到下优先级依次递减，只有<strong>当优先级高的队列中所有任务完成后</strong>，才会继续完成优先级较低的任务</p>
<ol>
<li>动态事件队列：动态事件队列在队列内部执行顺序无硬性规定，但在同一个<code>begin-end</code>语句块中的语句应当严格按照源代码中的顺序执行；且多个非阻塞赋值应当按照语句执行顺序进行
<ul>
<li>阻塞赋值</li>
<li>计算非阻塞赋值语句右边的表达式（<code>RHS</code>）</li>
<li>连续赋值（如 <code>assign</code>）</li>
<li>执行 <code>display</code> 命令</li>
</ul>
</li>
<li>停止运行的时间队列（#0）</li>
<li>非阻塞事件队列：更新非阻塞赋值语句 LHS（左边变量）的值。</li>
<li>监控事件队列（执行 <code>monitor</code>，<code>strobe</code> 命令）</li>
</ol>
<blockquote>
<p>在<code>Verilog</code>或<code>System Verilog</code>中，在一个 <code>always</code> 语句块中<strong>同时使用阻塞赋值和非阻塞赋值</strong>可能会引入不可预测的行为和硬件仿真问题。这种混合使用可能导致以下问题：</p>
<ol>
<li>冲突和竞争条件：阻塞赋值和非阻塞赋值有不同的优先级和执行顺序。当它们同时存在时，<strong>可能会引发信号赋值的竞争条件，这可能会导致不确定的电路行为</strong>。这可能会使仿真结果与预期不符，或者在实际硬件中引发问题。</li>
<li>代码可读性差：混合使用阻塞和非阻塞赋值会增加代码的复杂性，降低可读性。这会使代码更难以理解和维护，因为开发人员需要考虑不同赋值方式之间的交互。</li>
<li>不确定的延迟：<strong>阻塞赋值通常会引入更多的延迟</strong>，因为它们会等待前一个赋值完成后才会执行下一个。非阻塞赋值则可以并行执行。因此，混合使用这两种方式可能导致不确定的延迟，使设计变得更加复杂。</li>
</ol>
<p>为了避免这些问题，通常建议在一个 <code>always</code> 语句块中只使用一种赋值方式，以确保代码的可预测性和可维护性。选择使用阻塞赋值还是非阻塞赋值取决于设计的需求和意图。</p>
<p>通常情况下，<strong>非阻塞赋值更适合用于描述时钟边沿触发的行为，而阻塞赋值更适合用于组合逻辑</strong>。</p>
</blockquote>
<h3 id="default-nettype">default nettype</h3>
<p><code>Verilog</code>的默认缺省类型是 <code>wire</code>，如果我们不对某个变量显式声明类型或显式定义，而直接使用，该变量将会被默认地设为 <code>wire</code> 类型。</p>
<p><strong>如果在使用该变量之后再对该变量显式声明，则变量的类型以之后显式声明的类型为准。</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> test(<span class="keyword">input</span> <span class="keyword">wire</span>[<span class="number">3</span>:<span class="number">0</span>] temp);</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] a;</span><br><span class="line">    <span class="keyword">assign</span> a=<span class="number">4&#x27;b1000</span>;</span><br><span class="line">    <span class="keyword">assign</span> b=a;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] b;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>在这个示例中，b 的值变成了 <code>4'b1000</code>。在语法检查或仿真时，可以看到编译器产生了如下警告：</p>
<blockquote>
<p>WARNING:HDLCompiler:35 - “test.v” Line N: &lt;b&gt; is already implicitly declared earlier.</p>
</blockquote>
<p>这一语法特性容易造成一个问题：如果我们在对模块进行连接的时候，忘记对于某一个变量进行定义，或将变量名打错，如将 alu 打成 aiu，则该变量将会默认被定义为 1 位宽的 <code>wire</code> 类型，造成意料之外的 bug。</p>
<p>这时有一种解决方法：使用 ``default_nettype`。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> test(<span class="keyword">input</span> temp);</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] a;</span><br><span class="line">    <span class="keyword">assign</span> a=<span class="number">4&#x27;b1000</span>;</span><br><span class="line">    <span class="keyword">assign</span> b=a;</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"><span class="meta">`<span class="keyword">default_nettype</span> none</span></span><br></pre></td></tr></table></figure>
<p><code>default_nettype</code> 用于<strong>设置缺省类型</strong>，在代码文件的任意位置加入 <code>default_nettype</code> 宏，都可以使得该代码文件中所有变量的缺省类型改变。若代码中有两个以上的 <code>default_nettype</code> 宏，则将会以最后一条为准。</p>
<p><strong>若需要取消缺省类型，即若不显式声明类型就会报错，则应该使用 ``default_nettype none`。未显式指定类型而报错。</strong></p>
<h3 id="函数">函数</h3>
<p>函数用关键词 <code>function</code> 声明，并用 <code>endfunction</code> 结束，<strong>不允许输出端口声明（包括输出和双向端口）</strong>，但可以有多个输入端口。函数只返回一个值到函数被调用的位置，并且在函数中返回值与函数名同名。</p>
<p>函数的定义如下所示：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> [range] function_id; </span><br><span class="line">  input_declaration</span><br><span class="line">  other_declarations </span><br><span class="line">  procedural_statement </span><br><span class="line"><span class="keyword">endfunction</span></span><br></pre></td></tr></table></figure>
<p>在使用函数时有以下几点需要注意：</p>
<ol>
<li>函数定义<strong>只能在模块中完成，不能出现在过程块中</strong>；</li>
<li>函数至少要有一个输入端口；不能包含输出端口和双向端口；</li>
<li>在函数结构中， 不能使用任何形式的时间控制语句 （<code>#</code>、<code>wait</code> 等） ， 也不能使用 <code>disable</code> 中止语句；</li>
<li>函数定义结构体中不能出现过程块语句（<code>always</code> 语句）；</li>
<li>函数内部可以调用函数，但不能调用任务。</li>
</ol>
<p>一个简单的例子：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> comb15 (A, B, CIN, S, COUT);</span><br><span class="line">  <span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>] A, B;</span><br><span class="line">  <span class="keyword">input</span> CIN;</span><br><span class="line">  <span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>] S;</span><br><span class="line">  <span class="keyword">output</span> COUT;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">wire</span> [<span class="number">1</span>:<span class="number">0</span>] S0, S1, S2, S3;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="keyword">signed</span> [<span class="number">1</span>:<span class="number">0</span>] ADD;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">input</span> A, B, CIN;</span><br><span class="line">    <span class="keyword">reg</span> S, COUT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">      S = A ^ B ^ CIN;</span><br><span class="line">      COUT = (A&amp;B) | (A&amp;CIN) | (B&amp;CIN);</span><br><span class="line">      ADD = &#123;COUT, S&#125;;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">assign</span> S0 = ADD (A[<span class="number">0</span>], B[<span class="number">0</span>], CIN),</span><br><span class="line">  S1 = ADD (A[<span class="number">1</span>], B[<span class="number">1</span>], S0[<span class="number">1</span>]),</span><br><span class="line">  S2 = ADD (A[<span class="number">2</span>], B[<span class="number">2</span>], S1[<span class="number">1</span>]),</span><br><span class="line">  S3 = ADD (A[<span class="number">3</span>], B[<span class="number">3</span>], S2[<span class="number">1</span>]),</span><br><span class="line">  S = &#123;S3[<span class="number">0</span>], S2[<span class="number">0</span>], S1[<span class="number">0</span>], S0[<span class="number">0</span>]&#125;,</span><br><span class="line">  COUT = S3[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>在函数调用中，有下列几点需要注意：</p>
<ol>
<li>函数调用可以在过程块中完成，也可以在 <code>assign</code> 这样的连续赋值语句中出现。</li>
<li>函数调用语句不能单独作为一条语句出现，<strong>只能作为赋值语句的右端操作数</strong>。</li>
</ol>
<h2 id="可综合的Verilog代码">可综合的Verilog代码</h2>
<p>像 Verilog 这样的 HDL 语言，只有当编写的 Verilog 代码能被准确地综合成硬件，它才是有意义的。</p>
<h3 id="不要用-initial-块、不要为寄存器赋初值">不要用 initial 块、不要为寄存器赋初值</h3>
<p>在真实的电路中没有初始化赋值。<code>initial</code> 块用于在仿真开始时对寄存器进行初始化、执行其他代码。在综合时，<code>initial</code> 块会被忽略，不起任何作用，且为 reg 指定的初始值也会被忽略。</p>
<p>如果你想在模块开始运行时，对寄存器进行一些初始化，请使用 reset 信号控制复位，并在 Testbench 开始的部分提供一个 reset 信号。例如，代码正确写法为：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (reset) <span class="keyword">begin</span></span><br><span class="line">        v &lt;= <span class="number">6</span>;</span><br><span class="line">        m &lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>Testbench 正确的写法：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span> clk = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">reg</span> reset = <span class="number">0</span>;		<span class="comment">// 只有在tb中可以直接赋初值</span></span><br><span class="line"><span class="keyword">always</span> #<span class="number">5</span> clk = ~ clk; 	<span class="comment">// 创建周期为10的时钟</span></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    reset = <span class="number">1</span></span><br><span class="line">    # <span class="number">10</span> 	<span class="comment">// 延时一个时钟周期</span></span><br><span class="line">    reset = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 接下来开始你的测试</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="一个寄存器只能在一个-always-块中赋值一次">一个寄存器只能在一个 always 块中赋值一次</h3>
<p>Verilog 综合时，寄存器通常会被综合为 D 触发器：</p>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202309061529585.png" alt="image-20230906152954469"></p>
<p>可以看到，D 触发器只有一个时钟输入、一个数据输入。因此，每个寄存器只能属于一个时钟域（“时钟域”指驱动触发器更新的时钟所表示的“范围”）。</p>
<p>除了注意时钟域的归属外，我们也需保证在每个时钟周期中，寄存器被至多赋值一次，不能重复赋值。</p>
<p>需要注意的是“赋值一次”的含义。如果使用 <code>if</code> / <code>else</code> / <code>case</code> 语句进行条件判断，在<strong>不同且互斥</strong>的情况下对同一个寄存器进行赋值，是完全合法的。虽然这里出现了两条对 <code>d</code> 进行赋值的语句，但这两条语句是“互斥”的，并不会对 <code>d</code> 重复赋值。上面的代码会被综合成如下的硬件（if的硬件含义是MUX多路选择器）：</p>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202309061530290.png" alt="image-20230906153012170"></p>
<h3 id="组合逻辑相关注意事项">组合逻辑相关注意事项</h3>
<p>我们一般会将代码分为“时序逻辑”和“组合逻辑”。时序逻辑使用 <code>@(posedge clk)</code> 来表达，而组合逻辑使用 <code>@(*)</code> 来表达。在编写组合逻辑时，依照以下准则编写代码，可避免综合后产生奇怪的故障。</p>
<ol>
<li>在时序逻辑中，永远使用非阻塞赋值（<code>&lt;=</code>）；在组合逻辑中，永远使用阻塞赋值（<code>=</code>）；</li>
<li>每个组合逻辑运算结果仅在一个 <code>always @(*)</code> 中修改；</li>
<li>在 <code>always @(*)</code> 中，为每个运算结果赋初值，避免 latch 的产生。</li>
</ol>
<p>一段示例代码如下。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意以下 count_n 并不是一个寄存器，而是由组合逻辑生成的运算结果；count 才是实际存放计数值的寄存器。</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">4</span>:<span class="number">0</span>] count_n, count;</span><br><span class="line"><span class="keyword">wire</span> add, set;</span><br><span class="line"><span class="keyword">wire</span> [<span class="number">4</span>:<span class="number">0</span>] set_value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">    count_n = count; <span class="comment">// 修改了 count_n，因此先赋初值</span></span><br><span class="line">    <span class="keyword">if</span> (set)</span><br><span class="line">        count_n = set_value;</span><br><span class="line">    <span class="keyword">if</span> (add)</span><br><span class="line">        count_n = count_n + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 阻塞赋值类似于 C 语言，按顺序执行，以最后赋值的为准</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (reset)</span><br><span class="line">        count &lt;= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        count &lt;= count_n;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="综合的其他要求">综合的其他要求</h3>
<p>与仿真不同的常见综合化要求包括但不限于：</p>
<ul>
<li>不使用 <code>initial</code>、<code>fork</code>、<code>join</code>、<code>casex</code>、<code>casez</code>、延时语句（例如 <code>#10</code>）、系统任务（例如 <code>$display</code>）等语句，具体可自行查阅学习。</li>
<li>用 <code>always</code> 过程块描述<strong>组合逻辑</strong>时，应在敏感信号列表中列出<strong>所有的输入信号（或使用星号*）</strong>。</li>
<li>用 <code>always</code> 过程块描述<strong>时序逻辑</strong>时，敏感信号只能为<strong>时钟信号</strong>。</li>
<li>所有的内部寄存器都应该能够被复位。</li>
<li>不能在一个以上的 <code>always</code> 过程块中对<strong>同一个变量</strong>赋值。而对同一个赋值对象不能既使用阻塞式赋值，又使用非阻塞式赋值。</li>
<li>尽量避免出现锁存器（latch），具体避免方法有许多。例如，如果不打算把变量推导成锁存器，那么必须在 <code>if</code> 语句或 <code>case</code> 语句的所有条件分支中都对变量明确地赋值。</li>
<li>避免混合使用上升沿和下降沿触发的触发器。</li>
</ul>
<h2 id="System-verilog">System verilog</h2>
<h3 id="logic">logic</h3>
<p><code>reg</code> 变量好像暗指用时序逻辑的触发器搭建的硬件”寄存器”，然而<strong>实际上，<code>reg</code> 变量跟推断出的硬件没有任何关系</strong>.</p>
<p>System Verilog 使用更直观的 <code>logic</code> 关键字来描述通用的针对硬件的数据类型。我们将会看到你可以在过去 Verilog 中用 <code>reg</code> 型或是 <code>wire</code> 型的地方用 <code>logic</code> 型来代替。编译器可自动推断 <code>logic</code> 是 <code>reg</code> 还是 <code>wire</code>。</p>
<p>即 <code>logic</code> 是对 <code>reg</code>，<code>wire</code> 数据类型的改进，使得它除了作为一个变量之外，还可以被连续赋值、门单元和模块所驱动，显然，<code>logic</code> 是一个更合适的名字。</p>
<p>但以上的等同是在单驱动的情况下，因为 <code>logic</code> 只允许一个输入，<code>wire</code> 则无此限制。所以如果是多驱动的情况下，<code>logic</code> 和 <code>wire</code> 就不等同了。</p>
<h3 id="新变量">新变量</h3>
<p><code>bit</code>——1 位两态整数。</p>
<p><code>byte</code>——8 位两态整数，类似于C语言的 char。</p>
<p><code>shortint</code>——16 位两态整数，类似于C语言的 short。</p>
<p><code>int</code>——32 位两态整数，类似于C语言的 int。</p>
<p><code>longint</code>——64 位两态整数，类似于C语言的 longlong。</p>
<h3 id="always">always</h3>
<p>在旧版本的 Verilog 中只有一个通用的 <code>always</code> 过程块，System Verilog 中追加了三个具有更明确目的专用 <code>always</code> 块：<code>always_ff</code>， <code>always_comb</code>， <code>always_latch</code>。</p>
<p>与原始的 <code>always</code> 块一样，这三个新的东西也是无限循环过程块,即每一个仿真周期都执行。</p>
<p>相比于 Verilog 简单的 <code>always</code>，System Verilog 对其进行了细化，看似多此一举其实是有合理性的，三个新的 <code>always</code> 块是专门针对可综合性 RTL 逻辑建模而定义的：</p>
<p><code>always_comb</code> 用于<strong>可综合组合逻辑</strong>的建模。</p>
<p><code>always_ff</code> 用于<strong>可综合时序逻辑</strong>的建模。</p>
<p><code>always_latch</code> 用于<strong>锁存器</strong>的建模。</p>
<p><strong>即：可以简单认为 <code>always_comb</code> 是 <code>always @(\*)</code> 的平替，<code>always_ff @(posedge clk)</code> 是 <code>always @(posedge clk)</code> 的平替。</strong></p>
<h3 id="改进的case语句">改进的case语句</h3>
<p>Verilog 的 <code>case</code> 语句允许在多个选项中选择一个逻辑分支。</p>
<p>在 System Verilog 中，我们当然可以继续使用 <code>case</code> 语句，但是这里也引入了两种新的<code>case</code> 语句：</p>
<p><code>unique case</code> 和 <code>priority case</code>。</p>
<h4 id="unique">unique</h4>
<p>该语句指定：</p>
<p>1.只有一个条件选项与条件表达式匹配。</p>
<p>2.必须有一个条件选项与条件表达式匹配。</p>
<p>这并不意味着我们不再需要 default 语句，相反，由于在复杂工程下我们很可能忘掉某些条件选项，所以 default 反而是必须的。这也同时为了防止锁存器的出现。</p>
<p>在这种语句下，每一个选项可以被并行执行判断，极大的提高了判断的效率。</p>
<h4 id="priority">priority</h4>
<p>该语句指定：</p>
<ul>
<li>
<p>至少有一个条件选项的值与条件表达式匹配。</p>
</li>
<li>
<p>如果有多个条件选项的值与条件表达式匹配，必须执行第一个匹配分支。</p>
</li>
</ul>
<p>写法方面，由于这个和一般的 case 有所区别，所以给出样例：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always_comb</span></span><br><span class="line">    <span class="keyword">priority</span> <span class="keyword">case</span> (<span class="number">1&#x27;b1</span>)</span><br><span class="line">        irq0: irq = <span class="number">4&#x27;b0001</span>;</span><br><span class="line">        irq1: irq = <span class="number">4&#x27;b0010</span>;</span><br><span class="line">        irq2: irq = <span class="number">4&#x27;b0100</span>;</span><br><span class="line">        irq3: irq = <span class="number">4&#x27;b1000</span>;</span><br><span class="line">    <span class="keyword">endcase</span></span><br></pre></td></tr></table></figure>
<p>可以看出，<strong>常量取代了原来 case 中变量的位置，变量取代了 case 中常量的位置</strong>。 这个可以取代对一个变量进行 <code>if，else if，else if，else</code> 的判断过程。</p>
<h3 id="全面C语言化">全面C语言化</h3>
<p>System Verilog 加入了很多十分类 C 的语句，主要如下：</p>
<h4 id="break">break</h4>
<p>类似于 C 语言，会立即终止循环的执行。</p>
<h4 id="continue">continue</h4>
<p>类似于 C 语言，会跳转到循环的结尾然后执行循环控制。</p>
<h4 id="return">return</h4>
<p>类似于 C 语言，用来<strong>从非空函数返回或从空函数或任务中跳出</strong>。</p>
<h4 id="typedef">typedef</h4>
<p>基本格式为： <code>typedef</code> 已有类型 新类型</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> logic[<span class="number">31</span>:<span class="number">0</span>] <span class="type">word_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> logic[<span class="number">31</span>:<span class="number">0</span>] <span class="type">entry_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">entry_t</span>[<span class="number">31</span>:<span class="number">0</span>] <span class="type">table_t</span>; <span class="comment">//数组来了</span></span><br></pre></td></tr></table></figure>
<h4 id="struct">struct</h4>
<p>结构体 <code>struct</code> 可以描述一组相关的数据。</p>
<p>以译码器为例，按以前 Verilog 写法，可能需要这样写：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">logic</span> [<span class="number">3</span>:<span class="number">0</span>] alufunc;</span><br><span class="line"><span class="keyword">logic</span> mem_read;</span><br><span class="line"><span class="keyword">logic</span> mem_write;</span><br><span class="line"><span class="keyword">logic</span> regwrite;</span><br><span class="line"><span class="keyword">logic</span> [<span class="number">6</span>:<span class="number">0</span>] control;</span><br><span class="line"><span class="keyword">assign</span> control = &#123;alufunc,mem_read,mem_write,regwrite&#125;;</span><br></pre></td></tr></table></figure>
<p>在 System Verilog中，利用 <code>struct</code> 我们可以这样写：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="keyword">packed</span> &#123;</span><br><span class="line">    <span class="keyword">logic</span> [<span class="number">3</span>:<span class="number">0</span>] alufunc;</span><br><span class="line">    <span class="keyword">logic</span> mem_read;</span><br><span class="line">    <span class="keyword">logic</span> mem_write;</span><br><span class="line">    <span class="keyword">logic</span> regwrite;</span><br><span class="line">&#125; control_t;</span><br><span class="line"></span><br><span class="line">control_t control = &#x27;&#123;<span class="number">4&#x27;b1111</span>,<span class="number">1&#x27;b0</span>,<span class="number">1&#x27;b1</span>,<span class="number">1&#x27;b1</span>&#125;; <span class="comment">//赋值</span></span><br><span class="line">control_t control = &#x27;&#123;alufenc : <span class="number">4&#x27;b1111</span>,mem_read : <span class="number">1&#x27;b0</span>, mem_write: <span class="number">1&#x27;b1</span>,regwrite : <span class="number">1&#x27;b1</span>&#125;; <span class="comment">//另一种赋值</span></span><br><span class="line"><span class="keyword">logic</span> regwrite;</span><br><span class="line"><span class="keyword">assign</span> regwrite = control<span class="variable">.regwrite</span>; <span class="comment">//使用</span></span><br></pre></td></tr></table></figure>
<p>从上面例子我们需要注意，<strong>System Verilog 使用 <code>'&#123;&#125;</code> 符号包含数值列表，与{}拼接符作出区分</strong>。</p>
<p>第一种赋值方法需要我们按照结构体中元素定义顺序进行赋值，第二种则随意。</p>
<p>如果不用 <code>typedef</code> 进行包装 <code>struct</code>，<strong>在 <code>System Verilog</code> 中则认为生成了一个这样的结构体变量，而不是定义</strong>。</p>
<h4 id="parameter">parameter</h4>
<p><strong>使用parameter用于适应不同的参数</strong>。</p>
<p><strong>参数 <code>parameter</code> 的引进，可以让模块的设计变得更加灵活，复用性更高。</strong></p>
<p>比如适用同一算法 <code>int</code>和<code>long long</code> 的加法器，使用 Verilog 需要写两个，但引用参数后只需要写一个模块。</p>
<p>使用方法样例：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> ADD #(</span><br><span class="line">    <span class="keyword">parameter</span> <span class="keyword">int</span> N = <span class="number">32</span>,</span><br><span class="line">)(</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span>[N-<span class="number">1</span>:<span class="number">0</span>] a,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span>[N-<span class="number">1</span>:<span class="number">0</span>] b,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">logic</span>[N-<span class="number">1</span>:<span class="number">0</span>] c</span><br><span class="line">);</span><br><span class="line">    <span class="keyword">assign</span> c = a + b;</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">logic</span>[<span class="number">31</span>:<span class="number">0</span>] int_type;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">logic</span>[<span class="number">63</span>:<span class="number">0</span>] long_type;</span><br><span class="line"></span><br><span class="line">int_type int_a, int_b, int_c;</span><br><span class="line">long_type [<span class="number">63</span>:<span class="number">0</span>] long_a, long_b, long_c;</span><br><span class="line"></span><br><span class="line"><span class="comment">// int 类型的加法器</span></span><br><span class="line">ADD <span class="variable">#(.N(32)) int_add(.a(int_a), .b(int_b), .c(int_c))</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// long 类型的加法器</span></span><br><span class="line">ADD <span class="variable">#(.N(64)) long_add(.a(long_a), .b(long_b), .c(long_c))</span>;</span><br></pre></td></tr></table></figure>
<p>值得注意的是设置好参数后，如果在模块实例化时不设置参数，那么参数会使用默认值。</p>
<p>如上述理解，如果直接实例化不设置参数，那么 <code>N</code> 就会为 32（默认值）。</p>
<h1>Mips</h1>
<p>由于硬件方面的原因，CPU 所直接处理的都是一条条二进制<strong>机器码</strong>指令。而这些单纯的机器码是很难以阅读和理解的，汇编语言是一种<strong>助记符</strong>：用一些符号代表特定含义的机器码，用<strong>标签</strong>（Label）来替代地址。</p>
<p>MIPS 汇编的最大特点就是指令的<strong>结构比较单一</strong>，所有的指令都可以翻译成 <strong>32 位二进制的机器码</strong>，指令的组成也大都只有 <strong>R、I、J</strong> 这三类。</p>
<h2 id="寄存器简介">寄存器简介</h2>
<p>对寄存器的访问速度远大于对存储器的访问速度，因而将少量常用的指令、数据保存到寄存器中。</p>
<p>MIPS通常有32个寄存器，其地址就是其编号（5位）。</p>
<p>在本次实验中的 CPU 是 32 位 CPU，<strong>一次能处理的最大位数即为 32 位，绝大部分寄存器也均是 1 字大小的（即 4 字节，也就是 32 位）</strong>。</p>
<blockquote>
<p>在32位系统上，一个字为4字节，16位系统上为2字节</p>
</blockquote>
<p>MIPS 中的 32 个通用寄存器按照序号命名为<code>$0~$31</code>，也可以按照功能命名。</p>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202309201650282.png" alt="image-20230920165018191"></p>
<table>
<thead>
<tr>
<th style="text-align:left">registers（也就是其地址）</th>
<th style="text-align:left">Name（为了帮助记忆的名字）</th>
<th style="text-align:left">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>$0</code></td>
<td style="text-align:left"><code>$zero</code></td>
<td style="text-align:left">常量0</td>
</tr>
<tr>
<td style="text-align:left"><code>$1</code></td>
<td style="text-align:left"><code>$at</code></td>
<td style="text-align:left">汇编器临时变量</td>
</tr>
<tr>
<td style="text-align:left"><code>$2</code>-<code>$3</code></td>
<td style="text-align:left"><code>$v0</code>-<code>$v1</code></td>
<td style="text-align:left">函数返回值</td>
</tr>
<tr>
<td style="text-align:left"><code>$4</code>-<code>$7</code></td>
<td style="text-align:left"><code>$a0</code>-<code>$a3</code></td>
<td style="text-align:left">函数参数</td>
</tr>
<tr>
<td style="text-align:left"><code>$8</code>-<code>$15</code></td>
<td style="text-align:left"><code>$t0</code>-<code>$t7</code></td>
<td style="text-align:left">temp：临时变量，调用者保存</td>
</tr>
<tr>
<td style="text-align:left"><code>$16</code>-<code>$23</code></td>
<td style="text-align:left"><code>$s0</code>-<code>$s7</code></td>
<td style="text-align:left">save：需要保存的变量，被调用者保存</td>
</tr>
<tr>
<td style="text-align:left"><code>$24</code>-<code>$25</code></td>
<td style="text-align:left"><code>$t8</code>-<code>$t9</code></td>
<td style="text-align:left">temp：临时变量，调用者保存</td>
</tr>
<tr>
<td style="text-align:left"><code>$26</code>-<code>$27</code></td>
<td style="text-align:left"><code>$k0</code>-<code>$k1</code></td>
<td style="text-align:left">操作系统临时变量</td>
</tr>
<tr>
<td style="text-align:left"><code>$28</code></td>
<td style="text-align:left"><code>$gp</code></td>
<td style="text-align:left">全局指针</td>
</tr>
<tr>
<td style="text-align:left"><code>$29</code></td>
<td style="text-align:left"><code>$sp</code></td>
<td style="text-align:left">栈指针</td>
</tr>
<tr>
<td style="text-align:left"><code>$30</code></td>
<td style="text-align:left"><code>$fp</code></td>
<td style="text-align:left">帧指针</td>
</tr>
<tr>
<td style="text-align:left"><code>$31</code></td>
<td style="text-align:left"><code>$ra</code></td>
<td style="text-align:left">函数返回地址</td>
</tr>
</tbody>
</table>
<p><code>$0</code> 始终为0，因为0经常在计算机程序中使用，提供了一个不同于立即数的常数</p>
<h3 id="s寄存器和t寄存器的区别">s寄存器和t寄存器的区别</h3>
<ol>
<li>
<p>对于 s 寄存器而言，被调用者需要<strong>保证寄存器中的值在调用前后不能发生改变</strong></p>
<p>对应到实际操作中，如果你想要编写一个子函数，那么在这个子函数中使用的所有 s 寄存器，都必须要在函数的开头入栈，在函数的结尾出栈，以确保其值在这个函数被调用前后不会发生变化。</p>
</li>
<li>
<p>对于 t 寄存器而言则刚好相反，你编写的子函数中用到 t 寄存器的地方无需做任何保存，随意使用即可——因为维护 t 寄存器是上层函数的任务。</p>
</li>
<li>
<p>这也就是所谓的 ：s 寄存器由被调用者维护，t 寄存器由调用者维护。</p>
</li>
</ol>
<blockquote>
<p>一个调用者（即父函数）并不能预知其将要调用的子函数（即被调用者）会使用到哪些 t 寄存器，但可能在调用时并不想失去自己正在使用的某个 t 寄存器中的数据。</p>
<p>在这种情况下，为了维持 t 寄存器中的数据，调用者有两种选择：一是将所有 t 寄存器中的数据移至 s 寄存器，函数调用结束之后再移回来；二是将自己希望保留的 t 寄存器压入栈中，函数调用结束之后再弹回来。</p>
<p>第一种方法看似简单，但实际上引入了很多潜在的问题，比如：s 寄存器用完了怎么办？怎么确保子函数一定不会破坏 s 寄存器中的数据？在自动生成汇编代码（如编译）的过程中，怎样确定哪些 s 寄存器是可以用来保存 t 寄存器中的数据的？</p>
<p>因此，采用第二种方法，是一个更优雅，也更规范的做法。在第二种方法里，不再需要去考虑寄存器之间如何倒腾，只需要借助 sp 指针，不停地用栈去存取自己需要的数据就可以了。这减少了程序员的心智负担，规范了函数调用的过程，也方便了编译器的实现。</p>
<p>总而言之，调用者维护 t 寄存器，被调用者维护 s 寄存器的意义，就在于让代码更易于模块化。在这种约定下，调用者不需要去考虑被调用者的具体细节，被调用者也不需要去考虑自己被调用的方式。这使得 mips 代码可以以函数为单位进行模块化开发。</p>
</blockquote>
<h2 id="汇编指令">汇编指令</h2>
<p>指令，即是由处理器指令集架构定义的处理器的独立操作。这个操作一般是运算、存储、读取等。一个指令在 CPU 中真正的存在形式是高低电平，也可以理解为由01序列组成的机器码。</p>
<p>因为机器码人类难以阅读和理解，所以指令一般由汇编语言来表示。汇编指令只是一种助记符。一条指令的功能较为单一，一般不具有复杂的逻辑。</p>
<p>在 MIPS 汇编语言中，指令一般由一个指令名作为开头，后跟该指令的操作数，中间由空格或逗号隔开。指令的操作数的个数一般为 0-3 个，每一个指令都有其固定操作数个数。</p>
<p>一般来说，指令的格式如下：</p>
<p><code>指令名 操作数 1, 操作数 2, 操作数 3</code></p>
<p>不过，也有如下的指令格式，一般用于存取类指令：</p>
<p><code>指令名 操作数 1, 操作数 3(,操作数 2)</code></p>
<p>所谓操作数，即<strong>指令操作所作用的实体</strong>，可以是<strong>寄存器、立即数或标签</strong>，每个指令都有其固定的对操作数形式的要求。</p>
<blockquote>
<p>标签用于使程序更简单清晰。标签用于表示一个地址，以供指令来引用。最终会由汇编器转换为立即数。</p>
<p>立即数，即在<strong>指令中设定好的常数</strong>，可以直接参与运算，一般长度为 16 位二进制。</p>
<p>标签一般用于表示一个<strong>数据存取的地址</strong>（类似于数组名）、或者一个<strong>程序跳转的地址</strong>（类似于函数名，或者 C 语言中 <code>goto</code> 的跳转目标）。</p>
</blockquote>
<p>每条指令的执行周期大多为 1 个 CPU 周期。因此机器码就是 CPU 最基本的一种操作，也是原子操作，不可被打断。</p>
<h3 id="指令格式">指令格式</h3>
<p>32 位的机器码需要一定的格式才能被理解。一般来说，在 MIPS 指令集中，指令分为三种格式：R 型、I 型和 J 型。</p>
<p>区分 R 型指令，I 型指令与 J 型指令需要通过指令的机器码编码方式来确定。 R 型指令一般会有 rs, rt, rd 三种寄存器的编码； I 型指令会有 16 位的立即数； J 型指令会有 26 位的地址数。</p>
<h4 id="R-型指令">R 型指令</h4>
<p>R 型指令的操作数最多，一般用于运算指令。例如 <code>add</code>、<code>sub</code>、<code>sll</code> 等。其格式如下（左侧为高位，右侧为低位）：</p>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202309142006592.png" alt="image-20230914200649478"></p>
<h4 id="I-型指令">I 型指令</h4>
<p>I 型指令的特点是有 <strong>16 位的立即数</strong>（偏移也是一样的道理）。因此，I 型指令一般用于 <code>addi</code>、<code>subi</code>、<code>ori</code> 等与立即数相运算的指令（这里需要注意：在写汇编语言的时候，<strong>需要使用负号来标记负数</strong>，而不要和机器码一样认为首位的 1 就代表负数），或 <code>beq</code>、<code>bgtz</code> 等比较跳转指令，因为它们要让两个寄存器的值相比并让 PC 偏移 offset 这么多，刚好利用了全部的字段。还有存取指令，例如 <code>sw</code>、<code>lw</code>，它们在使用时需要对地址指定一个偏移值，也会用到立即数字段。</p>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202309142007237.png" alt="image-20230914200749149"></p>
<h4 id="J-型指令">J 型指令</h4>
<p>J 型指令很少，常见的为 <code>j</code> 和 <code>jal</code>。他们需要直接跳转至某个地址，而非利用当前的 PC 值加上偏移量计算出新的地址，因此需要的位数较多。</p>
<blockquote>
<p>j 指令的地址空间共26位，可以表示64M（1024*1024）条指令，但是由于指令左移两位（相当于乘4），使得实际能达到的地址位256M</p>
<p>也可以看出，j指令能跳转达到的地址一定是4的倍数，是特定的语句的地址</p>
</blockquote>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202309142007845.png" alt="image-20230914200759740"></p>
<p><code>jal</code>跳转后，寄存器<code>ra</code>存储<code>jal</code>下一条指令的地址，方便跳回</p>
<p><code>jr register</code>跳转到寄存器保存的地址</p>
<h3 id="注意">注意</h3>
<h4 id="地址相关">地址相关</h4>
<ul>
<li><code>rs,rt,rd</code>：在汇编程序和实际的机器指令中的相对位置</li>
<li>GPR ：即 General Purpose Register （通用寄存器），其后的中括号内为寄存器编号。<code>GPR[rs]</code> 即可表示编号为 <code>rs</code> 的寄存器。</li>
<li>memory：表示内存，当其后跟随中括号时，表示存储在<strong>以括号中数值为起始地址</strong>的 <strong>4 字节</strong>内存中的数据。
<ul>
<li>以 <code>memory[Addr]</code> 为例，其表示以 <code>Addr</code>为首地址的 4 字节内存中存储的数据。</li>
</ul>
</li>
</ul>
<h4 id="读出和写入">读出和写入</h4>
<p><code>sw,sb</code>：从寄存器中读出写入存储器</p>
<p><code>lw,lb</code>：从存储器读出写入寄存器</p>
<p><code>w</code>:一个字，4个字节（一条指令为32位），地址偏移量必须为4的倍数</p>
<p><code>b</code>:<code>byte</code>，地址偏移量可以任意</p>
<blockquote>
<p>bit：1个0/1是1位，1字节byte=8bit</p>
<p>1字=4字节（32位机器），字是CPU一次处理指令的长度</p>
</blockquote>
<h3 id="伪指令（DIRECTIVES）">伪指令（DIRECTIVES）</h3>
<p>伪指令是用来指导汇编器如何处理程序的语句，有点类似于其他语言中的预处理命令。</p>
<p>在使用伪指令初始化数据时，伪指令存储的数据在内存中从<code>.data</code>声明的首地址开始，按照伪指令声明顺序紧密有序存储</p>
<p>伪指令不是指令，它并不会被编译为机器码，但他却能影响其他指令的汇编结果。</p>
<p>常用的伪指令有以下几个：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.data	#在此处声明了全局变量</span><br><span class="line">fibs: .space   48           # &quot;array&quot; of 12 words to contain fib values</span><br><span class="line">size: .word  12             # size of &quot;array&quot;</span><br><span class="line">space:.asciiz  &quot; &quot;          # space to insert between numbers</span><br><span class="line">head: .asciiz  &quot;The Fibonacci numbers are:\n&quot;</span><br></pre></td></tr></table></figure>
<ol>
<li>
<p><code>.data</code>：用于预先存储数据的<strong>伪指令的开始标志</strong>。</p>
<p>格式：.data [address]</p>
<p>说明：</p>
<ul>
<li>定义程序的数据段，初始地址为 address，若无 address 参数，初始地址为设置的默认地址。</li>
<li>需要用伪指令声明的程序变量需要紧跟着该指令。</li>
</ul>
</li>
<li>
<p><code>.text</code>：程序代码指令开始的标志。</p>
<p>格式：.text [address]</p>
<p>说明：</p>
<ul>
<li>定义程序的代码段，初始地址为 address，若无 address 参数，初始地址为设置的默认地址。</li>
<li>该指令后面就是程序代码。</li>
<li>在 MARS 中如果前面没有使用 <code>.data</code> 伪指令，可以不使用 <code>.text</code> 直接编写程序代码，代码将放置在前面设置的代码段默认地址中；但如果前面使用了 <code>.data</code> 伪指令，务必在代码段开始前使用 <code>.text</code> 进行标注。</li>
</ul>
</li>
<li>
<p><code>.space</code>：申请<strong>若干个字节的未初始化的内存空间</strong>。</p>
<p>格式：[name]: .space [n]</p>
<p>说明：</p>
<ul>
<li>申请 n 个字节未初始化的内存空间，类似于其他语言中的数组声明。</li>
<li>这段数据的初始地址保存在标签 <code>name</code> 中。</li>
<li>name 的地址是由 <code>.data</code> 段的初始地址加上前面所申请的数据大小计算得出的。由于<strong>前面申请的空间大小不定，有可能会出现后来申请的空间没有字对齐的情况</strong>，从而在使用 <code>sw</code>,<code>lw</code> 一类指令时出现错误，所以在申请空间时尽可能让 n 为 4 的倍数，防止在数据存取过程中出现问题。</li>
<li>在本例中，事先申请了 48 个字节也就是 12 个字的内存空间，用来保存我们之后计算出来的 12 个 Fibonacci 数，地址标签为 fibs。</li>
</ul>
</li>
<li>
<p><code>.word</code>：以<strong>字为单位</strong>存储数据。</p>
<p>格式：[name]: .word [data1],[data2] ….</p>
<p>说明：</p>
<ul>
<li>在内存数据段中以字为单位连续存储数据 data1, data2,… (也就是将 datax 写入对应的 1 个字的空间，注意 .word 和 .space 的区别)</li>
<li>这段数据的初始地址保存在标签 name 中。计算方式与上面相同。</li>
</ul>
</li>
<li>
<p><code>.asciiz</code>：以<strong>字节为单位</strong>存储字符串。</p>
<p>格式：[name]: . asciiz “[content]”</p>
<p>说明：</p>
<ul>
<li>以字节为单位存储字符串，末尾以 NULL 结尾。</li>
<li>每个字符（ascii）占8位</li>
<li>这个字符串在内存数据区的初始地址保存在标签 name 中。</li>
<li>注意 <code>.asciiz</code> 与 <code>.ascii</code> 这两条伪指令的区别。
<ul>
<li><code>.ascii</code> 伪指令不会在字符串之后添加0x00, <code>.asciiz</code>会添加0x00</li>
<li><code>.asciiz</code> 由于是<strong>按字节存储</strong>，可能会导致之后分配的空间首地址无法字对齐的情况发生，请大家自行思考解决方法。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="宏">宏</h3>
<p>宏分为两种，不带参数的宏和带参数的宏。</p>
<h4 id="不带参数">不带参数</h4>
<p>不带参数的宏，定义的方式如下：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">.macro</span> macro_name</span><br><span class="line"><span class="comment"># 代码段</span></span><br><span class="line">.end_macro</span><br></pre></td></tr></table></figure>
<p>可以定义这样一个宏：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">.macro</span> done</span><br><span class="line">li  $<span class="built_in">v0</span>, <span class="number">10</span></span><br><span class="line"><span class="keyword">syscall</span></span><br><span class="line"><span class="keyword"></span>.end_macro</span><br></pre></td></tr></table></figure>
<p>此时，在需要程序停止运行的地方，使用 done 语句，就可以让程序在那里退出。这样就实现了代码复用。</p>
<h4 id="带参数">带参数</h4>
<p>带参数的宏，定义的方式如下：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.macro macro_name(%parameter1, %parameter2, ...)</span><br><span class="line"><span class="comment"># 代码段</span></span><br><span class="line">.end_macro</span><br></pre></td></tr></table></figure>
<p>和不带参数的宏不同的是，带参数的宏在 macro_name 后面有若干个用括号括起来的<strong>形式参数</strong>，每两个形式参数中间用逗号隔开，参数名前面有一个百分号。</p>
<p>可以定义这样一个宏：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.macro  getindex(%ans, %i, %j)</span><br><span class="line">    sll %ans, %i, <span class="number">3</span></span><br><span class="line">    add %ans, %ans, %j</span><br><span class="line">    sll %ans, %ans, <span class="number">2</span></span><br><span class="line">.end_macro</span><br></pre></td></tr></table></figure>
<p>其中<code>%i</code>代表行数，<code>%j</code> 代表列数，<code>%ans</code> 就是计算出来的结果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">%</mi><mi>i</mi><mo>∗</mo><mn>8</mn><mo>+</mo><mi mathvariant="normal">%</mi><mi>j</mi><mo stretchy="false">)</mo><mo>∗</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">(\%i*8+\%j)*4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">%</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">%</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span></span></span></span>。使用 <code>getindex($t2, $t0, $t1)</code> 来调用这个宏，汇编器会用这段代码替换它，同时 <code>%ans</code> 被替换成 <code>$t2</code>，<code>%i </code>被替换成 <code>$t0</code>，%j 被替换成 <code>$t1</code>，因此最终会被替换成</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sll </span>$<span class="built_in">t2</span>, $<span class="built_in">t0</span>, <span class="number">3</span></span><br><span class="line"><span class="keyword">add </span>$<span class="built_in">t2</span>, $<span class="built_in">t2</span>, $<span class="built_in">t1</span></span><br><span class="line"><span class="keyword">sll </span>$<span class="built_in">t2</span>, $<span class="built_in">t2</span>, <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>在矩阵乘法中，只需要替换调用宏的语句，问题就会被轻松解决，同时代码的复用性得到了提高，代码也更容易被人读懂。</p>
<h4 id="常量定义">常量定义</h4>
<p>在汇编程序中，还有一种和C语言中 <code>#define</code> 类似的宏定义，一般用于常量的定义上，那就是 <code>.eqv</code>。用法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.eqv EQV_NAME string</span><br></pre></td></tr></table></figure>
<p>汇编器会把所有 EQV_NAME 的地方替换成 string，这可以用来定义一些常量。</p>
<p>可以用 <code>.eqv</code> 对数字编码进行定义，例如：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.eqv    TUBECHAR_0  <span class="number">0x7E</span></span><br><span class="line">.eqv    TUBECHAR_1  <span class="number">0x30</span></span><br><span class="line">.eqv    TUBECHAR_2  <span class="number">0x6D</span></span><br></pre></td></tr></table></figure>
<p>使得代码更加清晰，并且避免了代码中出现各种意义不明的数字。</p>
<h3 id="扩展指令">扩展指令</h3>
<p>扩展指令的功能主要是简化程序。汇编器将一些常用功能<strong>封装为一条指令</strong>，或者<strong>改变现有指令的操作数的形式或个数</strong>，使其以新的形式出现。扩展指令是汇编器的功能，实际还是一条条的机器指令。</p>
<h4 id="li"><code>li</code></h4>
<p>最常用到的一条扩展指令是li指令，它用来<strong>为某个寄存器赋值</strong>，比如 <code>li $a0,100</code> 就是将 100 赋给 <code>$a0</code> 寄存器。汇编器在翻译这条扩展指令时会根据需要，将它翻译成不同的基本指令或基本指令的组合。</p>
<ul>
<li>第一条 <code>li</code> 指令后面的立即数不多于 16 位，因此只被翻译成了一条 <code>addiu</code>；
<ul>
<li><code>$a0</code>的地址是<code>$4</code></li>
</ul>
</li>
<li>第二条 <code>li</code> 指令后面的立即数多于 16 位，因此被翻译成了<code>lui+ori</code>的组合。</li>
</ul>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202309172304569.png" alt=""></p>
<h4 id="la"><code>la</code></h4>
<p>另一条常用的扩展指令是 <code>la</code> 指令，是获取标签指向的地址，也就是<strong>使用地址来为寄存器赋值</strong>。标签本质上对应**一个 32 位地址。</p>
<ul>
<li>比如 <code>la $t0, fibs</code> 这条指令就是把 fibs 指向的地址存入<code>$t0</code> 中。</li>
</ul>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202309172308030.png" alt=""></p>
<h3 id="系统调用">系统调用</h3>
<p>读取字符串的方式是以 $a0 存储器中存储的地址作为字符串的起始地址, 一直读取到 NULL, 也就是 0 为止.</p>
<p>考虑到字符结尾的 \0, 能够读取字符的最大数量应该是 $a1 寄存器所存储的值 - 1</p>
<ol>
<li>
<p>字符串输出 代码：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">la $<span class="built_in">a0</span>, <span class="keyword">addr</span></span><br><span class="line"><span class="keyword"></span>li $<span class="built_in">v0</span>, <span class="number">4</span></span><br><span class="line"><span class="keyword">syscall</span></span><br></pre></td></tr></table></figure>
<p>说明：</p>
<ul>
<li>首先把要输出的字符串在内存中的<strong>首地址</strong>赋给 <strong><code>$a0</code></strong> 寄存器，然后汇编器就会根据 <code>$a0</code> 中的地址将字符串输出。</li>
<li>在内存中存储的字符串是以 <strong>NULL(‘\0’)</strong> 作为结束符，输出时遇到这个结束符就会停止。</li>
</ul>
</li>
<li>
<p>整数输出</p>
<p>代码：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">li $v0, <span class="number">1</span></span><br><span class="line"><span class="keyword">syscall</span></span><br></pre></td></tr></table></figure>
<p>说明：这个系统调用的功能就是把 <strong><code>$a0</code></strong> 寄存器中的数据以<strong>整数</strong>的形式输出。</p>
</li>
<li>
<p>结束程序</p>
<p>格式：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">li $v0, <span class="number">10</span></span><br><span class="line"><span class="keyword">syscall</span></span><br></pre></td></tr></table></figure>
<p>说明：结束程序</p>
</li>
</ol>
<h2 id="Mars">Mars</h2>
<p>每个标签下的那块代码段一般都负责一部分功能，在设置断点调试程序时也大都是按照功能模块进行分块调试。</p>
<p>下面是一个求前12个Fibonacci数的一个程序：</p>
<blockquote>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202309172344770.png" alt="Mars_4.1.1_code_.png"> <img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202309172344763.png" alt="Mars_4.1.2_code_.png"> <img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202309172344775.png" alt="Mars_4.1.3_code_.png"></p>
<p>假如我们对它进行初步调试，应该在哪几行设置断点比较合理呢？</p>
<p>答案：15，27，32</p>
<p>解析：这段代码的 .text 部分有 3 个标签：<code>loop</code>，<code>print</code>，<code>out</code>。<code>loop</code> 标签对应的代码段功能为计算前 12 个 Fibonacci 数，<code>print</code> 标签对应的代码段功能为打印提示语句 “The Fibonacci numbers are:”，<code>out</code> 标签对应的代码段功能为循环打印 Fibonacci 数列的每个数值。</p>
<p>在 <code>loop</code> 标签处（第15行）设置断点：</p>
<ul>
<li>可以观察每次循环迭代时计算得到的 Fibonacci 数值，以及数组的变化情况。这有助于确保计算正确和查找潜在的计算错误。</li>
</ul>
<p>在 <code>print</code> 标签处（第27行）设置断点：</p>
<ul>
<li>可以查看计算完成后的最终结果，即前 12 个 Fibonacci 数列的值是否正确。这有助于确保计算和输出的正确性。</li>
</ul>
<p>在 <code>out</code> 标签处（第32行）设置断点：</p>
<ul>
<li>可以观察循环打印 Fibonacci 数列的执行情况，逐个输出 Fibonacci 数值，并观察输出是否正确。这有助于验证输出循环的正确性和定位可能出现的问题。</li>
</ul>
</blockquote>
<h2 id="汇编程序">汇编程序</h2>
<h3 id="循环">循环</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line">li  $v0,5</span><br><span class="line">syscall                 # 输入一个整数，输入的数存到 $v0 中</span><br><span class="line">move $s0, $v0           # 赋值，$s0 = $v0</span><br><span class="line">li  $s1, 0              # $s1 用于存储累加的值，$s1 = 0</span><br><span class="line">li  $t0, 1              # $t0 是循环变量</span><br><span class="line"></span><br><span class="line">loop:</span><br><span class="line">bgt $t0, $s0, loop_end  # 这里用了一个扩展指令 bgt,当 $t0 &gt; $s0 的时候跳转到 loop_end</span><br><span class="line">add $s1, $s1, $t0       # $s1 = $s1 + $t0</span><br><span class="line">addi $t0, $t0, 1        # $t0 = $t0 + 1</span><br><span class="line">j   loop                # 无条件跳转到 loop 标签</span><br><span class="line"></span><br><span class="line">loop_end:</span><br><span class="line">move $a0, $s1           # 赋值，$a0 = $s1</span><br><span class="line">li  $v0, 1              # $v0 = 1，在 syscall 中会输出 $a0 的值</span><br><span class="line">syscall         </span><br><span class="line">li  $v0,10              # $v0 = 10</span><br><span class="line">syscall                 # 结束程序          </span><br></pre></td></tr></table></figure>
<p>在这段程序中，用到了大量的扩展指令</p>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202309201520445.png" alt=""></p>
<h3 id="数组">数组</h3>
<p>数组的本质是存储器中连续的空间，相邻差4</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">array: .space 40           # 存储这些数需要用到数组，数组需要使用 10 * 4 = 40 字节</span><br><span class="line">                           # 一个 int 整数需要占用 4 个字节，需要存储 10 个 int 整数</span><br><span class="line">                           # 因此，array[0] 的地址为 0x00，array[1] 的地址为 0x04</span><br><span class="line">                           # array[2] 的地址为 0x08，以此类推。</span><br><span class="line"></span><br><span class="line">str:   .asciiz &quot;The numbers are:\n&quot;</span><br><span class="line">space: .asciiz &quot; &quot;</span><br><span class="line"></span><br><span class="line">.text</span><br><span class="line">li $v0,5</span><br><span class="line">syscall                    # 输入一个整数</span><br><span class="line">move $s0, $v0              # $s0 is n</span><br><span class="line">li $t0, 0                  # $t0 循环变量</span><br><span class="line"></span><br><span class="line">loop_in:</span><br><span class="line">beq $t0, $s0, loop_in_end  # $t0 == $s0 的时候跳出循环</span><br><span class="line">li $v0, 5</span><br><span class="line">syscall                    # 输入一个整数</span><br><span class="line">sll $t1, $t0, 2            # $t1 = $t0 &lt;&lt; 2，即 $t1 = $t0 * 4</span><br><span class="line">sw $v0, array($t1)         # 把输入的数存入地址为 array + $t1 的内存中</span><br><span class="line">addi $t0, $t0, 1           # $t0 = $t0 + 1</span><br><span class="line">j loop_in                  # 跳转到 loop_in</span><br><span class="line"></span><br><span class="line">loop_in_end:</span><br><span class="line">la $a0, str</span><br><span class="line">li $v0, 4</span><br><span class="line">syscall                    # 输出提示信息</span><br><span class="line">li $t0, 0</span><br><span class="line"></span><br><span class="line">loop_out:</span><br><span class="line">beq $t0, $s0, loop_out_end</span><br><span class="line">sll $t1, $t0, 2            # $t1 = $t0 &lt;&lt; 2，即 $t1 = $t0 * 4</span><br><span class="line">lw $a0, array($t1)         # 把内存中地址为 array + $t1 的数取出到 $a0 中</span><br><span class="line">li $v0, 1</span><br><span class="line">syscall                    # 输出 $a0</span><br><span class="line">la $a0, space</span><br><span class="line">li $v0, 4</span><br><span class="line">syscall                    # 输出一个空格</span><br><span class="line">addi $t0, $t0, 1</span><br><span class="line">j loop_out</span><br><span class="line"></span><br><span class="line">loop_out_end:</span><br><span class="line">li $v0, 10</span><br><span class="line">syscall                    # 结束程序</span><br></pre></td></tr></table></figure>
<p>这里使用了 <code>lw</code> 和 <code>sw</code> 指令，对内存进行读写操作。<code>lw</code> 和 <code>sw</code> 要求地址对齐到字（即<strong>地址必须为 4 的倍数</strong>），否则会产生异常。由于字符串的长度不确定，并且<strong>打印字符串（<code>$v0</code> 为 4）的 <code>syscall</code></strong> 对 <code>$a0</code> 的值没有对齐要求，因此在一般情况下，会把字符串的声明放在最后。同学们可以尝试把 str 的声明挪到 array 声明的前面，如果运行程序时产生了异常，则可以尝试让 str 字符串增加或减少一些字符，直到内存指令不再出现异常。</p>
<h3 id="二维数组">二维数组</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">matrix: .space  256             # int matrix[8][8]   8*8*4 字节</span><br><span class="line">                                # matrix[0][0] 的地址为 0x00，matrix[0][1] 的地址为 0x04，……</span><br><span class="line">                                # matrix[1][0] 的地址为 0x20，matrix[1][1] 的地址为 0x24，……</span><br><span class="line">                                # ……</span><br><span class="line">str_enter:  .asciiz &quot;\n&quot;</span><br><span class="line">str_space:  .asciiz &quot; &quot;</span><br><span class="line"></span><br><span class="line"># 这里使用了宏，%i 为存储当前行数的寄存器，%j 为存储当前列数的寄存器</span><br><span class="line"># 把 (%i * 8 + %j) * 4 存入 %ans 寄存器中</span><br><span class="line">.macro  getindex(%ans, %i, %j)</span><br><span class="line">    sll %ans, %i, 3             # %ans = %i * 8</span><br><span class="line">    add %ans, %ans, %j          # %ans = %ans + %j</span><br><span class="line">    sll %ans, %ans, 2           # %ans = %ans * 4</span><br><span class="line">.end_macro</span><br><span class="line"></span><br><span class="line">.text</span><br><span class="line">li  $v0, 5</span><br><span class="line">syscall</span><br><span class="line">move $s0, $v0                   # 行数</span><br><span class="line"></span><br><span class="line">li  $v0, 5</span><br><span class="line">syscall</span><br><span class="line">move $s1, $v0                   # 列数</span><br><span class="line"></span><br><span class="line"># 这里使用了循环嵌套</span><br><span class="line">li  $t0, 0                      # $t0 是一个循环变量</span><br><span class="line"></span><br><span class="line">in_i:                           # 这是外层循环</span><br><span class="line">beq $t0, $s0, in_i_end</span><br><span class="line">li  $t1, 0                      # $t1 是另一个循环变量</span><br><span class="line"></span><br><span class="line">in_j:                           # 这是内层循环</span><br><span class="line">beq $t1, $s1, in_j_end</span><br><span class="line">li  $v0, 5</span><br><span class="line">syscall</span><br><span class="line"></span><br><span class="line">getindex($t2, $t0, $t1)         # 这里使用了宏，就不用写那么多行来算 ($t0 * 8 + $t1) * 4 了</span><br><span class="line">sw  $v0, matrix($t2)            # matrix[$t0][$t1] = $v0</span><br><span class="line">addi $t1, $t1, 1</span><br><span class="line">j   in_j</span><br><span class="line"></span><br><span class="line">in_j_end:</span><br><span class="line">addi $t0, $t0, 1</span><br><span class="line">j   in_i</span><br><span class="line"></span><br><span class="line">in_i_end:</span><br><span class="line"># 这里使用了循环嵌套，和输入的时候同理</span><br><span class="line">li  $t0, 0</span><br><span class="line"></span><br><span class="line">out_i:</span><br><span class="line">beq $t0, $s0, out_i_end</span><br><span class="line">li  $t1, 0</span><br><span class="line"></span><br><span class="line">out_j:</span><br><span class="line">beq $t1, $s1, out_j_end</span><br><span class="line">getindex($t2, $t0, $t1)</span><br><span class="line">lw  $a0, matrix($t2)            # $a0 = matrix[$t0][$t1]</span><br><span class="line">li  $v0, 1</span><br><span class="line">syscall</span><br><span class="line">la  $a0, str_space</span><br><span class="line">li  $v0, 4</span><br><span class="line">syscall                         # 输出一个空格</span><br><span class="line">addi $t1, $t1, 1</span><br><span class="line">j   out_j</span><br><span class="line"></span><br><span class="line">out_j_end:</span><br><span class="line">la  $a0, str_enter</span><br><span class="line">li  $v0, 4</span><br><span class="line">syscall                         # 输出一个回车</span><br><span class="line">addi $t0, $t0, 1</span><br><span class="line">j   out_i</span><br><span class="line"></span><br><span class="line">out_i_end:</span><br><span class="line">li  $v0, 10</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure>
<h2 id="栈">栈</h2>
<p>通常情况下，存储器仅给数据段<code>.data</code>和代码段<code>.text</code>分配了内存空间，没有给栈分配空间，所以会在数据段自己开辟一定的空间，存储一下局部、临时变量</p>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202309201657061.png" alt="image-20230920165756904"></p>
<h3 id="使用规范">使用规范</h3>
<ul>
<li>过程自身满足栈的结构：先进后出</li>
<li>过程调用子过程时需要满足栈的结构</li>
<li>子过程执行前后需要移动栈指针<code>$sp</code>：分配和释放栈</li>
<li><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202309201754441.png" alt="image-20230920175423232"></li>
</ul>
<h3 id="使用方法">使用方法</h3>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202309201755731.png" alt="image-20230920175504579"></p>
<p>维护一个栈的过程就是维护<code>$sp</code>指针的过程，默认一个数据存储16位的空间，即<code>$sp=$sp-4</code>，在这4个空间内存储数据。</p>
<h2 id="函数调用">函数调用</h2>
<ul>
<li>函数是一个<strong>代码块</strong>，可以由指定语句调用，并且在执行完毕后返回调用语句。</li>
<li>函数通过传参，可以实现代码的<strong>复用</strong>。</li>
<li>函数只能通过返回值等有限手段对函数外造成影响。</li>
<li>函数里依然可以<strong>嵌套调用</strong>函数。</li>
</ul>
<h3 id="复用代码">复用代码</h3>
<p>复用代码实现了程序的结构化：传入参数，有返回值</p>
<p>为了复用代码，就必须让一些特定寄存器作为“接收器”，对于不同的参数，都采用<strong>同一组寄存器</strong>来存储他们的值，也就是我们说的形参寄存器 <code>$a0, $a1, $a2, $a3</code>。同样的道理，对于返回值，也是需要指定特定的寄存器。</p>
<p><code>$a0, $a1, $a2, $a3</code> 是一种程序员的约定，也可以用其他的寄存器或者存储入内存中。当需要传递的参数超过 4 个的时候，一般将多出的参数存入内存。在 MIPS 中，我们使用内存的一个主要方法就是利用栈，我们可以通过控制栈指针寄存器 <code>$sp</code>，完成对内存的访问。</p>
<h3 id="不对外界造成影响">不对外界造成影响</h3>
<p>所以我们需要保证函数不会对外部造成影响，方法就是应用栈。</p>
<p>栈在这里的作用是保存和恢复函数使用的寄存器，函数应该计算返回值，但不应该产生其他的负面影响。</p>
<p>那么其实有两种使用栈的位置，第一种是在调用函数前，这种被称为<strong>调用者保存</strong>（在这里就是在 <code>main</code> 里面出入栈）。另一种是<strong>被调用者保存</strong>（在 <code>sum</code> 里出入栈）</p>
<p>实际使用更多的是在函数中管理栈：更好地函数化</p>
<h3 id="嵌套函数调用">嵌套函数调用</h3>
<p>嵌套函数调用最重要的就是<strong>用栈保存跳转地址</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">.macro end</span><br><span class="line">    li $v0, 10</span><br><span class="line">    syscall</span><br><span class="line">.end_macro</span><br><span class="line"></span><br><span class="line">.text</span><br><span class="line">li      $s0, 2</span><br><span class="line">li      $s1, 3</span><br><span class="line"></span><br><span class="line">move    $a0, $s0</span><br><span class="line">move    $a1, $s1</span><br><span class="line">jal     cal</span><br><span class="line">move    $s5, $v0</span><br><span class="line"></span><br><span class="line">li      $v0, 1</span><br><span class="line">move    $a0, $s5</span><br><span class="line">syscall</span><br><span class="line"></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">sum:</span><br><span class="line">#将 $t0 和 $t1 入栈</span><br><span class="line">sw      $t0, 0($sp)</span><br><span class="line">addi    $sp, $sp, -4</span><br><span class="line">sw      $t1, 0($sp)</span><br><span class="line">addi    $sp, $sp, -4</span><br><span class="line"></span><br><span class="line">#传参过程</span><br><span class="line">move    $t0, $a0</span><br><span class="line">move    $t1, $a1</span><br><span class="line">#函数过程</span><br><span class="line">add     $v0 $t0, $t1</span><br><span class="line">#将 $t0 和 $t1 出栈</span><br><span class="line">addi    $sp, $sp, 4</span><br><span class="line">lw      $t1, 0($sp) </span><br><span class="line">addi    $sp, $sp, 4</span><br><span class="line">lw      $t0, 0($sp) </span><br><span class="line">#return</span><br><span class="line">jr      $ra</span><br><span class="line"></span><br><span class="line">cal:</span><br><span class="line">#将 $ra 入栈</span><br><span class="line">sw      $ra, 0($sp)</span><br><span class="line">addi    $sp, $sp, -4</span><br><span class="line"></span><br><span class="line">#传参过程</span><br><span class="line">move    $t0, $a0</span><br><span class="line">move    $t1, $a1</span><br><span class="line"></span><br><span class="line">#调用 sum 的过程</span><br><span class="line">move    $a0, $t1</span><br><span class="line">move    $a1, $t0</span><br><span class="line">jal     sum</span><br><span class="line">move    $t2, $v0</span><br><span class="line">#运算a-sum(b, a)</span><br><span class="line">sub     $v0, $t0, $t2</span><br><span class="line">#将ra出栈</span><br><span class="line">addi    $sp, $sp, 4</span><br><span class="line">lw      $ra, 0($sp) </span><br><span class="line">#return</span><br><span class="line">jr      $ra</span><br></pre></td></tr></table></figure>
<h3 id="递归函数调用">递归函数调用</h3>
<p>递归函数的本质就是<strong>一个在函数体内调用自身的嵌套函数</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">factorial</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span>  <span class="keyword">return</span> n * factorial(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, factorial(<span class="number">5</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>汇编翻译版本为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"># 程序结束</span><br><span class="line">.macro end</span><br><span class="line">    li      $v0, 10</span><br><span class="line">    syscall</span><br><span class="line">.end_macro</span><br><span class="line"></span><br><span class="line"># 从标准输入处得到一个整型变量，并存储到 %des 寄存器中</span><br><span class="line">.macro getInt(%des)</span><br><span class="line">    li      $v0, 5</span><br><span class="line">    syscall</span><br><span class="line">    move    %des, $v0</span><br><span class="line">.end_macro</span><br><span class="line"></span><br><span class="line"># 向标准输出中写入一个数据，这个数据保存在 %src 寄存器中</span><br><span class="line">.macro printInt(%src)</span><br><span class="line">    move    $a0, %src</span><br><span class="line">    li      $v0, 1</span><br><span class="line">    syscall</span><br><span class="line">.end_macro</span><br><span class="line"></span><br><span class="line"># 将寄存器 %src 中的数据入栈</span><br><span class="line">.macro push(%src)</span><br><span class="line">    sw      %src, 0($sp)</span><br><span class="line">    addi    $sp, $sp, -4</span><br><span class="line">.end_macro</span><br><span class="line"></span><br><span class="line"># 将栈顶数据出栈，并保存在 %des 寄存器中</span><br><span class="line">.macro pop(%des)</span><br><span class="line">    addi    $sp, $sp, 4</span><br><span class="line">    lw      %des, 0($sp) </span><br><span class="line">.end_macro</span><br><span class="line"></span><br><span class="line">.text</span><br><span class="line">main:</span><br><span class="line">    getInt($s0)</span><br><span class="line"></span><br><span class="line">    move    $a0, $s0</span><br><span class="line">    jal     factorial</span><br><span class="line">    move    $s1, $v0</span><br><span class="line"></span><br><span class="line">    printInt($s1)</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">factorial:</span><br><span class="line">    # 入栈</span><br><span class="line">    push($ra)</span><br><span class="line">    push($t0)</span><br><span class="line">    # 传参</span><br><span class="line">    move    $t0, $a0</span><br><span class="line">    #函数过程</span><br><span class="line">    bne     $t0, 1, else</span><br><span class="line">    </span><br><span class="line">    # 基准情况</span><br><span class="line">    if:</span><br><span class="line">        li      $v0, 1</span><br><span class="line">        j       if_end  </span><br><span class="line">    # 递归情况  </span><br><span class="line">    else:</span><br><span class="line">        subi    $t1, $t0, 1	 </span><br><span class="line">        move    $a0, $t1</span><br><span class="line">        jal     factorial</span><br><span class="line">        mult    $t0, $v0</span><br><span class="line">        mflo    $v0</span><br><span class="line">    if_end:</span><br><span class="line">    # 出栈</span><br><span class="line">    pop($t0)</span><br><span class="line">    pop($ra)</span><br><span class="line">    # 返回</span><br><span class="line">    jr      $ra</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://pigkillermaster.github.io">pigKiller</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://pigkillermaster.github.io/2023/08/11/CO-preview/">https://pigkillermaster.github.io/2023/08/11/CO-preview/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://pigkillermaster.github.io" target="_blank">浮泛之舟</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%BB%84%E5%AE%9E%E9%AA%8C/">计组实验</a></div><div class="post_share"><div class="social-share" data-image="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202307251641570.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/07/31/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="python笔记"><img class="cover" src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202307251641574.jpg" onerror="onerror=null;src='https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202309212200810.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">python笔记</div></div></a></div><div class="next-post pull-right"><a href="/2023/09/01/%E8%AE%A1%E7%BB%84-%E9%BB%91%E4%B9%A6%E7%AC%94%E8%AE%B0/" title="计组-黑书笔记"><img class="cover" src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202307251641571.jpg" onerror="onerror=null;src='https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202309212200810.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">计组-黑书笔记</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/10/16/%E8%AE%A1%E7%BB%84-%E5%AE%9E%E9%AA%8C-P1/" title="计组-实验-P1"><img class="cover" src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202307251641570.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-16</div><div class="title">计组-实验-P1</div></div></a></div><div><a href="/2023/10/09/%E8%AE%A1%E7%BB%84-%E5%AE%9E%E9%AA%8C-P0/" title="计组-实验-P0"><img class="cover" src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202307251641570.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-09</div><div class="title">计组-实验-P0</div></div></a></div><div><a href="/2023/10/23/%E8%AE%A1%E7%BB%84-%E5%AE%9E%E9%AA%8C-P2/" title="计组-实验-P2"><img class="cover" src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202307251641570.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-23</div><div class="title">计组-实验-P2</div></div></a></div><div><a href="/2024/01/10/%E8%AE%A1%E7%BB%84-%E5%AE%9E%E9%AA%8C-P3/" title="计组-实验-P3"><img class="cover" src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202307251641570.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-10</div><div class="title">计组-实验-P3</div></div></a></div><div><a href="/2024/01/10/%E8%AE%A1%E7%BB%84-%E5%AE%9E%E9%AA%8C-P5/" title="计组-实验-P5"><img class="cover" src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202307251641570.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-10</div><div class="title">计组-实验-P5</div></div></a></div><div><a href="/2024/01/10/%E8%AE%A1%E7%BB%84-%E5%AE%9E%E9%AA%8C-P6/" title="计组-实验-P6"><img class="cover" src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202307251641570.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-10</div><div class="title">计组-实验-P6</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">虚拟机</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4"><span class="toc-number">1.1.</span> <span class="toc-text">基本命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E7%9B%AE%E5%BD%95"><span class="toc-number">1.1.1.</span> <span class="toc-text">主目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%93%E5%89%8D%E7%9B%AE%E5%BD%95"><span class="toc-number">1.1.2.</span> <span class="toc-text">当前目录</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">Logisim</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6"><span class="toc-number">2.1.</span> <span class="toc-text">组件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E5%9B%BE%E6%A0%87"><span class="toc-number">2.1.1.</span> <span class="toc-text">组件图标</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Wiring-%E7%BA%BF%E8%B7%AF-%E7%BB%84%E4%BB%B6"><span class="toc-number">2.1.1.1.</span> <span class="toc-text">Wiring(线路)组件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Gates-%E9%80%BB%E8%BE%91%E9%97%A8-%E7%BB%84%E4%BB%B6"><span class="toc-number">2.1.1.2.</span> <span class="toc-text">Gates(逻辑门)组件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Plexers-%E5%A4%8D%E7%94%A8%E5%99%A8-%E7%BB%84%E4%BB%B6"><span class="toc-number">2.1.1.3.</span> <span class="toc-text">Plexers(复用器)组件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Arithmetic-%E8%BF%90%E7%AE%97%E5%99%A8-%E7%BB%84%E4%BB%B6"><span class="toc-number">2.1.1.4.</span> <span class="toc-text">Arithmetic(运算器)组件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Memory-%E5%AD%98%E5%82%A8-%E7%BB%84%E4%BB%B6"><span class="toc-number">2.1.1.5.</span> <span class="toc-text">Memory(存储)组件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Input-Output-%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA-%E7%BB%84%E4%BB%B6"><span class="toc-number">2.1.1.6.</span> <span class="toc-text">Input&#x2F;Output(输入&#x2F;输出)组件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Base-%E5%9F%BA%E6%9C%AC-%E7%BB%84%E4%BB%B6"><span class="toc-number">2.1.1.7.</span> <span class="toc-text">Base(基本)组件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Tunnel"><span class="toc-number">2.1.2.</span> <span class="toc-text">Tunnel</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Pull-Register-%E4%B8%8A%E4%B8%8B%E6%8B%89%E7%94%B5%E9%98%BB"><span class="toc-number">2.1.3.</span> <span class="toc-text">Pull Register 上下拉电阻</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%92%9F"><span class="toc-number">2.1.4.</span> <span class="toc-text">时钟</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Power%E7%94%B5%E6%BA%90-Ground%E5%9C%B0%E7%BA%BF"><span class="toc-number">2.1.5.</span> <span class="toc-text">Power电源&#x2F;Ground地线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Transistor%E6%99%B6%E4%BD%93%E7%AE%A1"><span class="toc-number">2.1.6.</span> <span class="toc-text">Transistor晶体管</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%8D%E6%89%A9%E5%B1%95%E5%99%A8"><span class="toc-number">2.1.7.</span> <span class="toc-text">位扩展器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#n%E4%BD%8D%E5%BC%82%E6%88%96%E9%97%A8"><span class="toc-number">2.1.8.</span> <span class="toc-text">n位异或门</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A5%87%E6%A0%A1%E9%AA%8C-%E5%81%B6%E6%A0%A1%E9%AA%8C"><span class="toc-number">2.1.9.</span> <span class="toc-text">奇校验&#x2F;偶校验</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Controlled-Buffer-%E5%8F%97%E6%8E%A7%E7%BC%93%E5%86%B2%E5%99%A8-%E4%B8%89%E6%80%81%E9%97%A8"><span class="toc-number">2.1.10.</span> <span class="toc-text">Controlled Buffer 受控缓冲器&#x2F;三态门</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Multiplexer-%E5%A4%9A%E8%B7%AF%E9%80%89%E6%8B%A9%E5%99%A8"><span class="toc-number">2.1.11.</span> <span class="toc-text">Multiplexer 多路选择器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Demultiplexer-%E8%A7%A3%E5%A4%8D%E7%94%A8%E5%99%A8"><span class="toc-number">2.1.12.</span> <span class="toc-text">Demultiplexer 解复用器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Decoder-%E8%AF%91%E7%A0%81%E5%99%A8"><span class="toc-number">2.1.13.</span> <span class="toc-text">Decoder 译码器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Pirority-Encoder-%E4%BC%98%E5%85%88%E7%BC%96%E7%A0%81%E5%99%A8"><span class="toc-number">2.1.14.</span> <span class="toc-text">Pirority Encoder 优先编码器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bit-Selector-%E4%BD%8D%E9%80%89%E6%8B%A9%E5%99%A8"><span class="toc-number">2.1.15.</span> <span class="toc-text">Bit Selector 位选择器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E6%B3%95%E5%99%A8-%E5%87%8F%E6%B3%95%E5%99%A8"><span class="toc-number">2.1.16.</span> <span class="toc-text">加法器&#x2F;减法器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%98%E6%B3%95%E5%99%A8"><span class="toc-number">2.1.17.</span> <span class="toc-text">乘法器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%A4%E6%B3%95%E5%99%A8"><span class="toc-number">2.1.18.</span> <span class="toc-text">除法器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Negator-%E6%B1%82%E8%A1%A5%E5%99%A8"><span class="toc-number">2.1.19.</span> <span class="toc-text">Negator 求补器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E5%99%A8"><span class="toc-number">2.1.20.</span> <span class="toc-text">比较器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E4%BD%8D%E5%99%A8"><span class="toc-number">2.1.21.</span> <span class="toc-text">移位器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bit-Adder-%E9%80%90%E4%BD%8D%E5%8A%A0%E6%B3%95%E5%99%A8"><span class="toc-number">2.1.22.</span> <span class="toc-text">Bit Adder 逐位加法器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bit-Finder-%E4%BD%8D%E6%9F%A5%E6%89%BE%E5%99%A8"><span class="toc-number">2.1.23.</span> <span class="toc-text">Bit Finder 位查找器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91%E5%99%A8%E6%80%BB%E4%BD%93%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.1.24.</span> <span class="toc-text">触发器总体介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E5%A4%8D%E4%BD%8D%EF%BC%88%E5%9B%BA%E5%AE%9A%E8%A7%A6%E5%8F%91%E5%99%A8%E5%80%BC%E4%B8%BA0%EF%BC%89"><span class="toc-number">2.1.24.1.</span> <span class="toc-text">异步复位（固定触发器值为0）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E8%AE%BE%E7%BD%AE%EF%BC%88%E5%9B%BA%E5%AE%9A%E8%A7%A6%E5%8F%91%E5%99%A8%E5%80%BC%E4%B8%BA1%EF%BC%89"><span class="toc-number">2.1.24.2.</span> <span class="toc-text">异步设置（固定触发器值为1）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E8%83%BD%E7%AB%AF%EF%BC%88%E5%90%AF%E7%94%A8%E6%97%B6%E9%92%9F%E4%BF%A1%E5%8F%B7%EF%BC%89"><span class="toc-number">2.1.24.3.</span> <span class="toc-text">使能端（启用时钟信号）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#D-Flip-flop-D%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="toc-number">2.1.25.</span> <span class="toc-text">D Flip-flop D触发器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#T-Flip-flop-T%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="toc-number">2.1.26.</span> <span class="toc-text">T Flip-flop T触发器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#J-K-Flip-flop-JK%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="toc-number">2.1.27.</span> <span class="toc-text">J-K Flip-flop JK触发器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#S-R-Flip-flop-SR%E9%94%81%E5%AD%98%E5%99%A8"><span class="toc-number">2.1.28.</span> <span class="toc-text">S-R Flip-flop SR锁存器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Register-%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">2.1.29.</span> <span class="toc-text">Register 寄存器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Counter-%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-number">2.1.30.</span> <span class="toc-text">Counter 计数器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BA%A2%E5%87%BA%E6%97%B6%E6%93%8D%E4%BD%9C"><span class="toc-number">2.1.30.1.</span> <span class="toc-text">溢出时操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Shift-Register-%E7%A7%BB%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">2.1.31.</span> <span class="toc-text">Shift Register 移位寄存器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Random-Generator-%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8"><span class="toc-number">2.1.32.</span> <span class="toc-text">Random Generator 随机数生成器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RAM%EF%BC%9A%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%8F%96%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">2.1.33.</span> <span class="toc-text">RAM：随机存取存储器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%A0%E4%B8%AA%E5%BC%95%E8%84%9A"><span class="toc-number">2.1.33.1.</span> <span class="toc-text">几个引脚</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E5%90%8C%E6%AD%A5%E5%8A%A0%E8%BD%BD-%E5%AD%98%E5%82%A8%E7%AB%AF%E5%8F%A3-%E9%BB%98%E8%AE%A4"><span class="toc-number">2.1.33.2.</span> <span class="toc-text">一个同步加载&#x2F;存储端口(默认)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD-%E5%AD%98%E5%82%A8%E7%AB%AF%E5%8F%A3%EF%BC%88%E6%B6%88%E9%99%A4%E4%BA%86%E6%97%B6%E9%92%9F%E4%BF%A1%E5%8F%B7%EF%BC%89"><span class="toc-number">2.1.33.3.</span> <span class="toc-text">一个异步加载&#x2F;存储端口（消除了时钟信号）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E7%A6%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%92%8C%E5%AD%98%E5%82%A8%E7%AB%AF%E5%8F%A3%EF%BC%88%E6%B6%88%E9%99%A4%E4%BA%86%E4%B8%89%E6%80%81%E9%97%A8%EF%BC%89"><span class="toc-number">2.1.33.4.</span> <span class="toc-text">分离的加载和存储端口（消除了三态门）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ROM%E5%8F%AA%E8%AF%BB%E5%AD%98%E5%82%A8%E5%99%A8-Read-Only-Memory"><span class="toc-number">2.1.34.</span> <span class="toc-text">ROM只读存储器(Read-Only Memory)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%B6%E5%BA%8F%E7%94%B5%E8%B7%AF"><span class="toc-number">2.2.</span> <span class="toc-text">时序电路</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%92%9F%E6%B2%BF"><span class="toc-number">2.2.1.</span> <span class="toc-text">时钟沿</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E4%BD%8D%E4%BF%A1%E5%8F%B7"><span class="toc-number">2.2.2.</span> <span class="toc-text">复位信号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">2.2.3.</span> <span class="toc-text">寄存器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#step-simulation"><span class="toc-number">2.2.4.</span> <span class="toc-text">step simulation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E9%81%93%E5%A5%BD%E9%A2%98"><span class="toc-number">2.2.5.</span> <span class="toc-text">一道好题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">Verilog与工具仿真</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%8C%96%E5%BB%BA%E6%A8%A1"><span class="toc-number">3.1.</span> <span class="toc-text">结构化建模</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E7%9A%84%E5%86%85%E9%83%A8%E5%85%B8%E5%9E%8B%E7%BB%93%E6%9E%84"><span class="toc-number">3.1.1.</span> <span class="toc-text">模块的内部典型结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E7%94%B5%E8%B7%AF%E7%9A%84%E8%A1%8C%E4%B8%BA%E7%BA%A7%E6%8F%8F%E8%BF%B0"><span class="toc-number">3.2.</span> <span class="toc-text">实现电路的行为级描述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E7%BB%AD%E8%B5%8B%E5%80%BC%E8%AF%AD%E5%8F%A5-assign"><span class="toc-number">3.2.1.</span> <span class="toc-text">连续赋值语句 assign</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5%E4%B8%8E%E6%9C%89%E5%85%B3%E7%BB%93%E6%9E%84"><span class="toc-number">3.2.2.</span> <span class="toc-text">过程控制语句与有关结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.3.</span> <span class="toc-text">常见数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#wire%E5%9E%8B"><span class="toc-number">3.3.1.</span> <span class="toc-text">wire型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#reg%E5%9E%8B"><span class="toc-number">3.3.2.</span> <span class="toc-text">reg型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A9%E7%94%A8-reg-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%BB%BA%E6%A8%A1%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">3.3.2.1.</span> <span class="toc-text">利用 reg 数据类型建模存储器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="toc-number">3.3.3.</span> <span class="toc-text">数字字面量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#integer-%E5%9E%8B"><span class="toc-number">3.3.4.</span> <span class="toc-text">integer 型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#parameter-%E5%9E%8B"><span class="toc-number">3.3.5.</span> <span class="toc-text">parameter 型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E5%BB%BA%E6%A8%A1"><span class="toc-number">3.4.</span> <span class="toc-text">组合逻辑建模</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#assign-%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.4.1.</span> <span class="toc-text">assign 语句</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91%E5%BB%BA%E6%A8%A1"><span class="toc-number">3.5.</span> <span class="toc-text">时序逻辑建模</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#always-%E5%9D%97"><span class="toc-number">3.5.1.</span> <span class="toc-text">always 块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#initial-%E5%9D%97"><span class="toc-number">3.5.2.</span> <span class="toc-text">initial 块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#if-else%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.5.3.</span> <span class="toc-text">if-else语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#case-%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.5.4.</span> <span class="toc-text">case 语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#for-%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.5.5.</span> <span class="toc-text">for 语句</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E5%8F%98%E9%87%8F"><span class="toc-number">3.5.5.1.</span> <span class="toc-text">循环变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#for-%E8%AF%AD%E5%8F%A5%E5%AF%B9%E5%BA%94%E5%AE%9E%E9%99%85%E7%BA%BF%E8%B7%AF"><span class="toc-number">3.5.5.2.</span> <span class="toc-text">for 语句对应实际线路</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#while-%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.5.6.</span> <span class="toc-text">while 语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.5.7.</span> <span class="toc-text">时间控制语句</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Verilog%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7"><span class="toc-number">3.6.</span> <span class="toc-text">Verilog语言特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.6.1.</span> <span class="toc-text">常用运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E7%AC%A6%E5%8F%B7%E6%95%B0%E5%92%8C%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B0"><span class="toc-number">3.6.2.</span> <span class="toc-text">有符号数和无符号数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">3.6.2.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5"><span class="toc-number">3.6.2.2.</span> <span class="toc-text">特殊情况</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E9%81%93%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E9%A2%98%EF%BC%9Averilog-signed-verified-2"><span class="toc-number">3.6.2.2.1.</span> <span class="toc-text">一道有意思的题：verilog-signed_verified-2</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8F%E5%AE%9A%E4%B9%89%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8"><span class="toc-number">3.6.3.</span> <span class="toc-text">宏定义的简单使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E5%86%99testbench"><span class="toc-number">3.6.4.</span> <span class="toc-text">编写testbench</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="toc-number">3.6.5.</span> <span class="toc-text">模块实例化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E9%A2%84%E5%A4%84%E7%90%86"><span class="toc-number">3.6.6.</span> <span class="toc-text">编译预处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#define"><span class="toc-number">3.6.6.1.</span> <span class="toc-text">define</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#include"><span class="toc-number">3.6.6.2.</span> <span class="toc-text">include</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#timescale"><span class="toc-number">3.6.6.3.</span> <span class="toc-text">timescale</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91%E5%91%BD%E4%BB%A4-ifdef-else-elsif-endif-ifndef"><span class="toc-number">3.6.6.4.</span> <span class="toc-text">条件编译命令 ifdef, else, elsif, endif, ifndef</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E4%BB%BB%E5%8A%A1"><span class="toc-number">3.6.7.</span> <span class="toc-text">系统任务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E4%BF%A1%E6%81%AF"><span class="toc-number">3.6.7.1.</span> <span class="toc-text">输出信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%91%E6%8E%A7%E5%8F%98%E9%87%8F"><span class="toc-number">3.6.7.2.</span> <span class="toc-text">监控变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E5%88%B0%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">3.6.7.3.</span> <span class="toc-text">读取文件到存储器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%82%E6%AC%A1%E5%8C%96%E4%BA%8B%E4%BB%B6%E9%98%9F%E5%88%97"><span class="toc-number">3.6.8.</span> <span class="toc-text">层次化事件队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#default-nettype"><span class="toc-number">3.6.9.</span> <span class="toc-text">default nettype</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">3.6.10.</span> <span class="toc-text">函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E7%BB%BC%E5%90%88%E7%9A%84Verilog%E4%BB%A3%E7%A0%81"><span class="toc-number">3.7.</span> <span class="toc-text">可综合的Verilog代码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E8%A6%81%E7%94%A8-initial-%E5%9D%97%E3%80%81%E4%B8%8D%E8%A6%81%E4%B8%BA%E5%AF%84%E5%AD%98%E5%99%A8%E8%B5%8B%E5%88%9D%E5%80%BC"><span class="toc-number">3.7.1.</span> <span class="toc-text">不要用 initial 块、不要为寄存器赋初值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E5%AF%84%E5%AD%98%E5%99%A8%E5%8F%AA%E8%83%BD%E5%9C%A8%E4%B8%80%E4%B8%AA-always-%E5%9D%97%E4%B8%AD%E8%B5%8B%E5%80%BC%E4%B8%80%E6%AC%A1"><span class="toc-number">3.7.2.</span> <span class="toc-text">一个寄存器只能在一个 always 块中赋值一次</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E7%9B%B8%E5%85%B3%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">3.7.3.</span> <span class="toc-text">组合逻辑相关注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%BC%E5%90%88%E7%9A%84%E5%85%B6%E4%BB%96%E8%A6%81%E6%B1%82"><span class="toc-number">3.7.4.</span> <span class="toc-text">综合的其他要求</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#System-verilog"><span class="toc-number">3.8.</span> <span class="toc-text">System verilog</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#logic"><span class="toc-number">3.8.1.</span> <span class="toc-text">logic</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E5%8F%98%E9%87%8F"><span class="toc-number">3.8.2.</span> <span class="toc-text">新变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#always"><span class="toc-number">3.8.3.</span> <span class="toc-text">always</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%B9%E8%BF%9B%E7%9A%84case%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.8.4.</span> <span class="toc-text">改进的case语句</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#unique"><span class="toc-number">3.8.4.1.</span> <span class="toc-text">unique</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#priority"><span class="toc-number">3.8.4.2.</span> <span class="toc-text">priority</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E9%9D%A2C%E8%AF%AD%E8%A8%80%E5%8C%96"><span class="toc-number">3.8.5.</span> <span class="toc-text">全面C语言化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#break"><span class="toc-number">3.8.5.1.</span> <span class="toc-text">break</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#continue"><span class="toc-number">3.8.5.2.</span> <span class="toc-text">continue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#return"><span class="toc-number">3.8.5.3.</span> <span class="toc-text">return</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#typedef"><span class="toc-number">3.8.5.4.</span> <span class="toc-text">typedef</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#struct"><span class="toc-number">3.8.5.5.</span> <span class="toc-text">struct</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#parameter"><span class="toc-number">3.8.5.6.</span> <span class="toc-text">parameter</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">Mips</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E7%AE%80%E4%BB%8B"><span class="toc-number">4.1.</span> <span class="toc-text">寄存器简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#s%E5%AF%84%E5%AD%98%E5%99%A8%E5%92%8Ct%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.1.1.</span> <span class="toc-text">s寄存器和t寄存器的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4"><span class="toc-number">4.2.</span> <span class="toc-text">汇编指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F"><span class="toc-number">4.2.1.</span> <span class="toc-text">指令格式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#R-%E5%9E%8B%E6%8C%87%E4%BB%A4"><span class="toc-number">4.2.1.1.</span> <span class="toc-text">R 型指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#I-%E5%9E%8B%E6%8C%87%E4%BB%A4"><span class="toc-number">4.2.1.2.</span> <span class="toc-text">I 型指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#J-%E5%9E%8B%E6%8C%87%E4%BB%A4"><span class="toc-number">4.2.1.3.</span> <span class="toc-text">J 型指令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F"><span class="toc-number">4.2.2.</span> <span class="toc-text">注意</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E7%9B%B8%E5%85%B3"><span class="toc-number">4.2.2.1.</span> <span class="toc-text">地址相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%87%BA%E5%92%8C%E5%86%99%E5%85%A5"><span class="toc-number">4.2.2.2.</span> <span class="toc-text">读出和写入</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%AA%E6%8C%87%E4%BB%A4%EF%BC%88DIRECTIVES%EF%BC%89"><span class="toc-number">4.2.3.</span> <span class="toc-text">伪指令（DIRECTIVES）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8F"><span class="toc-number">4.2.4.</span> <span class="toc-text">宏</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%B8%A6%E5%8F%82%E6%95%B0"><span class="toc-number">4.2.4.1.</span> <span class="toc-text">不带参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%A6%E5%8F%82%E6%95%B0"><span class="toc-number">4.2.4.2.</span> <span class="toc-text">带参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E5%AE%9A%E4%B9%89"><span class="toc-number">4.2.4.3.</span> <span class="toc-text">常量定义</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E6%8C%87%E4%BB%A4"><span class="toc-number">4.2.5.</span> <span class="toc-text">扩展指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#li"><span class="toc-number">4.2.5.1.</span> <span class="toc-text">li</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#la"><span class="toc-number">4.2.5.2.</span> <span class="toc-text">la</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">4.2.6.</span> <span class="toc-text">系统调用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mars"><span class="toc-number">4.3.</span> <span class="toc-text">Mars</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E7%A8%8B%E5%BA%8F"><span class="toc-number">4.4.</span> <span class="toc-text">汇编程序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF"><span class="toc-number">4.4.1.</span> <span class="toc-text">循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">4.4.2.</span> <span class="toc-text">数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">4.4.3.</span> <span class="toc-text">二维数组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88"><span class="toc-number">4.5.</span> <span class="toc-text">栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%A7%84%E8%8C%83"><span class="toc-number">4.5.1.</span> <span class="toc-text">使用规范</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">4.5.2.</span> <span class="toc-text">使用方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="toc-number">4.6.</span> <span class="toc-text">函数调用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E7%94%A8%E4%BB%A3%E7%A0%81"><span class="toc-number">4.6.1.</span> <span class="toc-text">复用代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%AF%B9%E5%A4%96%E7%95%8C%E9%80%A0%E6%88%90%E5%BD%B1%E5%93%8D"><span class="toc-number">4.6.2.</span> <span class="toc-text">不对外界造成影响</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="toc-number">4.6.3.</span> <span class="toc-text">嵌套函数调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="toc-number">4.6.4.</span> <span class="toc-text">递归函数调用</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2024 By pigKiller</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">你终会看到，你的歌声和旗帜在飘扬</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script></div><script src="f12.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>