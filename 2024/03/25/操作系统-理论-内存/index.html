<!DOCTYPE html><html lang="zh-CN" data-theme="light"><script>((function() {var callbacks = [],timeLimit = 50,open = false;setInterval(loop, 1);return {addListener: function(fn) {callbacks.push(fn);},cancleListenr: function(fn) {callbacks = callbacks.filter(function(v) {return v !== fn;});}}
function loop() {var startTime = new Date();debugger;if (new Date() - startTime > timeLimit) {if (!open) {callbacks.forEach(function(fn) {fn.call(null);});}open = true;window.stop();alert('你真坏，请关闭控制台！');document.body.innerHTML = "";} else {open = false;}}})()).addListener(function() {window.location.reload();});</script><script>function toDevtools(){
  let num = 0; 
  let devtools = new Date();
  devtools.toString = function() {
    num++;
    if (num > 1) {
        alert('你真坏，请关闭控制台！')
        window.location.href = "about:blank"
        blast();
    }
  }
  console.log('', devtools);
}
toDevtools();</script><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>操作系统-理论-内存 | 浮泛之舟</title><meta name="author" content="pigKiller"><meta name="copyright" content="pigKiller"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="存储 存储资源是一种宝贵的资源，无论存储器有多大，程序最终都能将其耗尽。 静态存储器SRAM：读写速度块、生产成本高、多用作Cache 动态存储器DRAM：读写速度慢、集成度高、生产成本低、多用作主存储器 存储组织 存储组织：再存储技术和CPU寻址技术许可的范围内组织合理的存储结构。 合理结合不同的存储器，达到各层次的存储器都处于均衡的繁忙状态的理想效果（命中率），营造又快又大的错觉。 典型的层次">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统-理论-内存">
<meta property="og:url" content="https://pigkillermaster.github.io/2024/03/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%90%86%E8%AE%BA-%E5%86%85%E5%AD%98/index.html">
<meta property="og:site_name" content="浮泛之舟">
<meta property="og:description" content="存储 存储资源是一种宝贵的资源，无论存储器有多大，程序最终都能将其耗尽。 静态存储器SRAM：读写速度块、生产成本高、多用作Cache 动态存储器DRAM：读写速度慢、集成度高、生产成本低、多用作主存储器 存储组织 存储组织：再存储技术和CPU寻址技术许可的范围内组织合理的存储结构。 合理结合不同的存储器，达到各层次的存储器都处于均衡的繁忙状态的理想效果（命中率），营造又快又大的错觉。 典型的层次">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403252018445.png">
<meta property="article:published_time" content="2024-03-25T12:16:53.000Z">
<meta property="article:modified_time" content="2024-03-30T12:57:58.946Z">
<meta property="article:author" content="pigKiller">
<meta property="article:tag" content="OS理论">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403252018445.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://pigkillermaster.github.io/2024/03/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%90%86%E8%AE%BA-%E5%86%85%E5%AD%98/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '操作系统-理论-内存',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2024-03-30 20:57:58'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202307102227559.png" onerror="onerror=null;src='https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202309212200810.jpg'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">41</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">29</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">19</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-categories"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403252018445.png')"><nav id="nav"><span id="blog-info"><a href="/" title="浮泛之舟"><span class="site-name">浮泛之舟</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-categories"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">操作系统-理论-内存</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-03-25T12:16:53.000Z" title="发表于 2024-03-25 20:16:53">2024-03-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-03-30T12:57:58.946Z" title="更新于 2024-03-30 20:57:58">2024-03-30</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/OS%E7%90%86%E8%AE%BA/">OS理论</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">17.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>51分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="操作系统-理论-内存"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>存储</h1>
<p>存储资源是一种宝贵的资源，无论存储器有多大，程序最终都能将其耗尽。</p>
<p>静态存储器SRAM：读写速度块、生产成本高、多用作Cache</p>
<p>动态存储器DRAM：读写速度慢、集成度高、生产成本低、多用作主存储器</p>
<h2 id="存储组织">存储组织</h2>
<p>存储组织：再存储技术和CPU寻址技术许可的范围内<strong>组织合理的存储结构</strong>。</p>
<p>合理结合不同的存储器，达到各层次的存储器都处于均衡的繁忙状态的理想效果（命中率），营造又快又大的错觉。</p>
<p>典型的层次式存储组织：访问速度越来越慢，容量越来越大，价格越来越便宜</p>
<h2 id="存储管理">存储管理</h2>
<p>存储管理的功能：</p>
<ul>
<li>
<p>存储分配和回收：存储管理的主要内容。</p>
<ul>
<li>关注其算法和相应的数据结构。</li>
</ul>
</li>
<li>
<p>地址变换：</p>
<ul>
<li>可执行文件生成中的链接技术</li>
<li>程序加载时的重定位技术</li>
<li>进程运行时硬件和软件的地址变换技术和机构</li>
</ul>
</li>
<li>
<p>存储共享和保护：代码和数据共享，对地址空间的访问权限（读、写、执行）。</p>
</li>
<li>
<p>存储器扩充：涉及存储器的逻辑组织和物理组织；</p>
<ul>
<li>由应用程序控制：覆盖；</li>
<li>由OS控制：交换（整个进程空间），请求调入和预调入（部分进程空间）</li>
</ul>
</li>
</ul>
<h1>编译、链接、装入</h1>
<p>怎么从代码到可执行文件。</p>
<h2 id="gcc的工作">gcc的工作</h2>
<p>GCC编译器驱动程序读取源程序文件<code>*.c</code>，并把它翻译成一个可执行目标文件<code>*</code>。这个翻译过程分为四个阶段：<strong>预处理（Preprocessing）、编译（Compilation）、汇编（Assembly）、链接（Linking）</strong>。执行这四个阶段的程序（<strong>预处理器、编译器、汇编器、和链接器</strong>）一起构成了编译系统。</p>
<p>gcc调用包含的工具：</p>
<ul>
<li><code>cc1</code>：预处理器和编译器</li>
<li><code>as</code>：汇编器</li>
<li><code>collect2</code>：链接器</li>
</ul>
<p>具体流程：</p>
<ol>
<li>
<p>预处理阶段</p>
<ol>
<li>处理所有的预处理，包括<code>define</code>，<code>ifdefine</code></li>
<li>删除所有的注释。</li>
<li>添加行号和文件标识，以便编译时产生调试用的行号及编译错误警告行号。</li>
<li><strong>保留所有的<code>#pragma</code>编译器指令</strong>，因为编译器需要使用它们。</li>
<li>使用<code>gcc -E hello.c -o hello.i</code>命令来进行预处理， 预处理得到的另一个程序通常是以<code>.i</code>作为文件扩展名。</li>
</ol>
</li>
<li>
<p>编译阶段</p>
<ol>
<li>编译器（<code>ccl</code>）将预处理完的文本文件<code>hello.i</code>翻译成文本文件<code>hello.s</code>，它包含一个<strong>汇编语言程序</strong>：汇编语言是非常有用的，因为它为不同高级语言的不同编译器提供了通用的输出语言。</li>
<li>该程序包含函数<code>main</code>的定义。</li>
</ol>
</li>
<li>
<p>汇编阶段：</p>
<ol>
<li>汇编器（<code>as</code>）将<code>hello.s</code><strong>翻译成机器语言指令</strong></li>
<li>把这些指令打包成一种叫做<strong>可重定位目标程序</strong>的格式</li>
<li>并将结果保存在目标文件<code>hello.o</code>中，<code>hello.o</code>是一个二进制文件。</li>
</ol>
</li>
<li>
<p>链接</p>
<ol>
<li><code>hello</code>程序调用了<code>printf</code>函数，它存在于一个名为<code>printf.o</code>的单独的预编译好了的目标文件中，而这个文件必须以某种方式合并到我们的<code>hello.o</code>程序中。</li>
<li>连接器（<code>ld</code>）就负责处理这种合并。结果就得到了hello文件，它是一个<strong>可执行目标文件</strong>（或者称为<strong>可执行文件</strong>）</li>
<li>可执行文件可以被加载到内存中，由系统执行。</li>
</ol>
</li>
</ol>
<h2 id="可执行文件">可执行文件</h2>
<p>可执行文件的常见格式为ELF文件。</p>
<ol>
<li>ELF头，包括程序的基本信息，比如体系结构和操作系统，同时也包含了节头表和段头表相对文件的偏移量（offset）。</li>
<li>段头表（或程序头表，program header table），主要包含程序中各个段（segment）的信息，段的信息需要在运行时刻使用。</li>
<li>节头表（section header table），主要包含程序中各个节（section）的信息，节的信息需要在程序编译和链接的时候使用。</li>
<li>段头表中的每一个表项，记录了该段数据载入内存时的目标位置等，记录了用于指导应用程序加载的各类信息。</li>
<li>节头表中的每一个表项，记录了该节程序的代码段、数据段等各个段的内容，主要是链接器在链接的过程中需要使用。</li>
</ol>
<p>段头表和节头表指向了同样的地方，这意味着两者只是程序数据的两种视图：</p>
<ol>
<li>组成可重定位文件，参与可执行文件和可共享文件的链接。此时使用节头表。</li>
<li>组成可执行文件或者可共享文件，在运行时为加载器提供信息。此时使用段头表。</li>
</ol>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403182039357.png" alt="image-20240318203921231"></p>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403182039285.png" alt="image-20240318203948152"></p>
<h3 id="具体划分">具体划分</h3>
<p>一个程序本质上都是由bss段、data段、text段三个组成的。</p>
<p>在C语言之类的程序编译完成之后，已初始化的全局变量保存在data 段中，未初始化的全局变量保存在bss 段中。</p>
<ul>
<li>bss段：（bss segment）用来存放程序中<strong>未初始化的全局变量</strong>的一块内存区域。bss段属于<strong>静态内存分配</strong>。</li>
<li>data段：数据段（data segment）用来存放程序中<strong>已初始化的全局变量</strong>的一块内存区域。数据段属于<strong>静态内存分配</strong>。</li>
<li>text段：代码段（code segment/text segment）用来<strong>存放程序执行代码</strong>的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读（某些架构也允许代码段为可写，即允许修改程序）。在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。</li>
</ul>
<p>text和data段都在可执行文件中，由系统从可执行文件中加载，而<strong>bss段不在可执行文件中，由系统初始化</strong>。</p>
<p>一个装入内存的可执行程序，除了bss、data和text段外，还需构建<strong>一个栈（stack）和一个堆（heap）</strong>。</p>
<ul>
<li>栈(stack)：存放、交换<strong>临时数据</strong>的内存区
<ul>
<li>用户存放程序局部变量的内存区域，（但不包括static声明的变量，<strong>static意味着在数据段中存放变量</strong>）。</li>
<li>保存/恢复调用现场。在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。</li>
</ul>
</li>
<li>堆（heap）：存放进程<strong>运行中动态分配的内存段</strong>
<ul>
<li>它的大小并不固定，可动态扩张或缩减。当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）。</li>
</ul>
</li>
</ul>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403182109468.png" alt="image-20240318210916389"></p>
<h2 id="重定位">重定位</h2>
<ol>
<li>地址空间：源程序经过编译后得到的目标程序，存在于它所限定的地址范围内，这个范围称为地址空间。<strong>地址空间是逻辑地址的集合</strong>。</li>
<li>存储空间：存储空间是指主存中一系列存储信息的物理单元的集合，这些单元的编号称为物理地址或绝对地址。<strong>存储空间是物理地址的集合</strong>。</li>
</ol>
<p>作业会有存储空间装入存储空间。重定位是在装入时对目标程序中的<strong>指令和数据地址的修改</strong>，或映射过程。</p>
<p>在编译后，原先的函数跳转变为了形如<code>jal func_name</code>的汇编指令，但是具体的跳转地址却是0，这显然是不正常的。这是因为编译时函数定义在不同的文件中，无法知道准确的地址，因而需要<strong>重定位</strong>来填入具体的地址。</p>
<p><strong>重定位的过程在连接中完成</strong>。链接将生成的机器码<code>.o</code>文件链接到一起，形成最终的可执行文件。在链接时，链接器会扫描各个目标文件，将之前未填写的地址填写上，从而生成一个真正可执行的文件。</p>
<p>在Mips体系结构中，<code>Elf32_Rel</code>给出了重定位的地点.</p>
<ul>
<li><code>r_offest</code>给出了<strong>使用重定位动作的地点</strong>。
<ul>
<li>对重定位文件来说，值是从<strong>节起始处</strong>到受重定位影响的<strong>存储单元的字节偏移量</strong>；</li>
<li>对<strong>可执行文件或共享目标文件</strong>来说，它的值是受重定位影响的存储单元的<strong>虚拟地址</strong>。</li>
</ul>
</li>
<li><code>r_info</code>给出了与重定位修改地点有关的符号表索引和所使用的重定位的类型。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf32_Addr r_offset;</span><br><span class="line">    Elf32_Word r_info;	<span class="comment">//(symbol:24; type:8)</span></span><br><span class="line">&#125; Elf32_Rel;</span><br></pre></td></tr></table></figure>
<p>重定位/链接的本质：河边不同可执行文件中相同的节</p>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403182110975.png" alt="image-20240318211052894"></p>
<h2 id="程序">程序</h2>
<p>程序的入口也写在ELF文件中，但是不是Main函数的地址。一般为<code>_start</code>函数，在这个入口函数中调用了<code>main</code>。</p>
<p>执行程序的过程：<code>shell</code>调用<code>fork()</code>系统调用，创建出一个子进程子进程调用<code>Execve()</code>加载<code>program</code></p>
<ul>
<li>
<p>装载前的工作：<code>shell</code>调用<code>fork()</code>系统调用，创建出一个子进程。</p>
</li>
<li>
<p>装载工作：子进程调用<code>execve()</code>加载<code>program</code>（即要执行的程序）。</p>
</li>
<li>
<p>程序如何被加载：</p>
<ul>
<li>
<p>加载器在加载程序的时候只需要看ELF文件中和segment相关的信息即可。</p>
<ul>
<li>读出的信息分为两部分，一部分是各segment的具体信息，另一部分是section和segment之间的对应关系。类型为Type为Load的segment是<strong>需要被加载到内存中的部分</strong>。</li>
</ul>
<ol>
<li>读取ELF头部的魔数(Magic Number)，以确认该文件确实是ELF文件。
<ol>
<li>ELF文件的头四个字节依次为<code>0x7f</code>、<code>E</code>、<code>L</code>、<code>F</code>。加载器会首先对比这四个字节，若不一致，则报错。</li>
</ol>
</li>
<li>找到段表项。
<ol>
<li>ELF头部会给出的段表起始位置在文件中的偏移，段表项的大小，以及段表包含了多少项。根据这些信息可以找到每一个段表项。</li>
</ol>
</li>
<li>对于每个段表项解析出各个段应当被加载的虚地址，在文件中的偏移。以及在内存中的大小和在文件中的大小。（段在文件中的大小小于等于内存中的大小）。</li>
<li>对于每一个段，根据其在内存中的大小，为其分配足够的物理页，并映射到指定的虚地址上。再将文件中的内容拷贝到内存中。
<ol>
<li>若ELF中记录的段在内存中的大小大于在文件中的大小，则多出来的部分用0进行填充。</li>
<li>一个segment<strong>在文件中的大小是小于等于其在内存中的大小</strong>：如果在文件中的大小小于在内存中的大小，那么在载入内存时通过补零使其达到其在内存中应有的大小。</li>
</ol>
</li>
<li>设置进程控制块中的PC为ELF文件中记载的入口地址。</li>
<li>各个segment都装入内存后，控制权交给应用，从应用入口开始，将控制权交给进程开始执行！</li>
</ol>
</li>
</ul>
</li>
</ul>
<img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403182057312.png" alt="image-20240318205727189" style="zoom:50%;" />
<h1>存储管理</h1>
<p>存储管理的基石：</p>
<ol>
<li>地址独立：程序发出的地址与物理地址无关</li>
<li>地址保护：一个程序不能访问另一个程序的地址空间</li>
</ol>
<p>存储管理要解决的问题：分配和回收</p>
<h2 id="存储分配">存储分配</h2>
<ol>
<li>直接指定方式：程序员在编程序时，或编译程序(汇编程序)对源程序进行编译(汇编)时，所用的是<strong>实际地址</strong>（即为物理地址）。</li>
<li>静态分配(Static Allocation)：程序员编程时，或由编译程序产生的目的程序，均可从其<strong>地址空间的零地址</strong>（虚拟地址）开始；当装配程序对其进行连接装入时才确定它们在主存中的地址。</li>
<li>动态分配(Dynamic Allocation)：作业在存储空间中的位置，在其装入时确定,在其执行过程中可根据需要申请附加的存储空间，而且一个作业已占用的部分区域不再需要时，可以要求归还给系统。</li>
</ol>
<h3 id="单道程序">单道程序</h3>
<p>单道程序：整个内存中只有两个程序，一个用户程序和操作系统。</p>
<p>操作系统所占空间是固定的，因而可以将用户程序加载到同一个地址，即用户地址永远从同一个地方开始运行。</p>
<p>因为只有一个用户程序，故天然的有地址独立和地址保护。这样的操作不需要地址映射，可以直接使用物理地址。</p>
<p>优点：执行过程中无需任何地址翻译工作，程序运行速度快。</p>
<p>缺点：</p>
<ol>
<li>比物理内存大的程序无法加载，因而无法运行。</li>
<li>造成资源浪费：小程序会造成空间浪费、I/O时间长会造成计算资源浪费。</li>
</ol>
<h3 id="多道程序">多道程序</h3>
<p>空间分配为分区式：把内存分为一些<strong>大小相等或不等的分区</strong>(partition)，<strong>每个应用程序占用一个或几个分区</strong>。操作系统占用其中<strong>一个分区</strong>。</p>
<p>支持多个程序并发执行，但难以进行内存分区的共享</p>
<h4 id="分区方式">分区方式</h4>
<ul>
<li>固定（静态）式分区分配，程序适应分区。</li>
<li>可变（动态）式分区分配，分区适应程序。</li>
</ul>
<h5 id="固定式分区">固定式分区</h5>
<p>把内存划分为若干个固定大小的连续分区。</p>
<ul>
<li>分区大小相等：只适合于多个相同程序的并发执行（处理多个类型相同的对象）。</li>
<li>分区大小不等：多个小分区、适量的中等分区、少量的大分区。根据程序的大小，分配当前空闲的、适当大小的分区。</li>
</ul>
<p>优点：易于实现，开销小。</p>
<p>缺点：内碎片造成浪费，分区总数固定，限制了并发执行的程序数目。</p>
<p>采用的数据结构：分区表：记录分区的大小和使用情况</p>
<ol>
<li>
<p>单一队列的分配方式</p>
<p>当需要加载程序时，选择一个当前闲置且容量足够大的分区进行加载，可采用共享队列的固定分区（多个用户程序排在一个共同的队列里面等待分区）分配。</p>
<img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403182122194.png" alt="image-20240318212212119" style="zoom:50%;" />
</li>
<li>
<p>多队列分配方式</p>
<p>由于程序大小和分区大小不一定匹配，有可能形成<strong>一个小程序占用一个大分区的情况</strong>，从而造成内存里虽然有小分区闲置但无法加载大程序的情况。这时，可以采用多个队列，给每个分区一个队列，程序按照大小排在相应的队列里。</p>
<img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403182122787.png" alt="image-20240318212217725" style="zoom:50%;" />
</li>
</ol>
<h5 id="可变式分区">可变式分区</h5>
<p>可变式分区：分区的边界可以移动，即分区的大小可变。</p>
<p>优点：没有内碎片</p>
<p>缺点：有外碎片</p>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403182123334.png" alt="image-20240318212333066"></p>
<h2 id="闲置空间的管理">闲置空间的管理</h2>
<p>在管理内存的时候，OS需要知道内存空间有多少空闲。这就需要<strong>跟踪内存的使用</strong>。</p>
<p>跟踪的办法有两种：位图表示法（分区表）和链表表示法（分区链表）</p>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403182129884.png" alt="image-20240318212909769"></p>
<ol>
<li>
<p>位图表示法</p>
<p>给<strong>每个分配单元赋予一个字位</strong>，用来记录该分配单元是否闲置。例如，字位取值为0表示单元闲置，取值为1则表示已被占用，这种表示方法就是位图表示法。</p>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403182124360.png" alt="image-20240318212431295"></p>
</li>
<li>
<p>链表表示法</p>
<p>将分配单元<strong>按照是否闲置链接起来</strong>，这种方法称为链表表示法。</p>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403182124480.png" alt="image-20240318212442396"></p>
</li>
</ol>
<p>位图表示法：</p>
<ul>
<li>空间成本固定：不依赖于内存中的程序数量。</li>
<li>时间成本低：操作简单，直接修改其位图值即可。</li>
<li>没有容错能力：如果一个分配单元为1，不能肯定<strong>应该为1还是因错误变成1</strong>。</li>
</ul>
<p>链表表示法：</p>
<ul>
<li>空间成本：取决于程序的数量。</li>
<li>时间成本：链表扫描通常速度较慢，还要进行链表项的插入、删除和修改。</li>
<li>有一定容错能力：因为链表有被占空间和闲置空间的表项，可以<strong>相互验证</strong>。</li>
</ul>
<h3 id="可变分区的管理">可变分区的管理</h3>
<p>内存分配采用两张表：已分配分区表和未分配分区表。</p>
<p>每张表的表项为存储控制块MCB（Memory Control Block），包括已分配AMCB（Allocated）和未分配FMCB（Free）。</p>
<p>空闲分区控制块按某种次序构成FMCB链表结构。当分区被分配出去以后，前、后向指针无意义。</p>
<img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403182131722.png" alt="image-20240318213136617" style="zoom:50%;" />
<img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403182131563.png" alt="image-20240318213150482" style="zoom: 67%;" />
<h2 id="分配内存">分配内存</h2>
<p>有了对空闲空间的追踪，就可以对内存进行动态分配，让空余内存得到使用，同时不影响已分配内存区域的正常使用。</p>
<ol>
<li>规定size是不再切割的剩余分区的大小。设请求的分区大小为<code>u.size</code>，空闲分区的大小为<code>m.size</code>。</li>
<li>若<code>m.size-u.size≤size</code>，将整个分区分配给请求者。</li>
<li>否则，从该分区中按请求的大小划分出一块内存空间分配出去，余下的部分仍留在空闲分区表/链中。</li>
</ol>
<h3 id="基于顺序搜索的分配方法">基于顺序搜索的分配方法</h3>
<ol>
<li>
<p>首次适应算法（First Fit）：每个空白区按其在存储空间中地址递增的顺序连在一起，在为作业分配存储区域时，从这个空白区域链的始端开始查找，选择<strong>第一个足以满足请求的空白块</strong>。</p>
<ol>
<li>
<p>优点：</p>
<ol>
<li>分配和释放的时间性能较好</li>
<li><strong>较大的空闲分区保留在内存的高端</strong></li>
</ol>
</li>
<li>
<p>缺点：随着低端内存被不断分配，会产生很多小分区，开销会增大。</p>
</li>
</ol>
</li>
<li>
<p>下次适应算法（Next Fit）：把存储空间中空白区<strong>构成一个循环链</strong>，每次为存储请求查找合适的分区时，总是<strong>从上次查找结束的地方开始</strong>，只要找到一个足够大的空白区，就将它划分后分配出去。</p>
<ol>
<li>多余的地址会保留，下次从多余地址处开始搜索</li>
</ol>
</li>
<li>
<p>最佳适应算法（Best Fit）：为一个作业选择分区时，总是寻找其<strong>大小最接近于</strong>作业所要求的存储区域。</p>
</li>
<li>
<p>最坏适应算法（Worst Fit）：为作业选择存储区域时，总是寻找<strong>最大的空白区</strong>。</p>
</li>
</ol>
<p>算法特点：</p>
<ol>
<li>首次适应：优先利用内存低地址部分的空闲分区。但由于<strong>低地址部分不断被划分</strong>，留下许多<strong>难以利用的很小的空闲分区</strong>（碎片或零头），而每次查找又都是从低地址部分开始，<strong>增加了查找可用空闲分区的开销</strong>。</li>
<li>下次适应：使存储空间的利用更加均衡，不致使小的空闲区集中在存储区的一端，但这会<strong>导致缺乏大的空闲分区</strong>。</li>
<li>最佳适应：若存在与作业大小一致的空闲分区,则它必然被选中，若不存在与作业大小一致的空闲分区，则只划分比作业稍大的空闲分区，从而保留了大的空闲分区。最佳适应算法往往使<strong>剩下的空闲区非常小</strong>，从而在存储器中留下许多难以利用的小空闲区（碎片）。</li>
<li>最坏适应算法的特点：总是挑选满足作业要求的最大的分区分配给作业。这样使分给作业后剩下的空闲分区也较大，可装下其它作业。由于最大的空闲分区总是因首先分配而划分，<strong>当有大作业到来时，其存储空间的申请往往会得不到满足</strong>。</li>
</ol>
<p>最佳适应算法是<strong>内存分配和释放平均时间之和最大</strong>的算法</p>
<h3 id="基于索引搜索的分配方法">基于索引搜索的分配方法</h3>
<p>基于顺序搜索的动态分区分配算法一般只是适合于较小的系统，如果系统的分区很多，空闲分区表（链）可能很大（很长），检索速度会比较慢。为了提高搜索空闲分区的速度，<strong>大中型系统</strong>采用了基于索引搜索的动态分区分配算法。</p>
<h4 id="快速适应算法">快速适应算法</h4>
<p>快速适应算法，又称为分类搜索法，把空闲分区<strong>按容量大小进行分类</strong>，<strong>经常用到长度</strong>的空闲区设立<strong>单独的空闲区链表</strong>。系统为多个空闲链表设立一张管理索引表。</p>
<p>优点：</p>
<ol>
<li>查找效率高，仅需要根据程序的长度，寻找到能容纳它的最小空闲区链表，取下第一块进行分配即可。</li>
<li>该算法在分配时，不会对任何分区产生分割，所以<strong>能保留大的分区</strong>，也不会产生内存碎片。</li>
</ol>
<p>缺点：</p>
<ol>
<li>在分区归还主存时算法复杂，系统开销较大。</li>
<li>在<strong>分配空闲分区时是以进程为单位</strong>，<strong>一个分区只属于一个进程</strong>，存在一定的浪费。空间换时间。</li>
</ol>
<h4 id="伙伴系统">伙伴系统</h4>
<p>固定分区方式不够灵活，当进程大小与空闲分区大小不匹配时，内存空间利用率很低。动态分区方式算法复杂，回收空闲分区时需要进行分区合并等，系统开销较大。</p>
<p>伙伴系统(buddy system)是介于固定分区与可变分区之间的动态分区技术。</p>
<p>伙伴：在分配存储块时<strong>将一个大的存储块分裂成两个大小相等的小块</strong>，这两个小块就称为“伙伴”。</p>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403182150634.png" alt="image-20240318215024536"></p>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403182150407.png" alt="image-20240318215042332"></p>
<h2 id="系统中的碎片">系统中的碎片</h2>
<p>内存中无法被利用的存储空间称为碎片。</p>
<p>内部碎片：</p>
<ul>
<li>指分配给作业的存储空间中未被利用的部分，如固定分区中存在的碎片。</li>
<li>单一连续区存储管理、固定分区存储管理等都会出现内部碎片。</li>
<li>内部碎片无法被整理，但作业完成后会得到释放。它们<strong>其实已经被分配出去了，只是没有被利用</strong>。</li>
</ul>
<p>外部碎片：</p>
<ul>
<li>指系统中<strong>无法利用的小的空闲分区</strong>。如<strong>分区与分区之间存在的碎片</strong>。这些不连续的区间就是外部碎片。动态分区管理会产生外部碎片。</li>
<li>外部碎片才是造成内存系统性能下降的主要原因。外部碎片可以被整理后清除。</li>
<li>消除外部碎片的方法：紧凑技术。</li>
</ul>
<h3 id="紧凑技术">紧凑技术</h3>
<p>通过移动作业从把多个分散的小分区拼接成一个大分区的方法称为紧凑（拼接或紧缩）。</p>
<p>目标：消除外部碎片，使本来分散的多个小空闲分区连成一个大的空闲区。</p>
<p>紧凑时机：找不到足够大的空闲分区且<strong>总空闲分区容量可以满足</strong>作业要求时。</p>
<p>技术支撑：<strong>动态重定位</strong>：作业在内存中的位置发生了变化，这就必须对其地址加以修改或变换。</p>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403182205202.png" alt="动态重定位的实现"></p>
<h3 id="多重分区分配">多重分区分配</h3>
<p>多重分区分配：一个作业往往由相对独立的程序段和数据段组成，将这些片断分别装入到存储空间中不同的区域内的分配方式。</p>
<img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403182206926.png" alt="image-20240318220631806" style="zoom:50%;" />
<h3 id="分区的存储保护">分区的存储保护</h3>
<p>存储保护是为了防止一个作业有意或无意地破坏操作系统或其它作业。常用的存储保护方法有</p>
<ul>
<li>界限寄存器方法：
<ul>
<li>上下界寄存器方法</li>
<li>基址、限长寄存器（BR,LR）方法</li>
<li><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403182208204.png" alt="image-20240318220801094"></li>
</ul>
</li>
<li>存储保护键方法：
<ul>
<li>给每个存储块分配一个单独的保护键，它相当于一把锁。进入系统的每个作业也赋予一个保护键，它相当于一把钥匙。</li>
<li>当作业运行时，检查钥匙和锁是否匹配，如果不匹配，则系统发出保护性中断信号，停止作业运行。</li>
</ul>
</li>
</ul>
<h2 id="交换和覆盖">交换和覆盖</h2>
<p>解决大作业在小内存中运行的问题：在运行过程中程序可能需要新的内存空间，原先分配的空间不够，如何继续分配：交换和覆盖</p>
<blockquote>
<p>覆盖技术主要用在早期的OS 中，交换技术则用在现代OS 中。</p>
</blockquote>
<h3 id="覆盖">覆盖</h3>
<p>覆盖：把一个程序划分为一系列功能相对独立的程序段，让执行时不要求同时装入内存的程序段组成一组（称为覆盖段），共享主存的同一个区域，这种内存扩充技术就是覆盖。</p>
<p>程序段先保存在磁盘上，当有关程序段的前一部分执行结束，把后续程序段调入内存，覆盖前面的程序段（内存“扩大”了）。</p>
<p>一般要求作业各模块之间有明确的调用结构，<strong>程序员要向系统指明覆盖结构，然后由操作系统完成自动覆盖</strong>。</p>
<p>缺点：对用户不透明，增加了用户负担。</p>
<h3 id="交换">交换</h3>
<p>交换：把暂时不用的某个（或某些）程序及其数据的部分或全部从主存移到辅存中去，以便腾出必要的存储空间；接着把指定程序或数据从辅存读到相应的主存中，并将控制转给它，让其在系统上运行。</p>
<p>优点：增加并发运行的程序数目，并且给用户提供适当的响应时间；<strong>编写程序时不影响程序结构</strong></p>
<p>缺点：对换入和换出的控制增加处理机开销；程序整个地址空间都进行传送，没有考虑执行过程中<strong>地址访问的统计特性</strong>。</p>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403182211214.png" alt="image-20240318221159076"></p>
<h3 id="交换VS覆盖">交换VS覆盖</h3>
<p>覆盖可<strong>减少一个程序运行所需的空间</strong>。交换可让整个程序暂存于外存中，让出内存空间。</p>
<p>覆盖是<strong>由程序员实现的</strong>，操作系统根据程序员提供的覆盖结构来完成程序段之间的覆盖。交换技术不要求程序员给出程序段之间的覆盖结构。</p>
<p>覆盖技术主要对同一个作业或程序进行。<strong>交换换主要在作业或程序间之间进行</strong>。</p>
<h1>程序、进程和作业</h1>
<h2 id="程序-2">程序</h2>
<p>程序是一个静态对象，是<strong>存储在磁盘中的可执行文件</strong>。</p>
<p>程序本身没有任何意义，也是数据的一部分，只有被执行了程序才能产生意义：<strong>程序是进程的一个实体</strong>。</p>
<p>只要不主动删除，程序会一直留在磁盘中。</p>
<h2 id="进程">进程</h2>
<p>进程是一个行为，是一个程序<strong>对某个数据集的执行过程，是分配资源的基本单位</strong>，是对<strong>执行过程</strong>的一种描述。进程包括程序和程序处理对象（数据集）才能产生意义。</p>
<ul>
<li>系统进程：完成操作系统功能的进程</li>
<li>用户进程：完成用户功能的进程</li>
</ul>
<p>进程是动态的作业过程，对进程的描述可以与计算机的执行过程等价，能够描述并发的状态。</p>
<p>进程具有一定的生命周期：执行完毕后即消失。</p>
<p>一个进程可以执行多个程序，一个程序也可以被多个进程执行，进程可以创建其他进程。</p>
<p>进程的执行需要连续的<strong>逻辑地址</strong>（实际物理地址经过映可以离散）。</p>
<h3 id="程序-行为在并行程序中是怎么存储的">程序/行为在并行程序中是怎么存储的</h3>
<p>程序本身是特定格式的数据，在并行程序中，基本不会涉及对程序的修改（在编译过程中确定），那么并行程序的执行过程就是对共有程序数据的读（无冲突），从共有的程序数据创建多个进程执行。</p>
<p>如果需要涉及对可执行文件的修改，就会引起锁冲突，造成并行各进程的执行内容不同。</p>
<h2 id="作业">作业</h2>
<p>作业是行为逻辑上的一个抽象，是计算机某次作业所需完成的特定对象。一个作业包含程序、数据和操作说明三个部分。</p>
<p>作业需要经过作业提交、作业收容、作业执行和作业完成4个阶段。一个作业至少由一个进程组成。</p>
<p>作业是用户向OS提交的<strong>任务实体</strong>，用户提交后，OS将其<strong>放入一个队列中等待执行</strong>。</p>
<h1>实存管理和虚存管理</h1>
<p>实存管理：</p>
<ul>
<li>分区（Partitioning ）（连续分配方式 ）（包括固定分区、可变分区）</li>
<li>分页（Paging）</li>
<li>分段（Segmentation）</li>
<li>段页式（Segmentation with paging）</li>
</ul>
<p>虚存管理：</p>
<ul>
<li>请求分页（Demand paging）-主流技术</li>
<li>请求分段（Demand segmentation）</li>
<li>请求段页式（Demand SWP）</li>
</ul>
<h1>页式内存管理</h1>
<p>进程需要连续的（虚拟地址）空间，但是这会造成严重的内存浪费，于是试图使用虚拟地址，在物理地址和虚拟地址之间构建一个映射关系，<strong>把逻辑地址连续的程序分散存放在离散的内存区域中</strong>。</p>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403271027740.png" alt="image-20240327102727612"></p>
<h2 id="基本概念">基本概念</h2>
<p>页：在分页存储管理系统中，把每个作业的地址空间分成<strong>一些大小相等的片</strong>，称之为页面（Page）或页，各页从0开始编号。</p>
<p>存储块：在分页存储管理系统中，把<strong>主存的存储空间</strong>也分成与页面相同大小的片，这些片称为<strong>存储块，或称为页框（Frame）</strong>，同样从0开始编号。</p>
<p>页表：为了便于在内存找到进程的每个页面所对应块，分页系统中为每个进程配置一张页表，进程逻辑地址空间中的每一页，在页表中都对应有一个页表项</p>
<p><strong>页表的作用就是在页和存储块之间构建一个映射</strong></p>
<p><strong>每一个进程都有自己的页表，从0开始编址。</strong></p>
<h2 id="纯分页系统">纯分页系统</h2>
<p>纯分页系统：<strong>不支持页面调换</strong>的分页系统。每次需要将程序完整的内容调入内存，优点是构建了映射关系。</p>
<p>纯分页也称为基本分页管理，它<strong>不支持页面对换</strong>。当进程到来时一次性分配进程所需的所有物理内存。有多少页直接分配多少页框，并不是按需装入（相对应的按需装入称作请求分页）。</p>
<p>纯分页也是<strong>可以支持多级页表的</strong>，只不过此时的多级页表<strong>不能动态装入</strong>，所有级别的页表都同时装入内存</p>
<blockquote>
<p>多级页表就是为了动态调入页表，但理论上还是可以实现多级页表的</p>
</blockquote>
<h2 id="页表的数据结构">页表的数据结构</h2>
<p>进程页表：<strong>每个进程有一个页表</strong>，描述该进程占用的物理页面及逻辑排列顺序，虚拟地址从0开始编制。</p>
<ul>
<li>逻辑页号（本进程的地址空间）－&gt;物理页面号（实际内存空间）；</li>
</ul>
<p>物理页面表：<strong>整个系统</strong>有一个物理页面表，描述<strong>物理内存空间的分配使用状况</strong>。</p>
<ul>
<li>数据结构：位示图，空闲页面链表；</li>
</ul>
<p>请求表：整个系统有一个请求表，描述系统内<strong>各个进程页表的位置和大小</strong>，用于地址转换，也可以结合到各进程的PCB里；</p>
<p>页表存放在内存中，访问一个数据需要访问内存两次：页表+数据各一次</p>
<h3 id="哈希页表">哈希页表</h3>
<p>处理超过32位地址空间的常用方法是使用<strong>哈希页表</strong>（hashed page table），并以虚拟页码作为哈希值。</p>
<p>哈希页表的每一个哈希值对应一个条目。使用链表来处理哈希碰撞（哈希值相同）的问题，</p>
<p>每个元素有3个域：</p>
<ol>
<li>虚拟页码</li>
<li>所映射的帧号</li>
<li>指向链表中下一个元素的指针。</li>
</ol>
<p>该算法按照如下方式工作：</p>
<ol>
<li>虚拟地址中的虚拟页号转换为哈希表号，用虚拟页号与链表中的每一个元素的第一个域相比较。</li>
<li>如果匹配，那么相应的帧号（第二个域）就用来形成物理地址；</li>
<li>如果不匹配，那么就对链表中的下一个节点进行比较，以寻找一个匹配的页号。</li>
</ol>
<h3 id="反置页表">反置页表</h3>
<p>反置页表不是依据进程的逻辑页号来组织，而是<strong>依据该进程在内存中的物理页面号</strong>来组织。反置页表按照物理页号排列，其表项的内容是逻辑页号P 及隶属进程标志符pid。</p>
<p>反置页表的大小只与物理内存的大小相关，<strong>与逻辑空间大小和进程数无关</strong>。如: 64M主存,若页面大小为4K,则反向页表只需64KB。</p>
<p><strong>反置页表难以实现共享物理页面</strong>，每个物理帧只对应一个虚拟页条目。</p>
<img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403271054233.png" alt="image-20240327105423076" style="zoom:33%;" />
<p>利用反置页表进行地址变换：</p>
<ol>
<li>用<strong>进程标志符和页号</strong>去检索反置页表。</li>
<li>如果检索完整个页表未找到与之匹配的页表项，表明此页此时尚未调入内存，对于具有请求调页功能的存储器系统产生请求调页中断，若无此功能则表示地址出错。</li>
<li>如果检索到与之匹配的表项，则表项的序号 i 便是该页的物理块号，将该块号与页内地址一起构成物理地址。</li>
</ol>
<h1>段式存储管理</h1>
<p>页是存储信息的物理单位，段是存储信息的逻辑单位。页式存储方式难以实现内存的共享，段式存储是一种更合适的方式。</p>
<p>通常一个作业是由多个程序段和数据段组成的，用户一般按逻辑关系对作业分段，并能根据名字来访问程序段和数据段。段式存储可以更好地根据数据的含义（数据段、程序段）进行共享。</p>
<blockquote>
<p>页式管理中地址空间是一维的，主程序，子程序都顺序排列，共享公用子程序比较困难，一个共享过程可能需要几十个页面。</p>
</blockquote>
<p>段式管理中，可以以信息的逻辑单位进行保护。</p>
<blockquote>
<p>页式管理中，一个页面中可能装有2个不同的子程序段的指令代码，不能通过页面共享实现共享一个逻辑上完整的子程序或数据块。</p>
</blockquote>
<p>动态链接在程序运行时才把主程序和要用到的目标程序（程序段）链接起来。</p>
<h2 id="基本概念-2">基本概念</h2>
<h3 id="段">段</h3>
<p>一个段可定义为一组逻辑信息，每个作业的地址空间是由一些分段构成的（由用户根据逻辑信息的相对完整来划分），每段都有自己的名字（通常是段号），且都是一段连续的地址空间，首地址为 0</p>
<h4 id="段的地址是二维的">段的地址是二维的</h4>
<ul>
<li>页式：一个程序的各页是根据程序空间<strong>连续编址</strong>（逻辑地址）的，程序地址空间只有一维；</li>
<li>段式：一个程序拆分成各段，独立编址（<strong>各段都从零开始编址</strong>），程序地址空间有两维。</li>
</ul>
<p>按照页式获取地址，可以直接获取页号、业内偏移量，进而得到物理地址。</p>
<p>对于段式，必须给出段号，根据段表找出此段的起始地址，再根据段内地址进行定位。</p>
<p><strong>本质是因为不同段的大小不同</strong>，没有一个统一的寻址方式，需要先按照段表找到段的起始地址，再根据段内地址寻找数据。不像页有相同的大小</p>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403220813566.png" alt="不同的段"></p>
<h3 id="段表">段表</h3>
<p>段表记录了段和内存位置的对应关系。段表的基址和长度由<strong>段表寄存器</strong>给出。</p>
<ul>
<li>段表是一个表，每一个表项的大小相同。记录了对应段的地址。</li>
<li>知道了<strong>段表的起始地址</strong>和段号后，可以按照<strong>相对段表起始地址的偏移量</strong>得到段表的表项，进而得到段的地址。</li>
<li>表项：段号+段长SL+基址</li>
</ul>
<p>段表的访存过程可类似于页表，区别就在于获取了<strong>段号和段内地址</strong>后，要按照段的方式进行访问。</p>
<ul>
<li>逻辑地址：段号+段内地址</li>
<li>根据段号和段表的启示地址，得到对应的段表表项，段长和基址</li>
<li>根据段长判断是否越界，未越界则按照基址+段内地址（偏移量）的方式进行访存</li>
</ul>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403271118445.png" alt="image-20240327111800320"></p>
<h2 id="信息共享">信息共享</h2>
<p>可重入代码（Reentrant Code) ：又称为纯代码（Pure Code) 是一种<strong>允许多个进程同时访问的代码</strong>。</p>
<p>为使各个进程所执行的代码完全相同绝对不允许可重入代码在执行中有任何改变。可重入代码是一种<strong>不允许任何进程对其进行修改</strong>的代码 。</p>
<p>优点：分段系统易于实现段的共享，对段的保护也十分简单。</p>
<p>缺点：</p>
<ul>
<li>处理机要为地址变换花费时间；要为表格提供附加的存储空间。</li>
<li>为满足分段的动态增长和减少外零头，要采用拼接手段。</li>
<li>在辅存中管理不定长度的分段困难较多。</li>
<li>分段的最大尺寸受到主存可用空间的限制。</li>
</ul>
<h2 id="段页式存储">段页式存储</h2>
<p>用分段的方式来分配和管理<strong>虚拟存储器</strong>，用分页的方式来分配和管理<strong>实存储器</strong>。</p>
<p>段页式存储管理是分段和分页原理的结合，即先将用户程序分成若干个段（段式），并为每一个段赋一个段名，再把每个段分成若干个页（页式） 。</p>
<ul>
<li>虚拟地址：段号S+段内页号P+业内地址W</li>
</ul>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403271122778.png" alt="image-20240327112250672"></p>
<p>对于段页式系统，需要段表和页表，均存放在内存中，<strong>每个进程都有一张段表，每个段都有一张页表</strong>。</p>
<p><strong>段表含段号、页表始址和页表长度。页表含页号和块号。</strong></p>
<p>访问一次数据需要访问三次内存：段表+页表+数据。</p>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403271126849.png" alt="image-20240327112633719"></p>
<p>地址变换：</p>
<ol>
<li>从PCB 中取出段表始址和段表长度，装入段表寄存器。</li>
<li>将地址的段号与段表长度进行比较，判断是否产生越界中断。</li>
<li>在段表中取出该地址对应的页表始址和页表长度。</li>
<li>将该地址的页号与页表长度进行比较，判断是否产生越界中断。</li>
<li>利用页表始址与页号得到该地址对应的页表项在页表中的位置。</li>
<li>取出该页的物理块号，与页内地址拼接得到实际的物理地址。</li>
</ol>
<h1>虚拟内存管理</h1>
<p>常规存储管理要求一个作业全部装入内存后方能运行，并且作业装入内存后一直驻留内存，直至结束。</p>
<p>可能出现的问题：</p>
<ul>
<li>有的作业很大，所需内存空间大于内存总容量，使作业无法运行。</li>
<li>有大量作业要求运行，但内存容量不足以容纳下所有作业，只能让一部分先运行，其它在外存等待。</li>
</ul>
<p>已有解决方法：</p>
<ul>
<li>增加内存容量：最简单、最有效的办法</li>
<li><strong>从逻辑上扩充内存容量：覆盖、对换。</strong></li>
</ul>
<h2 id="基本介绍">基本介绍</h2>
<p>对于此问题，引入虚拟内存技术。虚拟内存是计算机系统存储管理的一种技术。它为每个进程提供了一个大的、一致的、连续可用的和私有的地址空间（<strong>一个连续完整的地址空间</strong>）。</p>
<p>借鉴覆盖技术：不必把程序的所有内容都放在内存中，因而能够运行比当前的空闲内存空间还要大的程序。</p>
<ul>
<li>与覆盖不同：由操作系统自动完成，<strong>对程序员是透明的</strong>。</li>
</ul>
<p>借鉴交换技术：能够实现进程在内存与外存之间的交换，因而获得更多的空闲内存空间。</p>
<ul>
<li>与交换不同：只将进程的部分内容（<strong>更小的粒度</strong>，如分页）在内存和外存之间进行交换。</li>
</ul>
<h3 id="基本特征">基本特征</h3>
<p>离散性：物理内存分配的不连续，虚拟地址空间使用的不连续（数据段和栈段之间的空闲空间，共享段和动态链接库占用的空间）</p>
<p>多次性：作业被分成多次调入内存运行。<strong>正是由于多次性，虚拟存储器才具备了逻辑上扩大内存的功能</strong>。多次性是虚拟存储器最重要的特征，其它任何存储器不具备这个特征。</p>
<p>对换性：允许在作业运行过程中进行换进、换出。换进、换出可提高内存利用率。</p>
<p>虚拟性：虚拟存储器机制允许程序<strong>从逻辑的角度访问存储器</strong>（访问虚拟地址不知道真实的内存使用情况），而不考虑物理内存上可用的空间数量。</p>
<ul>
<li>范围大，但占用容量不超过物理内存和外存交换区容量之和。</li>
<li>占用容量包括：进程地址空间中的各个段，操作系统代码。</li>
</ul>
<p><strong>虚拟性以多次性和对换性为基础，多次性和对换性必须以离散分配为基础。</strong></p>
<h3 id="和Cache的区别">和Cache的区别</h3>
<p>侧重点不同：Cache 主要解决主存与 CPU 的速度差异问题；<strong>虚存主要解决存储容量问题</strong>，另外还包括存储管理、主存分配和存储保护等。</p>
<p>数据通路不同：CPU 与 Cache 和主存之间均有直接访问通路， Cache 不命中时可直接访问主存；而虚存所依赖的<strong>辅存与 CPU 之间不存在直接的数据通路</strong>，当主存不命中时只能通过调页解决， CPU <strong>最终还是要访问主存</strong>。</p>
<h2 id="请求分页（段）系统">请求分页（段）系统</h2>
<p>在分页/段系统的基础上，增加了<strong>请求调页/段功能</strong>、<strong>页面/段置换功能</strong>所形成的页/段式虚拟存储器系统。</p>
<blockquote>
<p>分页/段只是一种内存管理方式，没有页面调换前还不是虚拟内存管理系统</p>
</blockquote>
<p>允许只装入若干页/段的用户程序和数据，便可启动运行，以后在硬件支持下通过调页 段 功能和置换页/段功能，陆续将要运行的页面/段调入内存，同时把暂不运行的页面/段换到外存上，置换时以页面 段 为单位。</p>
<p>系统须设置相应的硬件支持和软件：</p>
<ul>
<li>硬件支持：请求分页/段的<strong>页/段表机制</strong>、<strong>缺页/段中断机构</strong>和<strong>地址变换机构</strong>。</li>
<li>软件：请求调页/段功能和页/段置换功能的软件。</li>
</ul>
<p>虚存机制要解决的关键问题：</p>
<ol>
<li>地址映射问题：<strong>进程空间</strong>到虚拟存储的映射问题</li>
<li>调入问题：决定哪些程序和数据应被调入主存，以及调入机制。</li>
<li>替换问题：决定哪些程序和数据应被调出主存。</li>
<li>更新问题：确保主存与辅存的一致性。</li>
<li>其它问题：存储保护与程序重定位等问题</li>
</ol>
<h3 id="页表结构">页表结构</h3>
<img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403290917678.png" alt="image-20240329091737506" style="zoom: 67%;" />
<ul>
<li>驻留位：1表示该页位于内存当中，0表示该页当前还在外存当中。</li>
<li>保护位：只读、可写、可执行。</li>
<li>修改位：表明此页在内存中是否被修改过。</li>
<li>访问（统计）位：用于页面置换算法。</li>
</ul>
<img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403301659159.png" alt="image-20240330165933046" style="zoom: 80%;" />
<h2 id="基本概念-3">基本概念</h2>
<p>建立了虚拟内存管理系统以后。</p>
<h3 id="进程空间">进程空间</h3>
<p>一个进程的逻辑空间的建立是通过链接器（Linker），将构成进程所需要的<strong>所有程序及运行所需环境</strong>，按照<strong>某种规则装配链接而形成的一种规范格式</strong>（布局）。</p>
<p>这种格式按字节从 0 开始编址所形成的空间也称为该进程的逻辑地址空间 。其中<strong>OS所使用的空间称为系统空间，其它部分称为用户空间</strong>。系统空间对用户空间不可见。由于该逻辑空间并不是真实存在的，所以也称为进程的虚拟（地址）空间 。</p>
<img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403290836829.png" alt="image-20240329083614552" style="zoom: 50%;" />
<h3 id="虚拟地址空间">虚拟地址空间</h3>
<p>进程的虚拟地址空间/虚拟内存空间即为进<strong>程在内存中存放的逻辑视图</strong>。因此，一个进程的虚拟地址空间的大小与该进程（占用的）的虚拟存储空间的大小相同 。且都从0 开始编址。</p>
<p>含有空白的虚拟地址空间称为稀疏地址空间。</p>
<h3 id="交换分区-文件">交换分区/文件</h3>
<p>在建立分页系统、交换系统后，可以将内存空间交换暂存到磁盘中，存到哪，即交换分区/文件。</p>
<p>是一段<strong>连续的磁盘空间</strong>（按页划分的），并且对用户不可见。它的功能就是在物理内存不够的情况下，操作系统先把内存中暂时不用的数据，存到硬盘的交换空间，腾出物理内存来让别的程序运行。</p>
<p>在Linux 系统中，交换分区为<code>Swap</code>；在 Windows 系统中则以文件的形式存在<code>pagefile.sys</code>。</p>
<p>交换器的大小：交换分区的大小应当与系统物理内存M的大小保持线性比例关系：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>Swap</mtext><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.36em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>2</mn><mo>∗</mo><mi>M</mi><mo separator="true">,</mo><mspace width="1em"/><mi>M</mi><mo>&lt;</mo><mn>2</mn><mi>G</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>M</mi><mo>+</mo><mn>2</mn><mo separator="true">,</mo><mspace width="1em"/><mtext>else</mtext></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\text{Swap} = 
	\begin{cases}
	2*M ,\quad M&lt;2G \\
	M+2 ,\quad \text{else}
	\end{cases}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord text"><span class="mord">Swap</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3em;vertical-align:-1.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mpunct">,</span><span class="mspace" style="margin-right:1em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">2</span><span class="mord mathnormal">G</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:1em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord text"><span class="mord">else</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>采用分段函数而不是连续函数：<strong>系统中的物理内存越大，对于内存的负荷可能也越大</strong>。</p>
<h3 id="地址映射">地址映射</h3>
<p>进程空间到虚拟空间的映射：进程的虚存分配</p>
<p>分配是以段为单位的，需要进行页对齐</p>
<p>事实上，在每个进程创建加载时，内核只是<strong>为进程“创建”了虚拟内存的布局</strong>，实际上并不立即就把虚拟内存对应位置的程序数据和代码（比如<code>.text</code> ，<code>.data</code>段）拷贝到物理内存中，只是<strong>建立好虚拟内存和磁盘文件之间的映射</strong>（叫做存储器映射），等到运行到对应的程序时，才会通过缺页异常，来拷贝数据。</p>
<ul>
<li>用户可执行文件（如<code>Hello World</code>可执行文件）及共享库（如<code>HelloWorld</code>中调用的库文件中的<code>printf</code>函数）都是以文件的形式存储在磁盘中，初始时其在页表中的类型为<code>file backed</code>，地址为相应文件的位置。</li>
<li>堆heap和栈 stack在磁盘上没有对应的文件 ，页表中的类型为<code>anonymous</code>，地址为空。</li>
<li>未分配部分没有对应的页表项，只有在申请时（如使用<code>malloc()</code>申请内存或用<code>mmap()</code>将文件映射到用户空间）才建立相应的页表项。</li>
</ul>
<h2 id="页面的基本操作">页面的基本操作</h2>
<h3 id="页面调入">页面调入</h3>
<p>什么程序和数据调入主存：</p>
<ul>
<li>OS的核心部分的程序和数据；</li>
<li>正在运行的用户进程相关的程序及数据。</li>
</ul>
<p>何时调入：</p>
<ul>
<li>OS在系统启动时调入。</li>
<li>用户程序的调入取决于调入策略。常用的调度策略有：
<ul>
<li>预调页 ：事先调入页面的策略。</li>
<li>按需调页 ：仅当需要时才调入页面的策略。</li>
</ul>
</li>
</ul>
<p>如何调入：缺页错误处理机制。</p>
<h4 id="预调页">预调页</h4>
<p>当进程开始时，所有页都在磁盘上，<strong>每个页都需要通过页错误来调入内存</strong>。预调页同时将所需要的所有页一起调入内存，从而阻止了大量的页错误。</p>
<p>实际应用中，可以<strong>为每个进程维护一个当前工作集合中的页的列表</strong>，如果进程在暂停之后需要重启时，根据这个列表使用预调页将所有工作集合中的页一次性调入内存。</p>
<p>预调页有时效果比较好，但成本不一定小于不使用预调页时发生页错误的成本，有很多预调页调入内存的页可能没有被使用。</p>
<h4 id="按需调页">按需调页</h4>
<p>当且仅当需要某页时才将该页调入内存的技术称为按需调页（ demand paging ），被虚拟内存系统采用。</p>
<p><strong>按需调页系统类似于使用交换的分页系统</strong>，进程驻留在二级存储器上（磁盘），进程执行时使用 懒惰交换（lazy swapper）换入内存。</p>
<p>按需调页需要使用备份存储，保存不在内存中的页。通常为快速磁盘，用于和内存交换页的部分空间称为交换空间。</p>
<h3 id="缺页错误">缺页错误</h3>
<p>当进程执行过程中需访问的页面不在物理内存中时，会引发发生缺页中断，进行所需页面换入，步骤如下：</p>
<ol>
<li>
<p>现场保护：<strong>陷入内核态</strong>，保存必要的信息（OS 及用户进程状态相关的信息）。</p>
</li>
<li>
<p>页面定位：查找出来发生页面中断的<strong>虚拟页面</strong>（位于进程地址空间中）。</p>
<ul>
<li>产生缺页中断的虚拟页面的信息通常会保存在一个硬件寄存器中。</li>
<li>如果没有的话，操作系统<strong>必须检索程序计数器</strong>，取出这条指令，通过软件分析找出发生页面中断的虚拟页面。</li>
</ul>
</li>
<li>
<p>权限检查：检查虚拟地址的有效性及安全保护位。如果发生保护错误，则<strong>杀死该进程</strong>。</p>
</li>
<li>
<p>新页面调入：查找内存中一个空闲的页框。如果没有空闲页框，则需要通过<strong>页面置换算法</strong>将一个页面换出内存以腾出位置。</p>
</li>
<li>
<p>旧页面写回：如果决定替换的页框中的内容被修改了，则需要将修改的内容保存到磁盘上。</p>
<p><strong>此时需要将页框置为忙状态，以防页框被其它进程抢占掉</strong></p>
</li>
<li>
<p>新页面调入：页框处理完毕后，操作系统将原先存储在磁盘上、对应的页面内容复制到该页框中。</p>
</li>
<li>
<p>更新页表：当磁盘中的页面内容全部装入页框后，向操作系统发送一个<strong>中断</strong>：操作系统<strong>更新内存中的页表项</strong>，将虚拟页面映射的页框号更新为写入的页框，并将页框标记为正常状态。</p>
</li>
<li>
<p>恢复现场：恢复缺页中断发生前的状态，<strong>将程序指针重新指向引起缺页中断的指令</strong>。</p>
</li>
<li>
<p>继续执行：程序重新执行引发缺页中断的指令，进行存储访问。</p>
</li>
</ol>
<p>其中5、6会引发一个<strong>写磁盘调用</strong>，发起<strong>上下文切换</strong>：在<strong>等待磁盘写的过程</strong>会让其他<strong>进程</strong>先运行</p>
<h3 id="页面替换">页面替换</h3>
<p>怎么选择对系统造成最小代价的页面进行替换？</p>
<h4 id="最优置换OPT">最优置换OPT</h4>
<p>从主存中移出<strong>永远不再需要的页面</strong>，如无这样的页面存在，则应选择<strong>未来最长时间不需要访问</strong>的页面。</p>
<p>但是从表述也可以看出，前半句话对应的情况是先验的难以预测的，往往会使用后半种情况。</p>
<p>它会将内存中的页P置换掉，页 P满足：从现在开始到未来某刻再次需要页 P，这段时间最长。也就是OPT算法会 置换掉<strong>未来最久不被使用的页</strong> 。</p>
<h4 id="先进先出算法FIFO">先进先出算法FIFO</h4>
<p>总选择作业中在主<strong>存驻留时间最长</strong>的一页淘汰。</p>
<p>维护一个队列，记录页面的进入顺序，移出最早进入队列的页面。</p>
<ul>
<li>新访问的页面插入FIFO 队列尾部，页面在 FIFO 队列中顺序移动</li>
<li>淘汰FIFO 队列头部的页面</li>
</ul>
<h5 id="改进的FIFO算法：Second-Chance">改进的FIFO算法：Second Chance</h5>
<p>每个页面会增加<strong>一个访问标志位</strong>，用于标识此数据放入缓存队列后是否被再次访问过。</p>
<p>A是 FIFO 队列中最旧的页面，且其放入队列后没有被再次访问，则 A被立刻淘汰；否则如果放入队列后被访问过，则将 A 移到 FIFO 队列头，并且将访问标志位清除。</p>
<blockquote>
<p>将页面提前的机会只有在页面来到队尾时才有。</p>
<p>并不是访问就将页面提到队首。</p>
</blockquote>
<p>如果所有的页面都被访问过，则经过一次循环后就会按照FIFO 的原则淘汰。</p>
<h5 id="改进的FIFO算法：Clock">改进的FIFO算法：Clock</h5>
<p>维护一个环形队列进行判断。</p>
<ul>
<li>如果没有缺页错误，将相应的页面<strong>访问位</strong>置1 ，指针不动</li>
<li>如果指针指向页面的访问位位是0就淘汰，并且把新页面插入到这个位置，然后把表针前移一个位置；</li>
<li>如果是1，则清除R位并把指针前移直到找到了一个R位为0的页面。</li>
</ul>
<img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403301907100.png" alt="image-20240330190734999" style="zoom: 80%;" />
<h4 id="最近最久不算法LRU">最近最久不算法LRU</h4>
<p>当需要置换一页面时，选择在最近一段时间内最久不用的页面予以淘汰。</p>
<ul>
<li>设置一个特殊的栈，保存当前使用的各个页面的页面号。</li>
<li>每当进程访问某页面时，便将该页面的页面号从栈中移出，将它压入栈顶。栈底始终是最近最久未使用页面的页面号。</li>
</ul>
<h5 id="老化算法">老化算法</h5>
<p>用硬件支持LRU的花销太大，进行一定减法，使用移位寄存器来实现计数的功能。</p>
<ul>
<li>为<strong>每个页面设置一个移位寄存器</strong>，每个时钟周期向右移位一次。</li>
<li>如果当前周期访问了该页面，则将寄存器最左位设置为1</li>
</ul>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403301913192.png" alt="image-20240330191314005"></p>
<h2 id="Page-Cache与一致性">Page Cache与一致性</h2>
<p>什么是Page Cache，怎么保持一致性。</p>
<h3 id="基本概念-4">基本概念</h3>
<p>page 是<strong>内存管理分配的基本单位</strong>， Page Cache 由多个 page 构成。</p>
<p>page 在操作系统中通常为 4KB 大小（32bits/64bits），而 Page Cache 的大小则为 4KB 的整数倍。</p>
<p>Page Cache 的本质是由 Linux 内核管理的内存区域。通过 mmap 以及 buffered I/O 将文件<strong>读取到内存空间实际上都是读取到 Page Cache 中</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Page Cache = Buffers + Cached + SwapCached</span><br></pre></td></tr></table></figure>
<img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403301927385.jpeg" alt="img" style="zoom: 50%;" />
<p>Linux 系统上<strong>供用户可访问的内存</strong>分为两个类型，即：</p>
<ul>
<li>File-backed pages：文件备份页。是<strong>存储在 Page Cache 中的 page</strong>，<strong>对应于磁盘上的若干数据块</strong>；对于这些页最大的问题是脏页回盘；
<ul>
<li>有相应的备份存储在磁盘种，不需要担心完全丢失</li>
</ul>
</li>
<li>Anonymous pages：匿名页<strong>不对应磁盘上的任何磁盘数据块</strong>，它们是进程的运行是内存空间（例如方法栈、局部变量表等属性）；
<ul>
<li>这部分物理页面由于<strong>没有对应外部存储介质上的文件</strong>。</li>
<li>在建立的时候只有虚按需分配拟地址，当它们真正被访问到的时候，内核才会为其分配物理页面。</li>
<li>Anonymous pages同page cache一样，也是可以被回收的，但由于没有对应的后备文件，因此在回收anonymous pages的时候，不能像可读写的page cache（比如data段）一样flush同步后discard，而是<strong>需要保存这些anonymous pages的内容</strong>，这样才能在以后再次访问这些页面的时候，获得它们被回收前所包含的数据。</li>
<li>为此，<strong>磁盘上</strong>会开辟专门的swap space保存这些页面。swap space由若干的swap areas组成，swap area的最大数目由&quot;MAX_SWAPFILES&quot;确定。</li>
</ul>
</li>
</ul>
<h3 id="主辅存一致性：更新问题">主辅存一致性：更新问题</h3>
<p>在虚存系统中，主存作为辅存（磁盘）的高速缓存，保存了磁盘信息的副本。因此，当一个页面被换出时，为了保持主辅存信息的一致性，必要时需要信息更新：</p>
<ul>
<li>如果页面有相应的磁盘备份，即file backed类型
<ul>
<li>若未被修改，则直接丢弃，因为磁盘上保存有相同的副本。</li>
<li>若已被修改，则直接写回原有位置。</li>
</ul>
</li>
<li>如果页面没有相应的磁盘备份，即anonymous类型
<ul>
<li>若是第一次换出且未被修改，则写入 Swap 区，若非第一次则丢弃。</li>
<li>若且已被修改，则写入Swap 区。</li>
</ul>
</li>
</ul>
<h2 id="多进程下的虚拟内存管理">多进程下的虚拟内存管理</h2>
<h3 id="基本概念-5">基本概念</h3>
<p>基本定义：</p>
<ul>
<li>工作集：当前<strong>正在使用的页面</strong>的集合，可能位于磁盘中。</li>
<li>驻留集：虚拟存储系统中每个进程<strong>驻留在内存的页面</strong>集合，或进程分到的<strong>物理页框集合</strong>。</li>
</ul>
<h4 id="工作集">工作集</h4>
<p>引入工作集的目的：依据进程在<strong>过去的一段时间内访问的页面</strong>来<strong>调整驻留集大小</strong>。</p>
<p>工作集的定义：工作集是一个进程执行过程中所访问页面的集合，可用一个二元函数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi><mo stretchy="false">(</mo><mi>t</mi><mo separator="true">,</mo><mi mathvariant="normal">Δ</mi><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">W(t,\Delta t)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">Δ</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span>表示</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span>是执行时刻</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Δ</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">\Delta t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Δ</span><span class="mord mathnormal">t</span></span></span></span>是窗口尺寸</li>
<li>工作集是在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>t</mi><mo>−</mo><mi mathvariant="normal">Δ</mi><mi>t</mi><mo separator="true">,</mo><mi>t</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[t-\Delta t,t]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Δ</span><span class="mord mathnormal">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">t</span><span class="mclose">]</span></span></span></span>时间段内所访问的页面的集合</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>W</mi><mo stretchy="false">(</mo><mi>t</mi><mo separator="true">,</mo><mi mathvariant="normal">Δ</mi><mi>t</mi><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|W(t,\Delta t)|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">Δ</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mord">∣</span></span></span></span>指工作集大小，即<strong>页面数目</strong>；</li>
</ul>
<p>工作集大小的变化：</p>
<ul>
<li>进程开始执行后，随着访问新页面逐步建立较稳定的工作集。</li>
<li>当内存访问的局部性区域的位置大致稳定时，工作集大小也大致稳定；</li>
<li>局部性区域的位置改变时，工作集<strong>快速扩张和收缩过渡到下一个稳定值</strong>。</li>
</ul>
<h4 id="驻留集">驻留集</h4>
<p>进程驻留集管理主要解决的问题是，<strong>系统应当为每个活跃进程分配多少个页框</strong>。</p>
<p>影响页框分配的主要因素：</p>
<ul>
<li>分配给每个活跃进程的页框数越少，同时驻留内存的活跃进程数就越多，进程调度程序能调度就绪进程的概率就越大。</li>
<li>然而，这将导致进程发生缺页中断的概率较大；<strong>为进程分配过多的页框，并不能显著地降低其缺页中断率</strong>。</li>
</ul>
<h3 id="页面分配政策">页面分配政策</h3>
<ul>
<li>固定分配政策：为每个活跃进程分配固定数量的页框。即每个进程的驻留集尺寸在运行期间固定不变。</li>
<li>可变分配政策：为每个活跃进程分配的页框数在其生命周期内是可变的。
<ul>
<li>即系统首先给进程分配一定数量的页框，运行期间可以增减页框。系统可以根据进程的缺页率调整进程的驻留集。</li>
<li>当进程的<strong>缺页率很高时，驻留集太小</strong>，需要增加页框；</li>
<li>当缺页率一段时间内都保持很低时，可以在<strong>不会明显增加进程缺页率的前提下</strong>，回收其一部分页框，减小进程的驻留集。</li>
</ul>
</li>
</ul>
<p>可变分配策略比固定分配策略更灵活，既可以提高系统的吞吐量，又能保证内存的有效利用。</p>
<p>可变分配要求统计进程的缺页率，增加系统额外开销。而准确<strong>判断进程缺页率的高低</strong>，确定缺页率的阈值是<strong>非常困难</strong>的。可变分配策略不仅需要操作<strong>系统软件专门的支持</strong>，而且，还需要<strong>处理机平台提供的硬件支持</strong>。</p>
<h3 id="内存块初始分配方法">内存块初始分配方法</h3>
<ol>
<li>等分法：为每个进程分配存储块的最简单的办法是平分，即若有m块、n个进程，则每个进程分<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>m</mi><mi mathvariant="normal">/</mi><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[m/n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">m</span><span class="mord">/</span><span class="mord mathnormal">n</span><span class="mclose">]</span></span></span></span>块。</li>
<li>比例法：分给进程的块数进程地址空间大小 /全部进程的总地址空间 * 可用块总数</li>
<li>优先权法：为加速高优先级进程的执行，可以给高优先级进程分较多内存。如使用比例分配法时，分给进程的块数不仅取决于程序的相对大小而且也取决于优先级的高低。</li>
</ol>
<h3 id="页面置换策略">页面置换策略</h3>
<p>当发生缺页中断且无足够的内存空间时，需要置换已有的某些（个）页面。应该解决的基本问题：</p>
<ol>
<li>当系统欲把一个页面装入内存时，应当在什么范围内判断已经没有空闲页框供分配？</li>
<li>当指定的范围内没有空闲页框时，应当从哪里选择哪个页面移出内存？</li>
</ol>
<p>局部置换：系统在进程<strong>自身的驻留集中</strong>判断当前是否存在空闲页框，并在其中进行置换。</p>
<p>全局置换策略：在<strong>整个内存空间内</strong>判断有无空闲页框，并允许从<strong>其它进程的驻留集</strong>中选择一个页面换出内存。</p>
<h3 id="分配模式与置换模式的搭配">分配模式与置换模式的搭配</h3>
<img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403301948155.png" alt="image-20240330194804932" style="zoom:67%;" />
<p>全局置换算法：存在的一个问题是，<strong>程序无法控制自己的缺页率</strong>。一个进程在内存中的一组页面不仅取决于该进程的页面走向，而且也取决于其他进程的页面走向。因此，相同程序由于外界环境不同会造成执行上的很大差别。</p>
<p>使用局部置换算法就不会出现这种情况，<strong>一个进程在内存中的页面仅受本进程页面走向的影响</strong>。</p>
<ul>
<li>仅在自身的驻留集中选择页面进行替换</li>
</ul>
<p>可变分配策略+局部置换策略：可增加或减少分配给每个活跃进程的页框数；当进程的页框全部用完，而需要装入一个新的页面时，系统将在该进程的当前驻留集中选择一个页面换出内存。</p>
<h3 id="页面清除策略">页面清除策略</h3>
<p>页面清除策略需要决定系统<strong>何时把被置换页面写回外存</strong>。</p>
<p>若被选中的置换页面被修改过，则需要将该页面内容<strong>写回外存，然后装入新页内容</strong>。</p>
<p>一种有效的页面清除策略是结合页缓冲（Page Buffering ）技术。当发生缺页中断时，不必首先写出置换页，而是将被选中的置换页暂时保留在内存的一个缓冲区，在以后某个合适的时候<strong>将这些被置换页批量写出到外存</strong>。<strong>减少磁盘 I/O 的次数，提高处理机的效率。</strong></p>
<h3 id="负载与负载控制">负载与负载控制</h3>
<p>抖动问题：随着驻留内存的进程数目增加，或者说进程并发水平的上升，处理器利用率先是上升，然后下降。这里处理器利用率下降的原因通常称为虚拟存储器发生“抖动”。</p>
<p>也就是：<strong>每个进程的驻留集不断减小，当驻留集小于工作集后</strong>，缺页率急剧上升，频繁调页使得调页开销增大。 OS 要选择一个适当的进程数目，以在并发水平和缺页率之间达到一个平衡 。</p>
<p><strong>抖动消除与预防</strong>：</p>
<ul>
<li>局部置换策略：如果一个进程出现抖动，它不能从另外的进程那里夺取内存块，从而不会引发其他进程出现抖动，使抖动局限于一个小的范围内。 然而这种方法并未消除抖动的发生。（微观层面）</li>
<li>引入工作集算法（微观）</li>
<li>预留部分页面（微观或宏观）</li>
<li>挂起若干进程：当出现CPU 利用率、而磁盘 I/O 非常频繁的情况时，就可能因为多道程序度太高而造成抖动。为此，可<strong>挂起一个或几个进程</strong>，以便 腾出内存空间供抖动进程使用，从而消除抖动现象 。（宏观）</li>
</ul>
<h4 id="负载控制">负载控制</h4>
<p>多道程序系统允许多个进程同时驻留内存，以提高系统吞吐量和资源利用率。然而，如果<strong>同时驻留的进程数量太多，每个进程都竞争各自需要的资源，反而会降低系统效率</strong>。</p>
<ul>
<li>如果内存中进程太多，将导致<strong>每个进程的驻留集太小，发生缺页中断的概率很大</strong>，系统发生抖动的可能性就会很大。</li>
<li>如果内存中保持太少的活动进程，那么所有活动进程<strong>同时处于阻塞状态的可能性就会很大</strong>，从而降低处理机的利用率。</li>
</ul>
<p>负载控制主要解决系统<strong>应当保持多少个活动进程驻留在内存</strong>的问题，即控制多道程序系统的度。</p>
<ul>
<li>当内存中的活动进程数太少时，负载控制将增加新进程或激活一些挂起进程进入内存；</li>
<li>当内存中的进程数太多时，负载控制将暂时挂起一些进程，减少内存中的活动进程数。</li>
</ul>
<h4 id="可挂起的进程">可挂起的进程</h4>
<ul>
<li>优先级最低的进程；</li>
<li>缺页进程：因为发生缺页中断的进程<strong>处于阻塞状态</strong>，暂时<strong>不需要竞争处理机的使用权</strong>。而且，挂起一个缺页进程时，挂起和激活操作需要的数据交换将消除页替换的开销；</li>
<li>最后一个被激活的进程：因为<strong>为此类进程装入的页面较少</strong>，将其挂起的开销较小；</li>
<li>驻留集最小的进程：将该类进程挂起以后，<strong>激活所需的开销较小</strong>；</li>
<li>最大的进程：<strong>挂起最大的进程将获得最多的内存空间</strong>，可以满足内存中的进程申请空闲页框的需要，使它们能尽快执行完成。</li>
</ul>
<h2 id="写时复制技术">写时复制技术</h2>
<p>对于复制的内容，如果不进行修改，则共享一个指针（一个内容）。只有<strong>当一个进程想要修改时，才进行真正的复制。</strong></p>
<p>资源的复制只有在需要写入的时候才进行。</p>
<ul>
<li>两个进程<strong>共享同一块物理内存</strong>，每个页面都被标志成了写时复制 。共享的物理内存中每个页面都是只读的。</li>
<li>如果某个进程想改变某个页面时，就会与只读标记冲突，而系统在检测出页面是写时复制的，则会在内存中复制一个页面，然后进行写操作。</li>
<li>新复制的页面对执行写操作的进程是私有的，对其他共享写时复制页面的进程是不可见的。</li>
</ul>
<h2 id="存储保护">存储保护</h2>
<ul>
<li>
<p>界限保护（上下界界限地址寄存器）：所有访问地址必须在上下界之间；</p>
</li>
<li>
<p>用户态与内核态</p>
</li>
<li>
<p>存取控制检查</p>
</li>
<li>
<p>环保护：处理器状态分为多个环( ring)，<strong>分别具有不同的存储访问特权级别</strong> ( privilege)，通常是级别高的在内环，编号小（如 0 环）级别最高；可访问同环或更低级别环的数据；可调用同环或更高级别环的服务。</p>
<img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403302014252.png" alt="image-20240330201440073" style="zoom: 33%;" />
</li>
</ul>
<h1>页表自映射</h1>
<p>自映射：页表占据的存储空间多后，也需要使用页表来进行管理。</p>
<p>页表建立了虚拟空间和物理空间的地址映射关系：</p>
<ul>
<li>
<p>对于32位系统，采用12位页内偏移量，则每个页大小为4KB，共1M页</p>
</li>
<li>
<p>假设每个页表项大小为4B，则需要4MB的空间存放页表项，需要1K个页面</p>
</li>
<li>
<p>记页表项为PDE</p>
<img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403302047125.png" alt="image-20240330204705918" style="zoom:50%;" />
</li>
</ul>
<p>页表自映射：<strong>页表也需要有也来存储，一定有页的地址指向自身</strong>。使其为<strong>页目录基地址</strong></p>
<ul>
<li>
<p><strong>页表基址</strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext>PT</mtext><mrow><mi>b</mi><mi>a</mi><mi>s</mi><mi>e</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\text{PT}_{base}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord text"><span class="mord">PT</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ba</span><span class="mord mathnormal mtight">se</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，需要4M对齐：业内偏移量12+1K个页表项</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mtext>PT</mtext><mrow><mi>b</mi><mi>a</mi><mi>s</mi><mi>e</mi></mrow></msub><mo>=</mo><mo stretchy="false">(</mo><msub><mtext>PT</mtext><mrow><mi>b</mi><mi>a</mi><mi>s</mi><mi>e</mi></mrow></msub><mo>&gt;</mo><mo>&gt;</mo><mn>22</mn><mo stretchy="false">)</mo><mo>&lt;</mo><mo>&lt;</mo><mn>22</mn></mrow><annotation encoding="application/x-tex">\text{PT}_{base} = (\text{PT}_{base}&gt;&gt;22)&lt;&lt;22
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord text"><span class="mord">PT</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ba</span><span class="mord mathnormal mtight">se</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord text"><span class="mord">PT</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ba</span><span class="mord mathnormal mtight">se</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">22</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">22</span></span></span></span></span></p>
</li>
<li>
<p><strong>页目录基地址</strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext>PD</mtext><mrow><mi>b</mi><mi>a</mi><mi>s</mi><mi>e</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\text{PD}_{base}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord text"><span class="mord">PD</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ba</span><span class="mord mathnormal mtight">se</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mtext>PD</mtext><mrow><mi>b</mi><mi>a</mi><mi>s</mi><mi>e</mi></mrow></msub><mo>=</mo><msub><mtext>PT</mtext><mrow><mi>b</mi><mi>a</mi><mi>s</mi><mi>e</mi></mrow></msub><mi mathvariant="normal">∣</mi><mo stretchy="false">(</mo><msub><mtext>PT</mtext><mrow><mi>b</mi><mi>a</mi><mi>s</mi><mi>e</mi></mrow></msub><mo>&gt;</mo><mo>&gt;</mo><mn>10</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\text{PD}_{base}=\text{PT}_{base} | (\text{PT}_{base}&gt;&gt;10)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord text"><span class="mord">PD</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ba</span><span class="mord mathnormal mtight">se</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord text"><span class="mord">PT</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ba</span><span class="mord mathnormal mtight">se</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mopen">(</span><span class="mord"><span class="mord text"><span class="mord">PT</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ba</span><span class="mord mathnormal mtight">se</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">10</span><span class="mclose">)</span></span></span></span></span></p>
</li>
<li>
<p><strong>自映射目录表项</strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext>PDE</mtext><mrow><mi>s</mi><mi>e</mi><mi>l</mi><mi>f</mi><mi mathvariant="normal">_</mi><mi>m</mi><mi>a</mi><mi>p</mi><mi>p</mi><mi>i</mi><mi>n</mi><mi>g</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\text{PDE}_{self\_mapping}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0503em;vertical-align:-0.367em;"></span><span class="mord"><span class="mord text"><span class="mord">PDE</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">se</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mord mtight" style="margin-right:0.02778em;">_</span><span class="mord mathnormal mtight">ma</span><span class="mord mathnormal mtight">pp</span><span class="mord mathnormal mtight">in</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.367em;"><span></span></span></span></span></span></span></span></span></span></p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mtext>PDE</mtext><mrow><mi>s</mi><mi>e</mi><mi>l</mi><mi>f</mi><mi mathvariant="normal">_</mi><mi>m</mi><mi>a</mi><mi>p</mi><mi>p</mi><mi>i</mi><mi>n</mi><mi>g</mi></mrow></msub><mo>=</mo><msub><mtext>PT</mtext><mrow><mi>b</mi><mi>a</mi><mi>s</mi><mi>e</mi></mrow></msub><mi mathvariant="normal">∣</mi><mo stretchy="false">(</mo><msub><mtext>PT</mtext><mrow><mi>b</mi><mi>a</mi><mi>s</mi><mi>e</mi></mrow></msub><mo>&gt;</mo><mo>&gt;</mo><mn>10</mn><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi><mo stretchy="false">(</mo><msub><mtext>PT</mtext><mrow><mi>b</mi><mi>a</mi><mi>s</mi><mi>e</mi></mrow></msub><mo>&gt;</mo><mo>&gt;</mo><mn>20</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\text{PDE}_{self\_mapping} = \text{PT}_{base}|(\text{PT}_{base}&gt;&gt;10)|(\text{PT}_{base}&gt;&gt;20)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0503em;vertical-align:-0.367em;"></span><span class="mord"><span class="mord text"><span class="mord">PDE</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">se</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mord mtight" style="margin-right:0.02778em;">_</span><span class="mord mathnormal mtight">ma</span><span class="mord mathnormal mtight">pp</span><span class="mord mathnormal mtight">in</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.367em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord text"><span class="mord">PT</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ba</span><span class="mord mathnormal mtight">se</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mopen">(</span><span class="mord"><span class="mord text"><span class="mord">PT</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ba</span><span class="mord mathnormal mtight">se</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">10</span><span class="mclose">)</span><span class="mord">∣</span><span class="mopen">(</span><span class="mord"><span class="mord text"><span class="mord">PT</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ba</span><span class="mord mathnormal mtight">se</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">20</span><span class="mclose">)</span></span></span></span></span></p>
</li>
</ul>
<p>只要给定4M 对齐的页表基址（虚拟地址），就可以得到所有页表项对应的地址，也就包括页目录表基址和自映射页目录项在页目录表中的位置。因此<strong>页目录表基址和自映射页目录项在虚空间中是计算出来的</strong>。</p>
<p>页表主要供OS 使用的，因此页表和页目录表通常放置在 OS 空间中（如 Win 的高 2G 空间）；</p>
<p>“页目录自映射”的含义是<strong>页目录包含在页表当中</strong>，是采用的映射（或组织）方法的一个特征， 是<strong>虚拟地址空间内的映射，与虚拟地址到物理地址的映射无关</strong>。</p>
<p>支持“页目录自映射”可节省4K （虚拟地址）空间</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://pigkillermaster.github.io">pigKiller</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://pigkillermaster.github.io/2024/03/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%90%86%E8%AE%BA-%E5%86%85%E5%AD%98/">https://pigkillermaster.github.io/2024/03/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%90%86%E8%AE%BA-%E5%86%85%E5%AD%98/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://pigkillermaster.github.io" target="_blank">浮泛之舟</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/OS%E7%90%86%E8%AE%BA/">OS理论</a></div><div class="post_share"><div class="social-share" data-image="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403252018445.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/03/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%90%86%E8%AE%BA-%E5%90%AF%E5%8A%A8/" title="操作系统-理论-启动"><img class="cover" src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403252018445.png" onerror="onerror=null;src='https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202309212200810.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">操作系统-理论-启动</div></div></a></div><div class="next-post pull-right"><a href="/2024/04/02/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-Unit1-%E9%80%92%E5%BD%92%E4%B8%8B%E9%99%8D/" title="面向对象-Unit1-递归下降"><img class="cover" src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202404022351911.png" onerror="onerror=null;src='https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202309212200810.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">面向对象-Unit1-递归下降</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/05/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%90%86%E8%AE%BA-IO%E7%AE%A1%E7%90%86/" title="操作系统-理论-IO管理"><img class="cover" src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403252018445.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-10</div><div class="title">操作系统-理论-IO管理</div></div></a></div><div><a href="/2024/03/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%90%86%E8%AE%BA-%E5%90%AF%E5%8A%A8/" title="操作系统-理论-启动"><img class="cover" src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403252018445.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-25</div><div class="title">操作系统-理论-启动</div></div></a></div><div><a href="/2024/03/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%90%86%E8%AE%BA-%E5%BC%95%E8%AE%BA/" title="操作系统-理论-引论"><img class="cover" src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403252018445.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-25</div><div class="title">操作系统-理论-引论</div></div></a></div><div><a href="/2024/05/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%90%86%E8%AE%BA-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/" title="操作系统-理论-进程和线程"><img class="cover" src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403252018445.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-10</div><div class="title">操作系统-理论-进程和线程</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">存储</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E7%BB%84%E7%BB%87"><span class="toc-number">1.1.</span> <span class="toc-text">存储组织</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="toc-number">1.2.</span> <span class="toc-text">存储管理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">编译、链接、装入</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#gcc%E7%9A%84%E5%B7%A5%E4%BD%9C"><span class="toc-number">2.1.</span> <span class="toc-text">gcc的工作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6"><span class="toc-number">2.2.</span> <span class="toc-text">可执行文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E5%88%92%E5%88%86"><span class="toc-number">2.2.1.</span> <span class="toc-text">具体划分</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E5%AE%9A%E4%BD%8D"><span class="toc-number">2.3.</span> <span class="toc-text">重定位</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F"><span class="toc-number">2.4.</span> <span class="toc-text">程序</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">存储管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%88%86%E9%85%8D"><span class="toc-number">3.1.</span> <span class="toc-text">存储分配</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E9%81%93%E7%A8%8B%E5%BA%8F"><span class="toc-number">3.1.1.</span> <span class="toc-text">单道程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F"><span class="toc-number">3.1.2.</span> <span class="toc-text">多道程序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%8C%BA%E6%96%B9%E5%BC%8F"><span class="toc-number">3.1.2.1.</span> <span class="toc-text">分区方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%BA%E5%AE%9A%E5%BC%8F%E5%88%86%E5%8C%BA"><span class="toc-number">3.1.2.1.1.</span> <span class="toc-text">固定式分区</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%BC%8F%E5%88%86%E5%8C%BA"><span class="toc-number">3.1.2.1.2.</span> <span class="toc-text">可变式分区</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%B2%E7%BD%AE%E7%A9%BA%E9%97%B4%E7%9A%84%E7%AE%A1%E7%90%86"><span class="toc-number">3.2.</span> <span class="toc-text">闲置空间的管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%88%86%E5%8C%BA%E7%9A%84%E7%AE%A1%E7%90%86"><span class="toc-number">3.2.1.</span> <span class="toc-text">可变分区的管理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98"><span class="toc-number">3.3.</span> <span class="toc-text">分配内存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E9%A1%BA%E5%BA%8F%E6%90%9C%E7%B4%A2%E7%9A%84%E5%88%86%E9%85%8D%E6%96%B9%E6%B3%95"><span class="toc-number">3.3.1.</span> <span class="toc-text">基于顺序搜索的分配方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E7%B4%A2%E5%BC%95%E6%90%9C%E7%B4%A2%E7%9A%84%E5%88%86%E9%85%8D%E6%96%B9%E6%B3%95"><span class="toc-number">3.3.2.</span> <span class="toc-text">基于索引搜索的分配方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95"><span class="toc-number">3.3.2.1.</span> <span class="toc-text">快速适应算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%99%E4%BC%B4%E7%B3%BB%E7%BB%9F"><span class="toc-number">3.3.2.2.</span> <span class="toc-text">伙伴系统</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E7%A2%8E%E7%89%87"><span class="toc-number">3.4.</span> <span class="toc-text">系统中的碎片</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A7%E5%87%91%E6%8A%80%E6%9C%AF"><span class="toc-number">3.4.1.</span> <span class="toc-text">紧凑技术</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D"><span class="toc-number">3.4.2.</span> <span class="toc-text">多重分区分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%8C%BA%E7%9A%84%E5%AD%98%E5%82%A8%E4%BF%9D%E6%8A%A4"><span class="toc-number">3.4.3.</span> <span class="toc-text">分区的存储保护</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E5%92%8C%E8%A6%86%E7%9B%96"><span class="toc-number">3.5.</span> <span class="toc-text">交换和覆盖</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%86%E7%9B%96"><span class="toc-number">3.5.1.</span> <span class="toc-text">覆盖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2"><span class="toc-number">3.5.2.</span> <span class="toc-text">交换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2VS%E8%A6%86%E7%9B%96"><span class="toc-number">3.5.3.</span> <span class="toc-text">交换VS覆盖</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">程序、进程和作业</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F-2"><span class="toc-number">4.1.</span> <span class="toc-text">程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B"><span class="toc-number">4.2.</span> <span class="toc-text">进程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F-%E8%A1%8C%E4%B8%BA%E5%9C%A8%E5%B9%B6%E8%A1%8C%E7%A8%8B%E5%BA%8F%E4%B8%AD%E6%98%AF%E6%80%8E%E4%B9%88%E5%AD%98%E5%82%A8%E7%9A%84"><span class="toc-number">4.2.1.</span> <span class="toc-text">程序&#x2F;行为在并行程序中是怎么存储的</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E4%B8%9A"><span class="toc-number">4.3.</span> <span class="toc-text">作业</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">实存管理和虚存管理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">页式内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">6.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%AF%E5%88%86%E9%A1%B5%E7%B3%BB%E7%BB%9F"><span class="toc-number">6.2.</span> <span class="toc-text">纯分页系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B5%E8%A1%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">6.3.</span> <span class="toc-text">页表的数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E9%A1%B5%E8%A1%A8"><span class="toc-number">6.3.1.</span> <span class="toc-text">哈希页表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E7%BD%AE%E9%A1%B5%E8%A1%A8"><span class="toc-number">6.3.2.</span> <span class="toc-text">反置页表</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text">段式存储管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-2"><span class="toc-number">7.1.</span> <span class="toc-text">基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AE%B5"><span class="toc-number">7.1.1.</span> <span class="toc-text">段</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AE%B5%E7%9A%84%E5%9C%B0%E5%9D%80%E6%98%AF%E4%BA%8C%E7%BB%B4%E7%9A%84"><span class="toc-number">7.1.1.1.</span> <span class="toc-text">段的地址是二维的</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AE%B5%E8%A1%A8"><span class="toc-number">7.1.2.</span> <span class="toc-text">段表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%A1%E6%81%AF%E5%85%B1%E4%BA%AB"><span class="toc-number">7.2.</span> <span class="toc-text">信息共享</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="toc-number">7.3.</span> <span class="toc-text">段页式存储</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">8.</span> <span class="toc-text">虚拟内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-number">8.1.</span> <span class="toc-text">基本介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81"><span class="toc-number">8.1.1.</span> <span class="toc-text">基本特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%92%8CCache%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">8.1.2.</span> <span class="toc-text">和Cache的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5%EF%BC%88%E6%AE%B5%EF%BC%89%E7%B3%BB%E7%BB%9F"><span class="toc-number">8.2.</span> <span class="toc-text">请求分页（段）系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E8%A1%A8%E7%BB%93%E6%9E%84"><span class="toc-number">8.2.1.</span> <span class="toc-text">页表结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-3"><span class="toc-number">8.3.</span> <span class="toc-text">基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%A9%BA%E9%97%B4"><span class="toc-number">8.3.1.</span> <span class="toc-text">进程空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="toc-number">8.3.2.</span> <span class="toc-text">虚拟地址空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E5%88%86%E5%8C%BA-%E6%96%87%E4%BB%B6"><span class="toc-number">8.3.3.</span> <span class="toc-text">交换分区&#x2F;文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84"><span class="toc-number">8.3.4.</span> <span class="toc-text">地址映射</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">8.4.</span> <span class="toc-text">页面的基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E8%B0%83%E5%85%A5"><span class="toc-number">8.4.1.</span> <span class="toc-text">页面调入</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%84%E8%B0%83%E9%A1%B5"><span class="toc-number">8.4.1.1.</span> <span class="toc-text">预调页</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%89%E9%9C%80%E8%B0%83%E9%A1%B5"><span class="toc-number">8.4.1.2.</span> <span class="toc-text">按需调页</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E9%A1%B5%E9%94%99%E8%AF%AF"><span class="toc-number">8.4.2.</span> <span class="toc-text">缺页错误</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E6%9B%BF%E6%8D%A2"><span class="toc-number">8.4.3.</span> <span class="toc-text">页面替换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E4%BC%98%E7%BD%AE%E6%8D%A2OPT"><span class="toc-number">8.4.3.1.</span> <span class="toc-text">最优置换OPT</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%E7%AE%97%E6%B3%95FIFO"><span class="toc-number">8.4.3.2.</span> <span class="toc-text">先进先出算法FIFO</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%94%B9%E8%BF%9B%E7%9A%84FIFO%E7%AE%97%E6%B3%95%EF%BC%9ASecond-Chance"><span class="toc-number">8.4.3.2.1.</span> <span class="toc-text">改进的FIFO算法：Second Chance</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%94%B9%E8%BF%9B%E7%9A%84FIFO%E7%AE%97%E6%B3%95%EF%BC%9AClock"><span class="toc-number">8.4.3.2.2.</span> <span class="toc-text">改进的FIFO算法：Clock</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E8%BF%91%E6%9C%80%E4%B9%85%E4%B8%8D%E7%AE%97%E6%B3%95LRU"><span class="toc-number">8.4.3.3.</span> <span class="toc-text">最近最久不算法LRU</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%80%81%E5%8C%96%E7%AE%97%E6%B3%95"><span class="toc-number">8.4.3.3.1.</span> <span class="toc-text">老化算法</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Page-Cache%E4%B8%8E%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">8.5.</span> <span class="toc-text">Page Cache与一致性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-4"><span class="toc-number">8.5.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E8%BE%85%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%9A%E6%9B%B4%E6%96%B0%E9%97%AE%E9%A2%98"><span class="toc-number">8.5.2.</span> <span class="toc-text">主辅存一致性：更新问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%8B%E7%9A%84%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">8.6.</span> <span class="toc-text">多进程下的虚拟内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-5"><span class="toc-number">8.6.1.</span> <span class="toc-text">基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E9%9B%86"><span class="toc-number">8.6.1.1.</span> <span class="toc-text">工作集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A9%BB%E7%95%99%E9%9B%86"><span class="toc-number">8.6.1.2.</span> <span class="toc-text">驻留集</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D%E6%94%BF%E7%AD%96"><span class="toc-number">8.6.2.</span> <span class="toc-text">页面分配政策</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%9D%97%E5%88%9D%E5%A7%8B%E5%88%86%E9%85%8D%E6%96%B9%E6%B3%95"><span class="toc-number">8.6.3.</span> <span class="toc-text">内存块初始分配方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AD%96%E7%95%A5"><span class="toc-number">8.6.4.</span> <span class="toc-text">页面置换策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E9%85%8D%E6%A8%A1%E5%BC%8F%E4%B8%8E%E7%BD%AE%E6%8D%A2%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%90%AD%E9%85%8D"><span class="toc-number">8.6.5.</span> <span class="toc-text">分配模式与置换模式的搭配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E6%B8%85%E9%99%A4%E7%AD%96%E7%95%A5"><span class="toc-number">8.6.6.</span> <span class="toc-text">页面清除策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%9F%E8%BD%BD%E4%B8%8E%E8%B4%9F%E8%BD%BD%E6%8E%A7%E5%88%B6"><span class="toc-number">8.6.7.</span> <span class="toc-text">负载与负载控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B4%9F%E8%BD%BD%E6%8E%A7%E5%88%B6"><span class="toc-number">8.6.7.1.</span> <span class="toc-text">负载控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E6%8C%82%E8%B5%B7%E7%9A%84%E8%BF%9B%E7%A8%8B"><span class="toc-number">8.6.7.2.</span> <span class="toc-text">可挂起的进程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6%E6%8A%80%E6%9C%AF"><span class="toc-number">8.7.</span> <span class="toc-text">写时复制技术</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E4%BF%9D%E6%8A%A4"><span class="toc-number">8.8.</span> <span class="toc-text">存储保护</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">9.</span> <span class="toc-text">页表自映射</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2024 By pigKiller</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">你终会看到，你的歌声和旗帜在飘扬</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script></div><script src="f12.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>