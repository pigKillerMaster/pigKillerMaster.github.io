<!DOCTYPE html><html lang="zh-CN" data-theme="light"><script>((function() {var callbacks = [],timeLimit = 50,open = false;setInterval(loop, 1);return {addListener: function(fn) {callbacks.push(fn);},cancleListenr: function(fn) {callbacks = callbacks.filter(function(v) {return v !== fn;});}}
function loop() {var startTime = new Date();debugger;if (new Date() - startTime > timeLimit) {if (!open) {callbacks.forEach(function(fn) {fn.call(null);});}open = true;window.stop();alert('你真坏，请关闭控制台！');document.body.innerHTML = "";} else {open = false;}}})()).addListener(function() {window.location.reload();});</script><script>function toDevtools(){
  let num = 0; 
  let devtools = new Date();
  devtools.toString = function() {
    num++;
    if (num > 1) {
        alert('你真坏，请关闭控制台！')
        window.location.href = "about:blank"
        blast();
    }
  }
  console.log('', devtools);
}
toDevtools();</script><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>操作系统-理论-内存 | 浮泛之舟</title><meta name="author" content="pigKiller"><meta name="copyright" content="pigKiller"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="存储 存储资源是一种宝贵的资源，无论存储器有多大，程序最终都能将其耗尽。 静态存储器SRAM：读写速度块、生产成本高、多用作Cache 动态存储器DRAM：读写速度慢、集成度高、生产成本低、多用作主存储器 存储组织 存储组织：再存储技术和CPU寻址技术许可的范围内组织合理的存储结构。 合理结合不同的存储器，达到各层次的存储器都处于均衡的繁忙状态的理想效果（命中率），营造又快又大的错觉。 典型的层次">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统-理论-内存">
<meta property="og:url" content="https://pigkillermaster.github.io/2024/03/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%90%86%E8%AE%BA-%E5%86%85%E5%AD%98/index.html">
<meta property="og:site_name" content="浮泛之舟">
<meta property="og:description" content="存储 存储资源是一种宝贵的资源，无论存储器有多大，程序最终都能将其耗尽。 静态存储器SRAM：读写速度块、生产成本高、多用作Cache 动态存储器DRAM：读写速度慢、集成度高、生产成本低、多用作主存储器 存储组织 存储组织：再存储技术和CPU寻址技术许可的范围内组织合理的存储结构。 合理结合不同的存储器，达到各层次的存储器都处于均衡的繁忙状态的理想效果（命中率），营造又快又大的错觉。 典型的层次">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403252018445.png">
<meta property="article:published_time" content="2024-03-25T12:16:53.000Z">
<meta property="article:modified_time" content="2024-03-25T12:19:02.170Z">
<meta property="article:author" content="pigKiller">
<meta property="article:tag" content="OS理论">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403252018445.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://pigkillermaster.github.io/2024/03/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%90%86%E8%AE%BA-%E5%86%85%E5%AD%98/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '操作系统-理论-内存',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2024-03-25 20:19:02'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202307102227559.png" onerror="onerror=null;src='https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202309212200810.jpg'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">35</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">23</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-categories"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403252018445.png')"><nav id="nav"><span id="blog-info"><a href="/" title="浮泛之舟"><span class="site-name">浮泛之舟</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-categories"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">操作系统-理论-内存</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-03-25T12:16:53.000Z" title="发表于 2024-03-25 20:16:53">2024-03-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-03-25T12:19:02.170Z" title="更新于 2024-03-25 20:19:02">2024-03-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/OS%E7%90%86%E8%AE%BA/">OS理论</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>23分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="操作系统-理论-内存"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>存储</h1>
<p>存储资源是一种宝贵的资源，无论存储器有多大，程序最终都能将其耗尽。</p>
<p>静态存储器SRAM：读写速度块、生产成本高、多用作Cache</p>
<p>动态存储器DRAM：读写速度慢、集成度高、生产成本低、多用作主存储器</p>
<h2 id="存储组织">存储组织</h2>
<p>存储组织：再存储技术和CPU寻址技术许可的范围内<strong>组织合理的存储结构</strong>。</p>
<p>合理结合不同的存储器，达到各层次的存储器都处于均衡的繁忙状态的理想效果（命中率），营造又快又大的错觉。</p>
<p>典型的层次式存储组织：访问速度越来越慢，容量越来越大，价格越来越便宜</p>
<h2 id="存储管理">存储管理</h2>
<p>存储管理的功能：</p>
<ul>
<li>
<p>存储分配和回收：存储管理的主要内容。</p>
<ul>
<li>关注其算法和相应的数据结构。</li>
</ul>
</li>
<li>
<p>地址变换：</p>
<ul>
<li>可执行文件生成中的链接技术</li>
<li>程序加载时的重定位技术</li>
<li>进程运行时硬件和软件的地址变换技术和机构</li>
</ul>
</li>
<li>
<p>存储共享和保护：代码和数据共享，对地址空间的访问权限（读、写、执行）。</p>
</li>
<li>
<p>存储器扩充：涉及存储器的逻辑组织和物理组织；</p>
<ul>
<li>由应用程序控制：覆盖；</li>
<li>由OS控制：交换（整个进程空间），请求调入和预调入（部分进程空间）</li>
</ul>
</li>
</ul>
<h1>编译、链接、装入</h1>
<p>怎么从代码到可执行文件。</p>
<h2 id="gcc的工作">gcc的工作</h2>
<p>GCC编译器驱动程序读取源程序文件<code>*.c</code>，并把它翻译成一个可执行目标文件<code>*</code>。这个翻译过程分为四个阶段：<strong>预处理（Preprocessing）、编译（Compilation）、汇编（Assembly）、链接（Linking）</strong>。执行这四个阶段的程序（<strong>预处理器、编译器、汇编器、和链接器</strong>）一起构成了编译系统。</p>
<p>gcc调用包含的工具：</p>
<ul>
<li><code>cc1</code>：预处理器和编译器</li>
<li><code>as</code>：汇编器</li>
<li><code>collect2</code>：链接器</li>
</ul>
<p>具体流程：</p>
<ol>
<li>
<p>预处理阶段</p>
<ol>
<li>处理所有的预处理，包括<code>define</code>，<code>ifdefine</code></li>
<li>删除所有的注释。</li>
<li>添加行号和文件标识，以便编译时产生调试用的行号及编译错误警告行号。</li>
<li><strong>保留所有的<code>#pragma</code>编译器指令</strong>，因为编译器需要使用它们。</li>
<li>使用<code>gcc -E hello.c -o hello.i</code>命令来进行预处理， 预处理得到的另一个程序通常是以<code>.i</code>作为文件扩展名。</li>
</ol>
</li>
<li>
<p>编译阶段</p>
<ol>
<li>编译器（ccl）将预处理完的文本文件<code>hello.i</code>翻译成文本文件<code>hello.s</code>，它包含一个<strong>汇编语言程序</strong>：汇编语言是非常有用的，因为它为不同高级语言的不同编译器提供了通用的输出语言。</li>
<li>该程序包含函数<code>main</code>的定义。</li>
</ol>
</li>
<li>
<p>汇编阶段：</p>
<ol>
<li>汇编器（as）将<code>hello.s</code><strong>翻译成机器语言指令</strong></li>
<li>把这些指令打包成一种叫做<strong>可重定位目标程序</strong>的格式</li>
<li>并将结果保存在目标文件<code>hello.o</code>中，<code>hello.o</code>是一个二进制文件。</li>
</ol>
</li>
<li>
<p>链接</p>
<ol>
<li>hello程序调用了printf函数，它存在于一个名为printf.o的单独的预编译好了的目标文件中，而这个文件必须以某种方式合并到我们的hello.o程序中。</li>
<li>连接器（ld）就负责处理这种合并。结果就得到了hello文件，它是一个<strong>可执行目标文件</strong>（或者称为<strong>可执行文件</strong>）</li>
<li>可执行文件可以被加载到内存中，由系统执行。</li>
</ol>
</li>
</ol>
<h2 id="可执行文件">可执行文件</h2>
<p>可执行文件的常见格式为ELF文件。</p>
<ol>
<li>ELF头，包括程序的基本信息，比如体系结构和操作系统，同时也包含了节头表和段头表相对文件的偏移量（offset）。</li>
<li>段头表（或程序头表，program header table），主要包含程序中各个段（segment）的信息，段的信息需要在运行时刻使用。</li>
<li>节头表（section header table），主要包含程序中各个节（section）的信息，节的信息需要在程序编译和链接的时候使用。</li>
<li>段头表中的每一个表项，记录了该段数据载入内存时的目标位置等，记录了用于指导应用程序加载的各类信息。</li>
<li>节头表中的每一个表项，记录了该节程序的代码段、数据段等各个段的内容，主要是链接器在链接的过程中需要使用。</li>
</ol>
<p>段头表和节头表指向了同样的地方，这意味着两者只是程序数据的两种视图：</p>
<ol>
<li>组成可重定位文件，参与可执行文件和可共享文件的链接。此时使用节头表。</li>
<li>组成可执行文件或者可共享文件，在运行时为加载器提供信息。此时使用段头表。</li>
</ol>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403182039357.png" alt="image-20240318203921231"></p>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403182039285.png" alt="image-20240318203948152"></p>
<h3 id="具体划分">具体划分</h3>
<p>一个程序本质上都是由bss段、data段、text段三个组成的。</p>
<p>在C语言之类的程序编译完成之后，已初始化的全局变量保存在data 段中，未初始化的全局变量保存在bss 段中。</p>
<ul>
<li>bss段：（bss segment）用来存放程序中<strong>未初始化的全局变量</strong>的一块内存区域。bss段属于<strong>静态内存分配</strong>。</li>
<li>data段：数据段（data segment）用来存放程序中<strong>已初始化的全局变量</strong>的一块内存区域。数据段属于<strong>静态内存分配</strong>。</li>
<li>text段：代码段（code segment/text segment）用来<strong>存放程序执行代码</strong>的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读（某些架构也允许代码段为可写，即允许修改程序）。在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。</li>
</ul>
<p>text和data段都在可执行文件中，由系统从可执行文件中加载，而<strong>bss段不在可执行文件中，由系统初始化</strong>。</p>
<p>一个装入内存的可执行程序，除了bss、data和text段外，还需构建<strong>一个栈（stack）和一个堆（heap）</strong>。</p>
<ul>
<li>栈(stack)：存放、交换<strong>临时数据</strong>的内存区
<ul>
<li>用户存放程序局部变量的内存区域，（但不包括static声明的变量，<strong>static意味着在数据段中存放变量</strong>）。</li>
<li>保存/恢复调用现场。在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。</li>
</ul>
</li>
<li>堆（heap）：存放进程<strong>运行中动态分配的内存段</strong>
<ul>
<li>它的大小并不固定，可动态扩张或缩减。当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）。</li>
</ul>
</li>
</ul>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403182109468.png" alt="image-20240318210916389"></p>
<h2 id="重定位">重定位</h2>
<ol>
<li>地址空间：源程序经过编译后得到的目标程序，存在于它所限定的地址范围内，这个范围称为地址空间。<strong>地址空间是逻辑地址的集合</strong>。</li>
<li>存储空间：存储空间是指主存中一系列存储信息的物理单元的集合，这些单元的编号称为物理地址或绝对地址。<strong>存储空间是物理地址的集合</strong>。</li>
</ol>
<p>作业会有存储空间装入存储空间。重定位是在装入时对目标程序中的<strong>指令和数据地址的修改</strong>，或映射过程。</p>
<p>在编译后，原先的函数跳转变为了形如<code>jal func_name</code>的汇编指令，但是具体的跳转地址却是0，这显然是不正常的。这是因为编译时函数定义在不同的文件中，无法知道准确的地址，因而需要<strong>重定位</strong>来填入具体的地址。</p>
<p><strong>重定位的过程在连接中完成</strong>。链接将生成的机器码<code>.o</code>文件链接到一起，形成最终的可执行文件。在链接时，链接器会扫描各个目标文件，将之前未填写的地址填写上，从而生成一个真正可执行的文件。</p>
<p>在Mips体系结构中，<code>Elf32_Rel</code>给出了重定位的地点.</p>
<ul>
<li><code>r_offest</code>给出了<strong>使用重定位动作的地点</strong>。
<ul>
<li>对重定位文件来说，值是从<strong>节起始处</strong>到受重定位影响的<strong>存储单元的字节偏移量</strong>；</li>
<li>对<strong>可执行文件或共享目标文件</strong>来说，它的值是受重定位影响的存储单元的<strong>虚拟地址</strong>。</li>
</ul>
</li>
<li><code>r_info</code>给出了与重定位修改地点有关的符号表索引和所使用的重定位的类型。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf32_Addr r_offset;</span><br><span class="line">    Elf32_Word r_info;	<span class="comment">//(symbol:24; type:8)</span></span><br><span class="line">&#125; Elf32_Rel;</span><br></pre></td></tr></table></figure>
<p>重定位/链接的本质：河边不同可执行文件中相同的节</p>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403182110975.png" alt="image-20240318211052894"></p>
<h2 id="程序">程序</h2>
<p>程序的入口也写在ELF文件中，但是不是Main函数的地址。一般为<code>_start</code>函数，在这个入口函数中调用了<code>main</code>。</p>
<p>执行程序的过程：<code>shell</code>调用<code>fork()</code>系统调用，创建出一个子进程子进程调用<code>Execve()</code>加载<code>program</code></p>
<ul>
<li>
<p>装载前的工作：<code>shell</code>调用<code>fork()</code>系统调用，创建出一个子进程。</p>
</li>
<li>
<p>装载工作：子进程调用<code>execve()</code>加载<code>program</code>（即要执行的程序）。</p>
</li>
<li>
<p>程序如何被加载：</p>
<ul>
<li>
<p>加载器在加载程序的时候只需要看ELF文件中和segment相关的信息即可。</p>
<ul>
<li>读出的信息分为两部分，一部分是各segment的具体信息，另一部分是section和segment之间的对应关系。类型为Type为Load的segment是<strong>需要被加载到内存中的部分</strong>。</li>
</ul>
<ol>
<li>读取ELF头部的魔数(Magic Number)，以确认该文件确实是ELF文件。
<ol>
<li>ELF文件的头四个字节依次为<code>0x7f</code>、<code>E</code>、<code>L</code>、<code>F</code>。加载器会首先对比这四个字节，若不一致，则报错。</li>
</ol>
</li>
<li>找到段表项。
<ol>
<li>ELF头部会给出的段表起始位置在文件中的偏移，段表项的大小，以及段表包含了多少项。根据这些信息可以找到每一个段表项。</li>
</ol>
</li>
<li>对于每个段表项解析出各个段应当被加载的虚地址，在文件中的偏移。以及在内存中的大小和在文件中的大小。（段在文件中的大小小于等于内存中的大小）。</li>
<li>对于每一个段，根据其在内存中的大小，为其分配足够的物理页，并映射到指定的虚地址上。再将文件中的内容拷贝到内存中。
<ol>
<li>若ELF中记录的段在内存中的大小大于在文件中的大小，则多出来的部分用0进行填充。</li>
<li>一个segment<strong>在文件中的大小是小于等于其在内存中的大小</strong>：如果在文件中的大小小于在内存中的大小，那么在载入内存时通过补零使其达到其在内存中应有的大小。</li>
</ol>
</li>
<li>设置进程控制块中的PC为ELF文件中记载的入口地址。</li>
<li>各个segment都装入内存后，控制权交给应用，从应用入口开始，将控制权交给进程开始执行！</li>
</ol>
</li>
</ul>
</li>
</ul>
<img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403182057312.png" alt="image-20240318205727189" style="zoom:50%;" />
<h1>存储管理</h1>
<p>存储管理的基石：</p>
<ol>
<li>地址独立：程序发出的地址与物理地址无关</li>
<li>地址保护：一个程序不能访问另一个程序的地址空间</li>
</ol>
<p>存储管理要解决的问题：分配和回收</p>
<h2 id="存储分配">存储分配</h2>
<ol>
<li>直接指定方式：程序员在编程序时，或编译程序(汇编程序)对源程序进行编译(汇编)时，所用的是<strong>实际地址</strong>（即为物理地址）。</li>
<li>静态分配(Static Allocation)：程序员编程时，或由编译程序产生的目的程序，均可从其<strong>地址空间的零地址</strong>（虚拟地址）开始；当装配程序对其进行连接装入时才确定它们在主存中的地址。</li>
<li>动态分配(Dynamic Allocation)：作业在存储空间中的位置，在其装入时确定,在其执行过程中可根据需要申请附加的存储空间，而且一个作业已占用的部分区域不再需要时，可以要求归还给系统。</li>
</ol>
<h3 id="单道程序">单道程序</h3>
<p>单道程序：整个内存中只有两个程序，一个用户程序和操作系统。</p>
<p>操作系统所占空间是固定的，因而可以将用户程序加载到同一个地址，即用户地址永远从同一个地方开始运行。</p>
<p>因为只有一个用户程序，故天然的有地址独立和地址保护。这样的操作不需要地址映射，可以直接使用物理地址。</p>
<p>优点：执行过程中无需任何地址翻译工作，程序运行速度快。</p>
<p>缺点：</p>
<ol>
<li>比物理内存大的程序无法加载，因而无法运行。</li>
<li>造成资源浪费：小程序会造成空间浪费、I/O时间长会造成计算资源浪费。</li>
</ol>
<h3 id="多道程序">多道程序</h3>
<p>空间分配为分区式：把内存分为一些<strong>大小相等或不等的分区</strong>(partition)，<strong>每个应用程序占用一个或几个分区</strong>。操作系统占用其中<strong>一个分区</strong>。</p>
<p>支持多个程序并发执行，但难以进行内存分区的共享</p>
<h4 id="分区方式">分区方式</h4>
<ul>
<li>固定（静态）式分区分配，程序适应分区。</li>
<li>可变（动态）式分区分配，分区适应程序。</li>
</ul>
<h5 id="固定式分区">固定式分区</h5>
<p>把内存划分为若干个固定大小的连续分区。</p>
<ul>
<li>分区大小相等：只适合于多个相同程序的并发执行（处理多个类型相同的对象）。</li>
<li>分区大小不等：多个小分区、适量的中等分区、少量的大分区。根据程序的大小，分配当前空闲的、适当大小的分区。</li>
</ul>
<p>优点：易于实现，开销小。</p>
<p>缺点：内碎片造成浪费，分区总数固定，限制了并发执行的程序数目。</p>
<p>采用的数据结构：分区表：记录分区的大小和使用情况</p>
<ol>
<li>
<p>单一队列的分配方式</p>
<p>当需要加载程序时，选择一个当前闲置且容量足够大的分区进行加载，可采用共享队列的固定分区（多个用户程序排在一个共同的队列里面等待分区）分配。</p>
<img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403182122194.png" alt="image-20240318212212119" style="zoom:50%;" />
</li>
<li>
<p>多队列分配方式</p>
<p>由于程序大小和分区大小不一定匹配，有可能形成<strong>一个小程序占用一个大分区的情况</strong>，从而造成内存里虽然有小分区闲置但无法加载大程序的情况。这时，可以采用多个队列，给每个分区一个队列，程序按照大小排在相应的队列里。</p>
<img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403182122787.png" alt="image-20240318212217725" style="zoom:50%;" />
</li>
</ol>
<h5 id="可变式分区">可变式分区</h5>
<p>可变式分区：分区的边界可以移动，即分区的大小可变。</p>
<p>优点：没有内碎片</p>
<p>缺点：有外碎片</p>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403182123334.png" alt="image-20240318212333066"></p>
<h2 id="闲置空间的管理">闲置空间的管理</h2>
<p>在管理内存的时候，OS需要知道内存空间有多少空闲。这就需要<strong>跟踪内存的使用</strong>。</p>
<p>跟踪的办法有两种：位图表示法（分区表）和链表表示法（分区链表）</p>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403182129884.png" alt="image-20240318212909769"></p>
<ol>
<li>
<p>位图表示法</p>
<p>给<strong>每个分配单元赋予一个字位</strong>，用来记录该分配单元是否闲置。例如，字位取值为0表示单元闲置，取值为1则表示已被占用，这种表示方法就是位图表示法。</p>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403182124360.png" alt="image-20240318212431295"></p>
</li>
<li>
<p>链表表示法</p>
<p>将分配单元<strong>按照是否闲置链接起来</strong>，这种方法称为链表表示法。</p>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403182124480.png" alt="image-20240318212442396"></p>
</li>
</ol>
<p>位图表示法：</p>
<ul>
<li>空间成本固定：不依赖于内存中的程序数量。</li>
<li>时间成本低：操作简单，直接修改其位图值即可。</li>
<li>没有容错能力：如果一个分配单元为1，不能肯定<strong>应该为1还是因错误变成1</strong>。</li>
</ul>
<p>链表表示法：</p>
<ul>
<li>空间成本：取决于程序的数量。</li>
<li>时间成本：链表扫描通常速度较慢，还要进行链表项的插入、删除和修改。</li>
<li>有一定容错能力：因为链表有被占空间和闲置空间的表项，可以<strong>相互验证</strong>。</li>
</ul>
<h3 id="可变分区的管理">可变分区的管理</h3>
<p>内存分配采用两张表：已分配分区表和未分配分区表。</p>
<p>每张表的表项为存储控制块MCB（Memory Control Block），包括已分配AMCB（Allocated）和未分配FMCB（Free）。</p>
<p>空闲分区控制块按某种次序构成FMCB链表结构。当分区被分配出去以后，前、后向指针无意义。</p>
<img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403182131722.png" alt="image-20240318213136617" style="zoom:50%;" />
<img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403182131563.png" alt="image-20240318213150482" style="zoom: 67%;" />
<h2 id="分配内存">分配内存</h2>
<p>有了对空闲空间的追踪，就可以对内存进行动态分配，让空余内存得到使用，同时不影响已分配内存区域的正常使用。</p>
<ol>
<li>规定size是不再切割的剩余分区的大小。设请求的分区大小为<code>u.size</code>，空闲分区的大小为<code>m.size</code>。</li>
<li>若<code>m.size-u.size≤size</code>，将整个分区分配给请求者。</li>
<li>否则，从该分区中按请求的大小划分出一块内存空间分配出去，余下的部分仍留在空闲分区表/链中。</li>
</ol>
<h3 id="基于顺序搜索的分配方法">基于顺序搜索的分配方法</h3>
<ol>
<li>
<p>首次适应算法（First Fit）：每个空白区按其在存储空间中地址递增的顺序连在一起，在为作业分配存储区域时，从这个空白区域链的始端开始查找，选择<strong>第一个足以满足请求的空白块</strong>。</p>
<ol>
<li>
<p>优点：</p>
<ol>
<li>分配和释放的时间性能较好</li>
<li><strong>较大的空闲分区保留在内存的高端</strong></li>
</ol>
</li>
<li>
<p>缺点：随着低端内存被不断分配，会产生很多小分区，开销会增大。</p>
</li>
</ol>
</li>
<li>
<p>下次适应算法（Next Fit）：把存储空间中空白区<strong>构成一个循环链</strong>，每次为存储请求查找合适的分区时，总是<strong>从上次查找结束的地方开始</strong>，只要找到一个足够大的空白区，就将它划分后分配出去。</p>
<ol>
<li>多余的地址会保留，下次从多余地址处开始搜索</li>
</ol>
</li>
<li>
<p>最佳适应算法（Best Fit）：为一个作业选择分区时，总是寻找其<strong>大小最接近于</strong>作业所要求的存储区域。</p>
</li>
<li>
<p>最坏适应算法（Worst Fit）：为作业选择存储区域时，总是寻找<strong>最大的空白区</strong>。</p>
</li>
</ol>
<p>算法特点：</p>
<ol>
<li>首次适应：优先利用内存低地址部分的空闲分区。但由于<strong>低地址部分不断被划分</strong>，留下许多<strong>难以利用的很小的空闲分区</strong>（碎片或零头），而每次查找又都是从低地址部分开始，<strong>增加了查找可用空闲分区的开销</strong>。</li>
<li>下次适应：使存储空间的利用更加均衡，不致使小的空闲区集中在存储区的一端，但这会<strong>导致缺乏大的空闲分区</strong>。</li>
<li>最佳适应：若存在与作业大小一致的空闲分区,则它必然被选中，若不存在与作业大小一致的空闲分区，则只划分比作业稍大的空闲分区，从而保留了大的空闲分区。最佳适应算法往往使<strong>剩下的空闲区非常小</strong>，从而在存储器中留下许多难以利用的小空闲区（碎片）。</li>
<li>最坏适应算法的特点：总是挑选满足作业要求的最大的分区分配给作业。这样使分给作业后剩下的空闲分区也较大，可装下其它作业。由于最大的空闲分区总是因首先分配而划分，<strong>当有大作业到来时，其存储空间的申请往往会得不到满足</strong>。</li>
</ol>
<p>最佳适应算法是<strong>内存分配和释放平均时间之和最大</strong>的算法</p>
<h3 id="基于索引搜索的分配方法">基于索引搜索的分配方法</h3>
<p>基于顺序搜索的动态分区分配算法一般只是适合于较小的系统，如果系统的分区很多，空闲分区表（链）可能很大（很长），检索速度会比较慢。为了提高搜索空闲分区的速度，<strong>大中型系统</strong>采用了基于索引搜索的动态分区分配算法。</p>
<h4 id="快速适应算法">快速适应算法</h4>
<p>快速适应算法，又称为分类搜索法，把空闲分区<strong>按容量大小进行分类</strong>，<strong>经常用到长度</strong>的空闲区设立<strong>单独的空闲区链表</strong>。系统为多个空闲链表设立一张管理索引表。</p>
<p>优点：</p>
<ol>
<li>查找效率高，仅需要根据程序的长度，寻找到能容纳它的最小空闲区链表，取下第一块进行分配即可。</li>
<li>该算法在分配时，不会对任何分区产生分割，所以<strong>能保留大的分区</strong>，也不会产生内存碎片。</li>
</ol>
<p>缺点：</p>
<ol>
<li>在分区归还主存时算法复杂，系统开销较大。</li>
<li>在<strong>分配空闲分区时是以进程为单位</strong>，<strong>一个分区只属于一个进程</strong>，存在一定的浪费。空间换时间。</li>
</ol>
<h4 id="伙伴系统">伙伴系统</h4>
<p>固定分区方式不够灵活，当进程大小与空闲分区大小不匹配时，内存空间利用率很低。动态分区方式算法复杂，回收空闲分区时需要进行分区合并等，系统开销较大。</p>
<p>伙伴系统(buddy system)是介于固定分区与可变分区之间的动态分区技术。</p>
<p>伙伴：在分配存储块时<strong>将一个大的存储块分裂成两个大小相等的小块</strong>，这两个小块就称为“伙伴”。</p>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403182150634.png" alt="image-20240318215024536"></p>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403182150407.png" alt="image-20240318215042332"></p>
<h2 id="系统中的碎片">系统中的碎片</h2>
<p>内存中无法被利用的存储空间称为碎片。</p>
<p>内部碎片：</p>
<ul>
<li>指分配给作业的存储空间中未被利用的部分，如固定分区中存在的碎片。</li>
<li>单一连续区存储管理、固定分区存储管理等都会出现内部碎片。</li>
<li>内部碎片无法被整理，但作业完成后会得到释放。它们<strong>其实已经被分配出去了，只是没有被利用</strong>。</li>
</ul>
<p>外部碎片：</p>
<ul>
<li>指系统中<strong>无法利用的小的空闲分区</strong>。如<strong>分区与分区之间存在的碎片</strong>。这些不连续的区间就是外部碎片。动态分区管理会产生外部碎片。</li>
<li>外部碎片才是造成内存系统性能下降的主要原因。外部碎片可以被整理后清除。</li>
<li>消除外部碎片的方法：紧凑技术。</li>
</ul>
<h3 id="紧凑技术">紧凑技术</h3>
<p>通过移动作业从把多个分散的小分区拼接成一个大分区的方法称为紧凑（拼接或紧缩）。</p>
<p>目标：消除外部碎片，使本来分散的多个小空闲分区连成一个大的空闲区。</p>
<p>紧凑时机：找不到足够大的空闲分区且<strong>总空闲分区容量可以满足</strong>作业要求时。</p>
<p>技术支撑：<strong>动态重定位</strong>：作业在内存中的位置发生了变化，这就必须对其地址加以修改或变换。</p>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403182205202.png" alt="动态重定位的实现"></p>
<h3 id="多重分区分配">多重分区分配</h3>
<p>多重分区分配：一个作业往往由相对独立的程序段和数据段组成，将这些片断分别装入到存储空间中不同的区域内的分配方式。</p>
<img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403182206926.png" alt="image-20240318220631806" style="zoom:50%;" />
<h3 id="分区的存储保护">分区的存储保护</h3>
<p>存储保护是为了防止一个作业有意或无意地破坏操作系统或其它作业。常用的存储保护方法有</p>
<ul>
<li>界限寄存器方法：
<ul>
<li>上下界寄存器方法</li>
<li>基址、限长寄存器（BR,LR）方法</li>
<li><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403182208204.png" alt="image-20240318220801094"></li>
</ul>
</li>
<li>存储保护键方法：
<ul>
<li>给每个存储块分配一个单独的保护键，它相当于一把锁。进入系统的每个作业也赋予一个保护键，它相当于一把钥匙。</li>
<li>当作业运行时，检查钥匙和锁是否匹配，如果不匹配，则系统发出保护性中断信号，停止作业运行。</li>
</ul>
</li>
</ul>
<h2 id="交换和覆盖">交换和覆盖</h2>
<p>解决大作业在小内存中运行的问题：在运行过程中程序可能需要新的内存空间，原先分配的空间不够，如何继续分配：交换和覆盖</p>
<blockquote>
<p>覆盖技术主要用在早期的OS 中，交换技术则用在现代OS 中。</p>
</blockquote>
<h3 id="覆盖">覆盖</h3>
<p>覆盖：把一个程序划分为一系列功能相对独立的程序段，让执行时不要求同时装入内存的程序段组成一组（称为覆盖段），共享主存的同一个区域，这种内存扩充技术就是覆盖。</p>
<p>程序段先保存在磁盘上，当有关程序段的前一部分执行结束，把后续程序段调入内存，覆盖前面的程序段（内存“扩大”了）。</p>
<p>一般要求作业各模块之间有明确的调用结构，<strong>程序员要向系统指明覆盖结构，然后由操作系统完成自动覆盖</strong>。</p>
<p>缺点：对用户不透明，增加了用户负担。</p>
<h3 id="交换">交换</h3>
<p>交换：把暂时不用的某个（或某些）程序及其数据的部分或全部从主存移到辅存中去，以便腾出必要的存储空间；接着把指定程序或数据从辅存读到相应的主存中，并将控制转给它，让其在系统上运行。</p>
<p>优点：增加并发运行的程序数目，并且给用户提供适当的响应时间；<strong>编写程序时不影响程序结构</strong></p>
<p>缺点：对换入和换出的控制增加处理机开销；程序整个地址空间都进行传送，没有考虑执行过程中<strong>地址访问的统计特性</strong>。</p>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403182211214.png" alt="image-20240318221159076"></p>
<h3 id="交换VS覆盖">交换VS覆盖</h3>
<p>覆盖可<strong>减少一个程序运行所需的空间</strong>。交换可让整个程序暂存于外存中，让出内存空间。</p>
<p>覆盖是<strong>由程序员实现的</strong>，操作系统根据程序员提供的覆盖结构来完成程序段之间的覆盖。交换技术不要求程序员给出程序段之间的覆盖结构。</p>
<p>覆盖技术主要对同一个作业或程序进行。<strong>交换换主要在作业或程序间之间进行</strong>。</p>
<h1>程序、进程和作业</h1>
<h2 id="程序-2">程序</h2>
<p>程序是一个静态对象，是<strong>存储在磁盘中的可执行文件</strong>。</p>
<p>程序本身没有任何意义，也是数据的一部分，只有被执行了程序才能产生意义：<strong>程序是进程的一个实体</strong>。</p>
<p>只要不主动删除，程序会一直留在磁盘中。</p>
<h2 id="进程">进程</h2>
<p>进程是一个行为，是一个程序<strong>对某个数据集的执行过程，是分配资源的基本单位</strong>，是对<strong>执行过程</strong>的一种描述。进程包括程序和程序处理对象（数据集）才能产生意义。</p>
<ul>
<li>系统进程：完成操作系统功能的进程</li>
<li>用户进程：完成用户功能的进程</li>
</ul>
<p>进程是动态的作业过程，对进程的描述可以与计算机的执行过程等价，能够描述并发的状态。</p>
<p>进程具有一定的生命周期：执行完毕后即消失。</p>
<p>一个进程可以执行多个程序，一个程序也可以被多个进程执行，进程可以创建其他进程。</p>
<p>进程的执行需要连续的<strong>逻辑地址</strong>（实际物理地址经过映可以离散）。</p>
<h3 id="程序-行为在并行程序中是怎么存储的">程序/行为在并行程序中是怎么存储的</h3>
<p>程序本身是特定格式的数据，在并行程序中，基本不会涉及对程序的修改（在编译过程中确定），那么并行程序的执行过程就是对共有程序数据的读（无冲突），从共有的程序数据创建多个进程执行。</p>
<p>如果需要涉及对可执行文件的修改，就会引起锁冲突，造成并行各进程的执行内容不同。</p>
<h2 id="作业">作业</h2>
<p>作业是行为逻辑上的一个抽象，是计算机某次作业所需完成的特定对象。</p>
<p>作业需要经过作业提交、作业收容、作业执行和作业完成4个阶段。一个作业至少由一个进程组成。</p>
<h1>页式内存管理</h1>
<p>纯分页也称为基本分页管理，它不支持页面对换。当进程到来时一次性分配进程所需的所有物理内存（B正确），有多少页直接分配多少页框，并不是按需装入（相对应的按需装入称作请求分页）（A正确）。纯分页也是可以支持多级页表的，只不过此时的多级页表不能动态装入，所有级别的页表都同时装入内存（个人觉得纯分页再加多级页表就没意义了，多级页表就是为了动态调入页表，但理论上还是可以实现多级页表的）（C错误）。</p>
<h1>段式存储管理</h1>
<p>页是存储信息的物理单位，段是存储信息的逻辑单位。</p>
<p>实际应用中，某些段（数据段）的大小会不断增长</p>
<p>一个段可定义为一组逻辑信息，每个作业的地址空间是由一些分段构成的（由用户根据逻辑信息的相对完整来划分），每段都有自己的名字（通常是段号），且都是一段连续的地址空间，首地址为 0</p>
<blockquote>
<p>为什么说页的地址是一维的，而段的地址是二维的：</p>
<p>页式，一个程序的各页是根据程序空间<strong>连续编址</strong>（逻辑地址）的，程序地址空间只有一维；</p>
<p>段式，一个程序拆分成各段，独立编址（<strong>各段都从零开始编址</strong>），程序地址空间有两维。</p>
<p>即按照页式获取地址，可以直接获取页号、业内偏移量，进而得到物理地址。</p>
<p>对于段式，必须给出段号，根据段表找出此段的起始地址，再根据段内地址进行定位</p>
<p><strong>本质是因为不同段的大小不同</strong></p>
</blockquote>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403220813566.png" alt="image-20240322081316420"></p>
<p>段表记录了段和内存位置的对应关系</p>
<p>段表的基址和长度由段表寄存器给出</p>
<p>可重入代码（Reentrant Code) ：又称为纯代码（Pure Code) 是一种<strong>允许多个进程同时访问的代码</strong>。</p>
<p>为使各个进程所执行的代码完全相同绝对不允许可重入代码在执行中有任何改变。因此可重入代码是一种不允许任何进程对它进行修改的代码 。</p>
<h2 id="段页式存储">段页式存储</h2>
<p>用分段的方式来分配和管理<strong>虚拟存储器</strong>，用分页的方式来分配和管理<strong>实存储器</strong></p>
<h1>虚拟内存管理</h1>
<p>常规存储管理方式的特征：</p>
<ul>
<li>一次性：要求一个作业全部装入内存后方能运行。</li>
<li>驻留性：作业装入内存后一直驻留内存，直至结束。</li>
</ul>
<p>可能出现的问题：</p>
<ul>
<li>有的作业很大，所需内存空间大于内存总容量，使作业无法运行。</li>
<li>有大量作业要求运行，但内存容量不足以容纳下所有作业，只能让一部分先运行，其它在外存等待。</li>
</ul>
<p>已有解决方法：</p>
<ul>
<li>增加内存容量：最简单、最有效的办法</li>
<li><strong>从逻辑上扩充内存容量：覆盖、对换。</strong></li>
</ul>
<h2 id="请求分页">请求分页</h2>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://pigkillermaster.github.io">pigKiller</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://pigkillermaster.github.io/2024/03/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%90%86%E8%AE%BA-%E5%86%85%E5%AD%98/">https://pigkillermaster.github.io/2024/03/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%90%86%E8%AE%BA-%E5%86%85%E5%AD%98/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://pigkillermaster.github.io" target="_blank">浮泛之舟</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/OS%E7%90%86%E8%AE%BA/">OS理论</a></div><div class="post_share"><div class="social-share" data-image="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403252018445.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2024/03/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%90%86%E8%AE%BA-%E5%90%AF%E5%8A%A8/" title="操作系统-理论-启动"><img class="cover" src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403252018445.png" onerror="onerror=null;src='https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202309212200810.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">操作系统-理论-启动</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/03/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%90%86%E8%AE%BA-%E5%90%AF%E5%8A%A8/" title="操作系统-理论-启动"><img class="cover" src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403252018445.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-25</div><div class="title">操作系统-理论-启动</div></div></a></div><div><a href="/2024/03/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%90%86%E8%AE%BA-%E5%BC%95%E8%AE%BA/" title="操作系统-理论-引论"><img class="cover" src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403252018445.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-25</div><div class="title">操作系统-理论-引论</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">存储</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E7%BB%84%E7%BB%87"><span class="toc-number">1.1.</span> <span class="toc-text">存储组织</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="toc-number">1.2.</span> <span class="toc-text">存储管理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">编译、链接、装入</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#gcc%E7%9A%84%E5%B7%A5%E4%BD%9C"><span class="toc-number">2.1.</span> <span class="toc-text">gcc的工作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6"><span class="toc-number">2.2.</span> <span class="toc-text">可执行文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E5%88%92%E5%88%86"><span class="toc-number">2.2.1.</span> <span class="toc-text">具体划分</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E5%AE%9A%E4%BD%8D"><span class="toc-number">2.3.</span> <span class="toc-text">重定位</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F"><span class="toc-number">2.4.</span> <span class="toc-text">程序</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">存储管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%88%86%E9%85%8D"><span class="toc-number">3.1.</span> <span class="toc-text">存储分配</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E9%81%93%E7%A8%8B%E5%BA%8F"><span class="toc-number">3.1.1.</span> <span class="toc-text">单道程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F"><span class="toc-number">3.1.2.</span> <span class="toc-text">多道程序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%8C%BA%E6%96%B9%E5%BC%8F"><span class="toc-number">3.1.2.1.</span> <span class="toc-text">分区方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%BA%E5%AE%9A%E5%BC%8F%E5%88%86%E5%8C%BA"><span class="toc-number">3.1.2.1.1.</span> <span class="toc-text">固定式分区</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%BC%8F%E5%88%86%E5%8C%BA"><span class="toc-number">3.1.2.1.2.</span> <span class="toc-text">可变式分区</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%B2%E7%BD%AE%E7%A9%BA%E9%97%B4%E7%9A%84%E7%AE%A1%E7%90%86"><span class="toc-number">3.2.</span> <span class="toc-text">闲置空间的管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%88%86%E5%8C%BA%E7%9A%84%E7%AE%A1%E7%90%86"><span class="toc-number">3.2.1.</span> <span class="toc-text">可变分区的管理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98"><span class="toc-number">3.3.</span> <span class="toc-text">分配内存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E9%A1%BA%E5%BA%8F%E6%90%9C%E7%B4%A2%E7%9A%84%E5%88%86%E9%85%8D%E6%96%B9%E6%B3%95"><span class="toc-number">3.3.1.</span> <span class="toc-text">基于顺序搜索的分配方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E7%B4%A2%E5%BC%95%E6%90%9C%E7%B4%A2%E7%9A%84%E5%88%86%E9%85%8D%E6%96%B9%E6%B3%95"><span class="toc-number">3.3.2.</span> <span class="toc-text">基于索引搜索的分配方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95"><span class="toc-number">3.3.2.1.</span> <span class="toc-text">快速适应算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%99%E4%BC%B4%E7%B3%BB%E7%BB%9F"><span class="toc-number">3.3.2.2.</span> <span class="toc-text">伙伴系统</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E7%A2%8E%E7%89%87"><span class="toc-number">3.4.</span> <span class="toc-text">系统中的碎片</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A7%E5%87%91%E6%8A%80%E6%9C%AF"><span class="toc-number">3.4.1.</span> <span class="toc-text">紧凑技术</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D"><span class="toc-number">3.4.2.</span> <span class="toc-text">多重分区分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%8C%BA%E7%9A%84%E5%AD%98%E5%82%A8%E4%BF%9D%E6%8A%A4"><span class="toc-number">3.4.3.</span> <span class="toc-text">分区的存储保护</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E5%92%8C%E8%A6%86%E7%9B%96"><span class="toc-number">3.5.</span> <span class="toc-text">交换和覆盖</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%86%E7%9B%96"><span class="toc-number">3.5.1.</span> <span class="toc-text">覆盖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2"><span class="toc-number">3.5.2.</span> <span class="toc-text">交换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2VS%E8%A6%86%E7%9B%96"><span class="toc-number">3.5.3.</span> <span class="toc-text">交换VS覆盖</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">程序、进程和作业</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F-2"><span class="toc-number">4.1.</span> <span class="toc-text">程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B"><span class="toc-number">4.2.</span> <span class="toc-text">进程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F-%E8%A1%8C%E4%B8%BA%E5%9C%A8%E5%B9%B6%E8%A1%8C%E7%A8%8B%E5%BA%8F%E4%B8%AD%E6%98%AF%E6%80%8E%E4%B9%88%E5%AD%98%E5%82%A8%E7%9A%84"><span class="toc-number">4.2.1.</span> <span class="toc-text">程序&#x2F;行为在并行程序中是怎么存储的</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E4%B8%9A"><span class="toc-number">4.3.</span> <span class="toc-text">作业</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">页式内存管理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">段式存储管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="toc-number">6.1.</span> <span class="toc-text">段页式存储</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text">虚拟内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5"><span class="toc-number">7.1.</span> <span class="toc-text">请求分页</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2024 By pigKiller</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">你终会看到，你的歌声和旗帜在飘扬</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script></div><script src="f12.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>