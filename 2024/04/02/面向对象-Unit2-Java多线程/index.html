<!DOCTYPE html><html lang="zh-CN" data-theme="light"><script>((function() {var callbacks = [],timeLimit = 50,open = false;setInterval(loop, 1);return {addListener: function(fn) {callbacks.push(fn);},cancleListenr: function(fn) {callbacks = callbacks.filter(function(v) {return v !== fn;});}}
function loop() {var startTime = new Date();debugger;if (new Date() - startTime > timeLimit) {if (!open) {callbacks.forEach(function(fn) {fn.call(null);});}open = true;window.stop();alert('你真坏，请关闭控制台！');document.body.innerHTML = "";} else {open = false;}}})()).addListener(function() {window.location.reload();});</script><script>function toDevtools(){
  let num = 0; 
  let devtools = new Date();
  devtools.toString = function() {
    num++;
    if (num > 1) {
        alert('你真坏，请关闭控制台！')
        window.location.href = "about:blank"
        blast();
    }
  }
  console.log('', devtools);
}
toDevtools();</script><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>面向对象-Unit2-Java多线程 | 浮泛之舟</title><meta name="author" content="pigKiller"><meta name="copyright" content="pigKiller"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="进程和线程 Java语言内置了多线程支持：一个Java程序实际上是一个JVM进程，JVM进程用一个主线程来执行main()方法，在main()方法内部，我们又可以启动多个线程。此外，JVM还有负责垃圾回收的其他工作线程等。 因此，对于大多数Java程序来说，我们说多任务，实际上是说如何使用多线程实现多任务。 和单线程相比，多线程编程的特点在于：多线程经常需要读写共享数据，并且需要同步。 多线程并发">
<meta property="og:type" content="article">
<meta property="og:title" content="面向对象-Unit2-Java多线程">
<meta property="og:url" content="https://zhhangbian.github.io/2024/04/02/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-Unit2-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/index.html">
<meta property="og:site_name" content="浮泛之舟">
<meta property="og:description" content="进程和线程 Java语言内置了多线程支持：一个Java程序实际上是一个JVM进程，JVM进程用一个主线程来执行main()方法，在main()方法内部，我们又可以启动多个线程。此外，JVM还有负责垃圾回收的其他工作线程等。 因此，对于大多数Java程序来说，我们说多任务，实际上是说如何使用多线程实现多任务。 和单线程相比，多线程编程的特点在于：多线程经常需要读写共享数据，并且需要同步。 多线程并发">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202404022351911.png">
<meta property="article:published_time" content="2024-04-02T15:48:28.000Z">
<meta property="article:modified_time" content="2024-04-02T15:52:16.466Z">
<meta property="article:author" content="pigKiller">
<meta property="article:tag" content="OO补充">
<meta property="article:tag" content="Java多线程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202404022351911.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://zhhangbian.github.io/2024/04/02/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-Unit2-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '面向对象-Unit2-Java多线程',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2024-04-02 23:52:16'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202307102227559.png" onerror="onerror=null;src='https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202309212200810.jpg'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">49</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">35</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">21</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-categories"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202404022351911.png')"><nav id="nav"><span id="blog-info"><a href="/" title="浮泛之舟"><span class="site-name">浮泛之舟</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-categories"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">面向对象-Unit2-Java多线程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-04-02T15:48:28.000Z" title="发表于 2024-04-02 23:48:28">2024-04-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-04-02T15:52:16.466Z" title="更新于 2024-04-02 23:52:16">2024-04-02</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">面向对象</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">12.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>39分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="面向对象-Unit2-Java多线程"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>进程和线程</h1>
<p>Java语言内置了多线程支持：一个Java程序实际上是一个JVM进程，JVM进程用一个主线程来执行<code>main()</code>方法，在<code>main()</code>方法内部，我们又可以启动多个线程。此外，JVM还有负责垃圾回收的其他工作线程等。</p>
<p>因此，对于大多数Java程序来说，我们说多任务，实际上是说如何使用多线程实现多任务。</p>
<p>和单线程相比，多线程编程的特点在于：多线程经常需要读写共享数据，并且需要同步。</p>
<p>多线程并发的法宝：<strong>外互斥</strong>、<strong>内可见</strong></p>
<h2 id="内存模型">内存模型</h2>
<p>每个进程会把虚拟内存空间分成4个段(代码段, 数据端，堆，栈)</p>
<p>代码段：用来存放进程(应用App)的代码指令。</p>
<p>数据端：用来存放全局变量的内存。</p>
<p><strong>堆</strong>：调用os的malloc/free 来动态分配的内存。</p>
<p><strong>栈</strong>：用来存放局部变量，函数参数，函数调用与跳转。</p>
<p>每个进程(应用App)相当于一个容器，所有应用App里面需要的资源和机制都在进程里面。</p>
<p>线程是OS独立调度执行的单元，<strong>OS调度执行的单位就是线程</strong>，线程需要以进程作为容器和使用进程相关的环境。</p>
<img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403252029430.webp" alt="img" style="zoom:80%;" />
<p>每个线程<strong>共享进程的代码段内存空间</strong>，所以我们编写多线程代码的时候，可以在任何线程调用<strong>任何函数</strong>。</p>
<p>每个线程<strong>共享进程的数据段内存空间</strong>，所以我们编写多线程代码的时候，可以在任何线程访问<strong>全局变量</strong>。</p>
<p>每个线程<strong>共享进程的</strong>堆，所以我们编写多线程代码的时候，可以在一个线程访问另外一个线程new/malloc出来的<strong>内存对象</strong>。</p>
<p>每个线程都<strong>有自己的栈的空间</strong>，所以可以<strong>独立调用执行函数</strong>（参数，局部变量，函数跳转）相互之间不受影响。</p>
<blockquote>
<p>并行程序中函数是以怎样形式存在、怎样执行，其实是一个关键的问题</p>
</blockquote>
<h2 id="OS调度">OS调度</h2>
<p>CPU有几个核心，就可以<strong>真正并行地</strong>执行几个<strong>线程</strong>。OS的功能就是要在合适的时候分配CPU核心来调度合适的线程。</p>
<p>OS会根据线程的优先级分配每次调度最多执行的时间片，这个时间一到，无论如何都要重新调度一次线程。</p>
<p>除了时间片以外，线程会等待某些条件（磁盘读取文件，网卡发送完数据，线程休眠， 等待用户操作）这样也会把这个线程挂起，OS会重新找一个新的线程继续执行，只到挂起的这个线程的条件满足了，重新把这个线程放到可调度队列里面，这个线程又有机会被OS调度CPU核心来执行。</p>
<p>每个线程都会有一个运行时的环境</p>
<ul>
<li>运行时CPU的每个寄存器的值、栈独立。</li>
<li>栈的内存数据不会变。</li>
<li>数据段、堆共用，可能调度回来会变</li>
</ul>
<p>当OS要把某个CPU核心调度出去给其它线程的时候，首先会<strong>把当前线程的运行环境（寄存器的值等）保存到内存</strong>，然后调度到其它线程，等再次调度回来的时候，再把原来保存到内存的寄存器的值，再设置会CPU核心的寄存器里面，这样就回到了调度出去之前的进度。</p>
<p>因为<strong>多线程之间共用了代码段</strong>（代码段只读，不会改），<strong>数据段</strong>(全局变量调度回来后，可能被其它线程篡改，不是调度之前的那个值了)，<strong>堆</strong>(调度回来后，动态内存分配的对象内存数据可能被其它线程出篡改)，调度回来后，栈上的数据是不变的，因为每个线程都有自己的栈空间。线程调度前后哪些会变，哪些不变你要清楚。这样你写多线程代码的时候才能清晰。</p>
<p>线程调度的开销就是：保存上下文执行环境，内核态运行算法决定接下来调度那个线程，切换这个线程的上下文环境。</p>
<h3 id="多线程的顺序">多线程的顺序</h3>
<p>操作系统会将CPU资源切分为若干个时间片，采用时间片轮转的方法将时间片分给线程，线程分配到时间片后在CPU上运行，没有分配到时停滞。</p>
<p>通俗来讲，线程A在CPU上执行，其他线程停滞。到点以后（时间片结束）就轮到另一个线程B在CPU上执行，B以外的线程都停滞。以单核CPU为例，由于时间片通常很小，尽管同一时间只会有一个线程在运行，但因为运行线程“换的太快”，宏观上却感觉多个线程在同时执行。</p>
<p>对于单线程程序（顺序执行），程序的执行主体只有一个，它的执行顺序是确定的，且程序的运行结果也一定是确定的，不管运行多少次只要输入一样，输出结果一定相同。</p>
<p>多个线程组成的程序就是多线程程序，有多个执行程序的主体，<strong>各个线程的执行相对独立（并发执行）</strong>。</p>
<p><strong>时间片相对于程序员透明</strong>（我们并不能知晓一个线程执行到某个确定的地方时，另一个线程执行到了哪里），各个线程的相对执行顺序不确定，运行结果也可能随之不确定。</p>
<h1>Java内存模型</h1>
<h2 id="JMM">JMM</h2>
<p>Java线程间的通信由Java内存模型(JMM)控制，J<strong>MM决定一个线程对共享变量的写入何时以及如何变成对另一个线程可见</strong>。</p>
<p>JMM是一个<strong>抽象的概念</strong>，并非真实存在，它<strong>涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器的优化</strong></p>
<p>JMM定义了线程和主内存之间的抽象关系：</p>
<ul>
<li>
<p>线程之间的共享变量存储在主内存中（从硬件角度来说就是内存条）</p>
</li>
<li>
<p>每个线程都有一个私有的本地内存，本地内存中存储了该线程用来读/写共享变量的副本（从硬件角度来说就是CPU的缓存，比如寄存器、L1、L2、L3缓存等）</p>
</li>
<li>
<p>同时JVM通过JMM来屏蔽各个硬件平台和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果</p>
</li>
<li>
<p><strong>重要声明：</strong> JMM所描述的主内存、工作内存与Java内存区域的堆栈不是一回事，更准确是主内存就是内存条，为了提高性能，JVM可能会让工作内存优先存储在寄存器和高速缓存中，程序运行时主要访问读写的也是工作内存</p>
</li>
</ul>
<p>JMM的关键技术点都是围绕多线程的<strong>原子性</strong>、<strong>可见性</strong>和<strong>有序性</strong>展开的</p>
<ul>
<li>原子性：一个操作是不可中断的，即多线程环境下，操作不能被其他线程干扰</li>
<li>可见性：当一个线程修改了某一个共享变量的值，其他线程是否能够立即知道该变更
<ul>
<li>Java中普通的共享变量不保证可见性，因为其的修改被写入内存的时机是不确定的，<strong>多线程并发下很可能出现&quot;脏读&quot;</strong></li>
<li>缓存优化或者硬件优化或<strong>指令重排以及编辑器的优化</strong>都可能导致一个线程修改不会立即被其他线程察觉</li>
<li>Java提供<code>volatile</code>保证可见性：<strong>写操作立即刷新到主内存，读操作直接从主内存读取</strong></li>
<li>Java同时还<strong>可以通过加锁的同步性间接保证可见性</strong>：<code>synchronized</code>和<code>Lock</code>能保证同一时刻只有一个线程获取锁并执行同步代码，并在释放锁之后将变量的修改刷新到主内存中</li>
</ul>
</li>
<li>有序性：
<ul>
<li>对于一个线程的执行代码而言，我们总是习惯性认为代码的执行总是从上到下，有序执行。但为了提供性能，<strong>编译器和处理器通常会对指令序列进行重新排序</strong></li>
<li>指令重排可以保证串行语义一致，但没有义务保证多线程间的语义也一致，即可能产生&quot;脏读&quot;</li>
</ul>
</li>
</ul>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202404011519118.jpeg" alt="JMM"></p>
<h2 id="可见性保证">可见性保证</h2>
<ul>
<li><strong>正确同步的多线程程序：</strong> 将顺序一致性，JMM通过<strong>限制重排序</strong>来为程序提供内存可见性保证</li>
<li><strong>未同步/未正确同步的多线程程序：</strong> JMM提供最小安全性保障-线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值</li>
</ul>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202404011523157.png" alt="JMM可见性"></p>
<h2 id="重排序">重排序</h2>
<p><strong>写后写、写后读、读后写</strong>均存在相关数据依赖，不允许重排序</p>
<ul>
<li>**数据依赖性：**若两个操作访问同一变量，且这两个操作中有一个为写操作，此时两操作间就存在数据依赖性</li>
<li>编译器和处理器在重排序时，会遵守数据依赖性，不会改变存在依赖关系的两个操作的执行</li>
<li>但不同处理器和<strong>不同线程之间的数据性</strong>不会被编译器和处理器考虑，其只会作用于单处理器和单线程环境</li>
</ul>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202404011525317.png" alt="重排序"></p>
<h1>Java多线程</h1>
<p>Java的多线程编程不能像C、Cuda计算中那样精细地手动掌控线程、内存的运行，而是由Java虚拟机和OS进行自动调控。在Java多线程编程中，能做的、需要做的就是宏观地开启线程、对资源进行互斥和共享判断，其余地由OS自动完成。</p>
<h2 id="基本函数">基本函数</h2>
<p>封装好了Thread类，只要向其中送入需要执行的参数即可。</p>
<p>基本路线：</p>
<ol>
<li>创建子类：创建一个新的类，该类继承自Thread类</li>
<li>重写<code>run()</code>方法：在子类中重写Thread类的<code>run()</code>方法，该方法定义了线程的执行任务。</li>
<li>实例化子类对象：创建子类的对象，即<strong>线程对象</strong>。</li>
<li>调用<code>start()</code>方法：调用线程对象的<code>start()</code>方法，启动新线程，新线程会执行<code>run()</code>方法，从<code>run()</code>方法退出后被回收。</li>
<li>线程执行：一旦调用<code>start()</code>方法，线程会被加入到线程调度器中，等待分配CPU资源，当线程获得CPU资源时，就会执行其run()方法中定义的任务。</li>
</ol>
<p><code>run()</code>方法只是<strong>主线程调用了一个Test对象的public方法</strong>，执行这个方法的仍然是主线程，并<strong>没有产生新的线程</strong></p>
<p><code>start()</code>方法却是<strong>新创建了一个线程来执行对应的<code>run()</code>方法</strong>，原来的线程继续向下执行。</p>
<p>直接调用<code>run()</code>方法是无效的，相当于调用了一个对象的方法，并没有创建真正的线程。只有采用<code>start()</code>方法，才会创建一个线程，继而自动调用<code>run()</code>方法</p>
<h3 id="创建线程">创建线程</h3>
<p>创建线程的几种方式：</p>
<ol>
<li>
<p>继承Thread类，重写<code>run()</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        t.start(); <span class="comment">// 启动新线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start new thread!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>创建<code>Thread</code>实例时，传入一个<code>Runnable</code>实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">        t.start(); <span class="comment">// 启动新线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start new thread!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以使用Lamba语法进行简写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;start new thread!&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start(); <span class="comment">// 启动新线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>实现Runnable接口</p>
</li>
</ol>
<h3 id="线程优先级">线程优先级</h3>
<p>JVM自动把1（低）~10（高）的优先级映射到操作系统实际优先级上（不同操作系统有不同的优先级数量）。</p>
<p>优先级高的线程被操作系统调度的优先级较高，操作系统对高优先级线程可能调度更频繁，但<strong>决不能通过设置优先级来确保高优先级的线程一定会先执行</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread.setPriority(<span class="type">int</span> n) <span class="comment">// 1~10, 默认值5</span></span><br></pre></td></tr></table></figure>
<h2 id="资源竞争">资源竞争</h2>
<p><strong>原子性</strong>：一个操作或者多个操作，要么全部执行并且执行的过程不会被其他线程打断，要么就都不执行。</p>
<p>实现一组操作序列的原子性需要进行<strong>线程互斥</strong>（mutual exclusion）：如果某一个线程正在对<strong>共享对象</strong>执行某种操作，那么其他所有线程都<strong>不能</strong>进行对该共享对象执行某种操作。</p>
<h3 id="线程的状态">线程的状态</h3>
<p>一个线程对象只能调用一次<code>start()</code>方法启动新线程，并在新线程中执行<code>run()</code>方法。<strong>一旦<code>run()</code>方法执行完毕，线程就结束了。</strong></p>
<p>Java种线程的状态共有6种。</p>
<img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403252123267.webp" alt="图片" style="zoom:50%;" />
<ol>
<li>
<p><strong>初始(NEW)</strong>：新创建了一个线程对象，但还没有调用start()方法。</p>
</li>
<li>
<p><strong>运行(RUNNABLE)</strong>：将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。</p>
<ol>
<li>就绪：线程对象创建后位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。</li>
<li>运行种：就绪状态的线程在<strong>获得CPU时间片后</strong>变为运行中状态（running）。</li>
</ol>
</li>
<li>
<p><strong>阻塞(BLOCKED)</strong>：表示线程阻塞于锁。</p>
<p>阻塞状态是线程阻塞在进入synchronized关键字修饰的方法或代码块(获取锁)时的状态。</p>
</li>
<li>
<p><strong>等待(WAITING)</strong>：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。</p>
<p>处于这种状态的线程不会被分配CPU执行时间，它们要<strong>等待被显式地唤醒</strong>，否则会处于无限期等待的状态。</p>
</li>
<li>
<p><strong>超时等待(TIMED_WAITING)</strong>：该状态不同于WAITING，它可以在<strong>指定的时间后自行返回</strong>。</p>
</li>
<li>
<p><strong>终止(TERMINATED)</strong>：表示该线程已经执行完毕。</p>
</li>
</ol>
<img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403252121790.png" alt="image-20240325212102679" style="zoom: 50%;" />
<h3 id="进程的阻塞">进程的阻塞</h3>
<p>有些进程的执行是有相对的先后顺序的，需要一个函数执行结束后再执行另一个，这个是否就可以使用<code>join()</code>来对线程进行阻塞。</p>
<p><code>thread.join()</code>：阻塞，在该线程执行结束前不开启别的线程。通过对另一个线程对象调用<code>join()</code>方法可以<strong>等待其执行结束</strong>；可以指定等待时间，超过等待时间线程仍然没有结束就不再等待；</p>
<p>对已经运行结束的线程调用<code>join()</code>方法会立刻返回。</p>
<p><code>join</code> 方法的基本用法如下：</p>
<ol>
<li>
<p><strong>单个线程的 <code>join</code> 方法</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 线程执行的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">thread.start(); <span class="comment">// 启动线程</span></span><br><span class="line">thread.join(); <span class="comment">// 等待线程结束</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，主线程启动了一个新线程，并通过调用 <code>join</code> 方法等待新线程完成。如果新线程还没有结束，主线程将被阻塞，直到新线程执行完毕。</p>
</li>
<li>
<p><strong>多个线程的 <code>join</code> 方法</strong>： 如果你有多个线程，并且希望主线程等待所有这些线程都完成，你可以对每个线程调用 <code>join</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(...);</span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(...);</span><br><span class="line"></span><br><span class="line">thread1.start();</span><br><span class="line">thread2.start();</span><br><span class="line"></span><br><span class="line">thread1.join();</span><br><span class="line">thread2.join();</span><br></pre></td></tr></table></figure>
<p>在这个例子中，主线程等待 <code>thread1</code> 和 <code>thread2</code> 都执行完毕后才继续执行。</p>
<p><code>thread1</code> 和 <code>thread2</code> 是并行执行的，而不是顺序执行。这意味着一旦 <code>thread1.start()</code> 和 <code>thread2.start()</code> 被调用，两个线程几乎同时开始执行它们的任务（由操作系统的线程调度器控制）。每个线程的执行是独立的，并且它们的完成顺序是不确定的，这取决于它们各自的任务内容、执行时间以及系统资源等。</p>
<p><code>join</code> 方法在这里用于同步线程，确保主线程（执行这段代码的线程）在继续执行之前等待 <code>thread1</code> 和 <code>thread2</code> 完成它们的执行。这意味着主线程会等待 <code>thread1</code> 完成，然后再等待 <code>thread2</code> 完成。这并不改变 <code>thread1</code> 和 <code>thread2</code> 并行执行的特性，而是确保了在它们完成之前，主线程不会执行 <code>join</code> 之后的代码。</p>
<p>由于CPU极快的运行速度，判断<code>join</code>函数几乎是并行完成的，不用纠结具体的先后，总体效果就是等待<code>thread1</code>和<code>thread2</code>运行结束</p>
</li>
<li>
<p><strong>带有超时的 <code>join</code> 方法</strong>： <code>join</code> 方法还有一个重载版本，允许你指定一个超时时间。如果在指定的时间内线程没有结束，调用线程将不再等待。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">timeout</span> <span class="operator">=</span> <span class="number">5000</span>; <span class="comment">// 5秒超时</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (thread1.isAlive()) &#123;</span><br><span class="line">    thread1.join(timeout);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (thread2.isAlive()) &#123;</span><br><span class="line">    thread2.join(timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，如果 <code>thread1</code> 或 <code>thread2</code> 在5秒内没有结束，主线程将不再等待它们。</p>
</li>
</ol>
<p><code>join</code> 方法是多线程同步的一个重要工具，它可以确保线程以一种可预测的方式协同工作。正确使用 <code>join</code> 方法可以避免常见的并发问题，如死锁和竞态条件。</p>
<h3 id="临界">临界</h3>
<p>对于多线程程序，我们有临界资源和临界区两个概念：</p>
<ol>
<li>临界资源：<strong>一次仅允许一个进程使用</strong>的<strong>共享资源</strong>。</li>
<li>临界区：每个进程中<strong>访问临界资源的那段程序</strong>称之为临界区。</li>
</ol>
<p>常<strong>利用锁的机制</strong>来<strong>实现线程对于共享资源的互斥访问</strong>，通过锁可以让一段临界区代码<strong>同时只能有一个线程运行</strong>，也就是使得<strong>临界区代码的执行具有原子性</strong>。</p>
<blockquote>
<p>资源是什么呢？</p>
<p>不要忘记Java是一门面向对象的语言，OO的目的也是面向对象，线程、锁面对的资源都是对象，获取的是<strong>对象的锁</strong>。</p>
<p>一个对象的方法种可以有很多个加上关键字synchronized，但是在实际的运行种，都是同一个锁，即这个对象的锁，看哪个线程能优先获得这个对象的执行权限。</p>
</blockquote>
<p>Java的锁有很多种，先介绍synchronized 关键字的一些用法。</p>
<p><strong>当使用synchronized修饰某段代码时，某段代码就具有原子性。</strong></p>
<p>Java中每个对象都<strong>与一个内置的锁关联</strong>，<strong>一个锁一次只能被一个线程持有</strong>（排他性）。获得锁的线程可以继续向下运行；</p>
<p>在持有锁的线程离开这段代码之前，任何程序由于无法获得锁而阻塞在这个锁的等待队列中</p>
<p>当持有锁的线程走出临界区后，会释放这个锁同时唤醒这个锁阻塞队列中的线程。<strong>抢夺到锁的线程</strong>可以运行临界区代码，而其他线程继续阻塞。</p>
<img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403252126137.webp" alt="图片" style="zoom:33%;" />
<h3 id="锁">锁</h3>
<p><code>synchronized</code> 是Java中的一个关键字，用于创建一个原子操作，确保同一时刻只有一个线程能够执行特定的代码块或者方法。<code>synchronized</code> 可以用于修饰方法或者代码块，它提供了一种内置的锁机制，用于控制对共享资源的并发访问。</p>
<ul>
<li>线程A释放一个锁，实质是线程A告知下一个获取到该锁的某个线程其已变<strong>更该共享变量</strong></li>
<li>线程B获取一个锁，实质是线程B得到了线程A告知其(在释放锁之前)变更共享变量的消息</li>
<li>线程A释放锁，随后线程B竞争到该锁，实质是线程A通过主内存向线程B发消息告知其变更了共享变量</li>
</ul>
<h4 id="修饰方法">修饰方法</h4>
<p>当在方法声明前使用 <code>synchronized</code> 关键字时，锁定的是<strong>当前对象的实例</strong>（面向对象中方法是依赖于对象的）（对于静态方法则是锁定的是这个类的所有对象）。任何时候，只有一个线程能够执行这个 <code>synchronized</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>increment</code> 和 <code>getCount</code> 方法都被声明为 <code>synchronized</code>，它们将对 <code>count</code> 变量的访问同步化。</p>
<p>这意味着，即使有多个线程同时调用 <code>increment</code> 方法，谁获取了Counter实例化后的对象，谁才能调用相关的方法，<code>count</code> 变量的增加操作也是原子的，线程安全的。</p>
<p>对于静态方法，<code>synchronized</code> 锁定的是类的Class对象。这意味着，对于非静态方法，每个对象都有自己的锁，而对于静态方法，所有线程共享同一个锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticCounter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="修饰代码块">修饰代码块</h5>
<p><code>synchronized</code> 也可以用于修饰一个代码块，这样可以更精细地控制哪些代码需要同步。在代码块中，<strong>需要明确指定一个锁对象</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlockCounter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 手动创建一个锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 这里可以有一些操作，实现更精细的控制</span></span><br><span class="line">        <span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 这里可以有一些操作，实现更精细的控制</span></span><br><span class="line">        <span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>lock</code> 对象被用作同步锁。<code>increment</code> 和 <code>getCount</code> 方法中的代码块只有在获得 <code>lock</code> 对象的锁时才会执行。这种方式比同步整个方法更加灵活，因为它<strong>允许在同步代码块之外执行一些不需要同步的操作</strong>。</p>
<h4 id="等待-通知机制">等待/通知机制</h4>
<p><code>synchronized</code> 关键字还提供了等待（<code>wait</code>）、通知（<code>notify</code>）和通知所有（<code>notifyAll</code>）方法，这些方法用于线程间的协作。</p>
<p>等待/通知机制涉及以下三个方法：</p>
<ol>
<li><code>wait()</code>：当前线程调用 <code>wait()</code> 方法后，它会释放对象的监视器锁（即让出锁），然后<strong>进入等待队列</strong>。线程会一直等待，直到被其他线程通过 <code>notify()</code> 或 <code>notifyAll()</code> 方法唤醒。</li>
<li><code>notify()</code>：当一个线程调用 <code>notify()</code> 方法时，它会<strong>随机选择等待队列中的一个线程</strong>，并将其唤醒，使其尝试重新获取对象的监视器锁。如果没有线程在等待，<code>notify()</code> 方法没有任何效果。</li>
<li><code>notifyAll()</code>：这个方法会唤醒等待队列中的所有线程，让它们尝试重新获取对象的监视器锁。至于哪个线程能抢到锁，这说不准。</li>
</ol>
<p>这些方法<strong>必须在 <code>synchronized</code> 代码块或方法中调用</strong>，因为它们需要获取当前线程所持有的监视器锁。以下是等待/通知机制的一个简单示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            lock.notifyAll(); <span class="comment">// 唤醒所有等待的线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>) &#123; <span class="comment">// 如果计数为0，则等待</span></span><br><span class="line">                lock.wait();	</span><br><span class="line">            &#125;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>increment</code> 方法增加计数，并通过 <code>notifyAll()</code> 唤醒所有等待的线程。<code>decrement</code> 方法检查计数是否为0，如果是，则调用 <code>wait()</code> 方法等待。当 <code>increment</code> 方法执行并增加计数时，它会唤醒所有等待的 <code>decrement</code> 线程。</p>
<p>使用等待/通知机制时，需要注意以下几点：</p>
<ul>
<li>调用 <code>wait()</code>、<code>notify()</code> 和 <code>notifyAll()</code> 的线程<strong>必须持有对象的监视器锁</strong>。</li>
<li><code>wait()</code> 方法会使线程放弃锁并进入等待状态，直到被 <code>notify()</code> 或 <code>notifyAll()</code> 唤醒。</li>
<li><code>notify()</code> 只会随机唤醒一个等待的线程，而 <code>notifyAll()</code> 会唤醒所有等待的线程。</li>
<li>为了避免虚假唤醒（spurious wakeup），通常在 <code>while</code> 循环中使用 <code>wait()</code> 方法，并检查唤醒条件。</li>
<li><code>InterruptedException</code> 可能会在 <code>wait()</code>、<code>notify()</code> 或 <code>notifyAll()</code> 调用中抛出，需要妥善处理这个异常。</li>
</ul>
<p>等待/通知机制是实现线程间协作的有效方式，特别是在需要等待某些条件成立时。然而，它也需要仔细设计，以避免死锁、活锁和资源饥饿等问题。</p>
<h4 id="不需要同步">不需要同步</h4>
<p>JVM规范定义了几种原子操作：</p>
<ul>
<li>基本类型（<code>long</code>和<code>double</code>除外）赋值，例如：<code>int n = m</code>；</li>
<li>引用类型赋值，例如：<code>List&lt;String&gt; list = anotherList</code>。</li>
</ul>
<p><code>long</code>和<code>double</code>是64位数据，JVM没有明确规定64位赋值操作是不是一个原子操作，不过在x64平台的JVM是把<code>long</code>和<code>double</code>的赋值作为原子操作实现的。</p>
<p>单条原子操作的语句不需要同步。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> m)</span> &#123;</span><br><span class="line">    <span class="comment">// 基本类型，原子操作，不需要</span></span><br><span class="line">    <span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="comment">// 引用赋值，不需要</span></span><br><span class="line">    <span class="built_in">this</span>.value = s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果多线程读写的是一个<strong>不可变对象</strong>，那么无需同步，因为不会修改对象的状态：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span> &#123;</span><br><span class="line">    List&lt;String&gt; names;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String[] names)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.names = List.of(names);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    List&lt;String&gt; <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.names;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到<code>set()</code>方法内部创建了一个不可变<code>List</code>，这个<code>List</code>包含的对象也是不可变对象<code>String</code>，因此，整个<code>List&lt;String&gt;</code>对象都是<strong>不可变</strong>的，因此读写均无需同步。</p>
<h4 id="可重入锁">可重入锁</h4>
<p>当一个线程获得锁后，如果需要继续调用相关函数，可一直持有锁。</p>
<p><strong>隐患：<strong>由于在JVM中具有String常量池缓存的功能，因此</strong>相同字面量是同一个锁！！！</strong></p>
<h4 id="死锁">死锁</h4>
<p>当线程间需要<strong>相互等待对方已持有的锁</strong>时，就形成死锁，进而产生死循环</p>
<p>一个线程可以获取一个锁后，再继续获取另一个锁。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> m)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(lockA) &#123; <span class="comment">// 获得lockA的锁</span></span><br><span class="line">        <span class="built_in">this</span>.value += m;</span><br><span class="line">        <span class="keyword">synchronized</span>(lockB) &#123; <span class="comment">// 获得lockB的锁</span></span><br><span class="line">            <span class="built_in">this</span>.another += m;</span><br><span class="line">        &#125; <span class="comment">// 释放lockB的锁</span></span><br><span class="line">    &#125; <span class="comment">// 释放lockA的锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dec</span><span class="params">(<span class="type">int</span> m)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(lockB) &#123; <span class="comment">// 获得lockB的锁</span></span><br><span class="line">        <span class="built_in">this</span>.another -= m;</span><br><span class="line">        <span class="keyword">synchronized</span>(lockA) &#123; <span class="comment">// 获得lockA的锁</span></span><br><span class="line">            <span class="built_in">this</span>.value -= m;</span><br><span class="line">        &#125; <span class="comment">// 释放lockA的锁</span></span><br><span class="line">    &#125; <span class="comment">// 释放lockB的锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在获取多个锁的时候，不同线程获取多个不同对象的锁可能导致死锁。对于上述代码，线程1和线程2如果分别执行<code>add()</code>和<code>dec()</code>方法时：</p>
<ul>
<li>线程1：进入<code>add()</code>，获得<code>lockA</code>；</li>
<li>线程2：进入<code>dec()</code>，获得<code>lockB</code>。</li>
</ul>
<p>随后：</p>
<ul>
<li>线程1：准备获得<code>lockB</code>，失败，等待中；</li>
<li>线程2：准备获得<code>lockA</code>，失败，等待中。</li>
</ul>
<p>此时，两个线程各自持有不同的锁，然后各自试图获取对方手里的锁，造成了双方无限等待下去，这就是死锁。</p>
<p>死锁发生后，没有任何机制能解除死锁，只能强制结束JVM进程。</p>
<p>因此，在编写多线程应用时，要特别注意防止死锁。因为死锁一旦形成，就只能强制结束进程。</p>
<p>那么我们应该如何避免死锁呢？答案是：线程获取锁的顺序要一致。即严格按照先获取<code>lockA</code>，再获取<code>lockB</code>的顺序。</p>
<h2 id="资源共享">资源共享</h2>
<p><strong>锁获取与volatile读有相同的内存语义</strong>。线程间共享变量需要使用<code>volatile</code>关键字标记，确保每个线程都能读取到更新后的变量值。</p>
<p><strong>volatile本身并不保证原子性！！！</strong></p>
<p>在Java虚拟机中，变量的值保存在主内存中。但是，当线程访问变量时，它会先获取一个副本，并保存在自己的工作内存中。如果线程修改了变量的值，虚拟机会在某个时刻把修改后的值回写到主内存，但是<strong>JVM虚拟机将数据写回时间是不确定的</strong>！这会导致<strong>如果一个线程更新了某个变量，另一个线程读取的值可能还是更新前的</strong>。</p>
<p>因此，<code>volatile</code>关键字的目的是告诉虚拟机：</p>
<ul>
<li>每次访问变量时，总是获取主内存的最新值；</li>
<li>每次修改变量后，立刻回写到主内存。</li>
</ul>
<p><code>volatile</code>关键字解决的是<strong>可见性问题</strong>：当一个线程修改了某个共享变量的值，其他线程能够立刻看到修改后的值。</p>
<p><code>volatile</code>是线程同步的轻量级实现，主要作用是<strong>使变量在多线程间可见</strong>，<strong>本身并不处理数据的原子性</strong>，而是强制对数据的读写及时影响到主内存里。</p>
<p><code>volatile</code>会<strong>强制从公共堆栈中取得变量的值</strong>，而不是从线程私有数据栈中取的变量的值。</p>
<p><code>volatile</code>变量自身具有三个语义特性：</p>
<ul>
<li>**可见性：**保证了不同线程对这个变量进行操作时的可见性，即变量一旦变更所有线程立即可见</li>
<li>**有限原子性：**对任意单个volatile变量的简单读写操作具有原子性，<strong>复合操作不具有原子性</strong>（如i++）</li>
<li>**重排序禁止：**禁止进行指令重排序</li>
</ul>
<p>对于<code>volatile</code>修饰的变量：</p>
<ul>
<li>当写时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存</li>
<li>当读时，JMM会把该线程<strong>对应的本地内存置为无效</strong>，线程会<strong>直接从主内存中读取共享变量</strong>
<ul>
<li>此时实际上是线程间通过主内存完成了一次消息通信，即线程A向B发送消息</li>
</ul>
</li>
</ul>
<h3 id="volatile原理"><code>volatile</code>原理</h3>
<p>为了实现volatile内存语义，JMM会分别<strong>限制编译器重排序和处理器重排序</strong>。为了保证内存可见性，编译器会在生成指令序列的恰当位置插入<strong>内存屏障指令</strong>来禁止特定类型的处理器重排序。</p>
<p>实现原理是在指令序列执行过程中，通过在<code>volatile</code>写操作后面插入<code>StoreLoad</code>屏障（x86平台），仅对<code>volatile</code><strong>写-读进行重排序</strong>（x86会忽略读-读、读-写、写-写的重排序）从而<strong>实现正确的内存语义</strong>。</p>
<p><strong>从汇编角度来说</strong>，操作volatile变量会多出一个lock前缀指令，其相当于内存屏障。执行该屏障开销昂贵，因为处理器通常会把写缓冲区的数据全部刷新到内存中。</p>
<blockquote>
<p>为了保证各个CPU的缓存一致性，每个CPU通过嗅探在总线上传播的数据来检查自己的缓存的数据有效性，当发现自己缓存行对应的内存地址的数据被修改，就会将该缓存行设置为无效，当CPU读取该变量，发现所在的缓存行被设置为无效，就会重新从内存中读取数据到缓存中</p>
</blockquote>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202404011531610.png" alt="volatile原理"></p>
<h3 id="volatile使用"><code>volatile</code>使用</h3>
<ul>
<li><strong>适用场合：多个线程读，一个线程写的场合</strong></li>
<li>**使用场景：**通常被 <strong>作为标识完成、中断、状态的标记</strong>，值变化应具有原子性</li>
<li>**充分利用其可见性：**即volatile能够保证在读取的那个时刻读到的肯定是最新值</li>
<li><strong>重点声明：</strong> volatile主要使用的场合是在多线程中可以感知实例变量被变更了，并且可以获得最新的值使用，也就是用多线程读取共享变量时可以获得最新值使用，但不能保证你在使用最新值过程中最新值不发生变化！很可能在使用之后，最新值已经变更。原数据变成过期数据，这时候就会出现数据不一致（非同步）的问题</li>
</ul>
<h4 id="原子性操作">原子性操作</h4>
<p><strong>不进行操作则不保证原子性！！！</strong></p>
<ul>
<li>多线程环境下，&quot;数据计算&quot;和&quot;数据赋值&quot;操作可能多次出现，即操作非原子</li>
<li>若数据在加载之后，若主内存count变量发生修改之后，由于线程工作内存中的值在此前已经加载，从而不会对变更操作做出相应变化，即私有内存和公共内存中变量不同步，进而导致数据不一致</li>
<li>对于volatile变量，JVM只是保证从主内存加载到线程工作内存的值是最新的，也就是数据加载时是最新的。由此可见volatile解决的是变量读时的可见性问题，但无法保证原子性，对于多线程修改共享变量的场景必须使用加锁同步</li>
</ul>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202404011533790.jpeg" alt="变量在内存中的工作过程.jpg-299.8kB"></p>
<p>针对工作内存和主内存之间的原子性交互，JVM提供了如下原子性指令：</p>
<ul>
<li><strong>read:</strong> 作用于主内存，将变量的值从主内存传输到工作内存，即数据读取到本地内存</li>
<li><strong>load:</strong> 作用于工作内存，将read从主内存传输的变量值放入工作内存变量副本中，即数据加载</li>
<li><strong>use:</strong> 作用于工作内存，将工作内存变量副本的值传递给执行引擎，每当JVM遇到需要该变量的字节码指令时会执行该操作</li>
<li><strong>assign:</strong> 作用于工作内存，将从执行引擎接收到的值赋值给工作内存变量，每当JVM遇到一个给变量赋值字节码指令时会执行该操作</li>
<li><strong>store:</strong> 作用于工作内存，将赋值完毕的工作变量的值传输给主内存</li>
<li><strong>write:</strong> 作用于主内存，将store传输过来的变量值赋值给主内存中的变量</li>
</ul>
<p>由于上述只能保证单条指令的原子性，针对多条指令的组合性原子保证，JVM提供了另外两个原子指令：</p>
<ul>
<li><strong>lock:</strong> 作用于主内存，将一个变量标记为一个线程独占的状态</li>
<li><strong>unlock:</strong> 作用于主内存，把一个处于锁定状态的变量释放，然后才能被其他线程占用</li>
</ul>
<p>以上指令在使用时必须遵循如下规范：</p>
<ol>
<li>read-load、store-write必须搭配使用</li>
<li>不允许线程丢弃最近一次assign操作，一旦在工作内存改变后必须同步回主内存</li>
<li>不允许线程没执行assign操作就执行主内存同步操作</li>
<li>变量必须在主内存生成，执行assign的前提必须是执行了read-load-use</li>
<li>一个变量的同一时刻只允许被一个线程执行lock操作，允许lock被同一线程多次执行，但必须执行相同次数的unlock操作</li>
<li>执行lock操作必须清空所有工作内存该变量值，在执行引擎使用该变量时必须重新load或assign初始化该值</li>
<li>使用unlock必须先执行lock，且执行unlock前必须将此变量同步到主内存</li>
</ol>
<h1>Java函数式编程</h1>
<h2 id="一、函数式编程引入">一、函数式编程引入</h2>
<p>java比较痛苦的一点是要经常新建类，给他起名，写构造函数等等。</p>
<h3 id="匿名类">匿名类</h3>
<p>为了简化这种负担，java有<strong>匿名类</strong>的机制，可以省略掉这个外部类的定义。匿名类是一种特殊的类，它没有显式的名称，通常用于<strong>创建临时的、只需使用一次的类实例</strong>。匿名类通常被用于<strong>实现接口、抽象类或者作为方法参数</strong>。</p>
<p>匿名类的特点包括：</p>
<ol>
<li>没有显式的类名。</li>
<li>可以实现接口或继承自类，但不能同时实现多个接口或继承多个类。</li>
<li>通常用于简单的、一次性的类实例创建。</li>
<li>可以在方法内部、构造函数内部或者其他类的成员内部创建。</li>
</ol>
<h3 id="函数式编程">函数式编程</h3>
<p>有时候多方代码，真正有效的就一行输出语句。<strong>创建线程是为了执行某一个任务</strong>，任务也就是一个<strong>方法</strong>，那我们为何不<strong>直接传入一个方法</strong>呢？干脆把新建类也省去。</p>
<p>这就是函数式编程的一个核心概念，函数式编程的<strong>主要抽象</strong>是<strong>函数</strong>，函数是一等公民。</p>
<p>所谓的一等公民，指的是函数与其他数据类型一样，处于同等地位。函数可以在任何地方定义，在函数内或函数外，可以作为函数的参数和返回值，因此可以对函数进行组合。</p>
<p>放在这个代码里理解，就是这短短的一行函数，作了线程创建的参数，用到了Lambda函数。这是函数式编程和我们面向对象的世界中不一样的一种抽象。</p>
<h3 id="命令式编程">命令式编程</h3>
<p>下面我们再来看另一组编程范式。</p>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403260021057.png" alt="pic1"></p>
<p><strong>面向对象</strong>是一种典型的<strong>命令式编程</strong>，命令式编程是关于定义<strong>如何做</strong>。</p>
<p>怎么做，是一种<strong>面向硬件</strong>的抽象，程序员需要告诉机器每一步的实现过程。命令式程序有变量（对应着存储单元），赋值语句（获取，存储指令），表达式（内存引用和算术运算）和控制语句（跳转指令）。简单来说，命令式程序就是一个<strong>冯诺依曼机的指令序列</strong>。</p>
<h3 id="声明式编程">声明式编程</h3>
<p><strong>声明式编程</strong>的风格，是关于定义<strong>要做什么</strong>而不是如何做，更接近<strong>自然语言</strong>的接口。</p>
<p>同样的功能，声明式的代码不仅写起来起来更简洁，不需要看函数内部的实现细节就可以了解大意。比如这段这段声明式编程的代码只是说：我要<code>过滤(filter)</code> 一下这些店 构成的<code>流(stream)</code> , 只把那些销量大于<code>1000</code>的留下， 计算出个数就行了。</p>
<p>流式编程是一种典型的<strong>声明式编程</strong>，更接近自然语言接口，这一些函数调用返回一个结果给<code>count</code>变量，也规避了<code>count</code>自增前的初始化问题。</p>
<p>这也是函数式编程的另一个优势，不需要考虑过程量的副作用。</p>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403260025853.png" alt="pic1"></p>
<p>看这例子：两段代码都是先排序，然后返回第一项作为最近的店。区别在于上面的排序改变了这个表的顺序，按照距离由小到大排序。而<strong>流式编程的<code>sort</code>并未改变原数据。也就是</strong>函数执行没有副作用****。</p>
<p>第一个排序，跟下边的比起来也是唯一一个没有使用Lambda表达式的排序写法，它的<code>compartor接口</code>就需要在这个<strong>店铺的类</strong>里边<strong>继承接口</strong>，然后<strong>重写</strong><code>compareto方法</code>。</p>
<p>在排序的代码中，后面几种出现了 <code>-&gt;</code>、<code>::</code> 的，都用了lambda表达式实现<code>compartor</code>这个比较接口。</p>
<p>可以看到都是lambda函数，有的刷灰了意思是还可有更简化的写法。</p>
<p>我们可以对比集合排序的比较器接口的几种使用lambda函数实现的方法，从compartor接口的例子中了解lambda函数的语法。</p>
<h2 id="二、lambda函数">二、lambda函数</h2>
<p>这么多次OO作业肯定大家都用到过，尽管我们在作业中使用Lambda的场景并不是为了函数式编程，是使用新特性来让代码的书写更加优雅。</p>
<h3 id="Lambda表达式语法">Lambda表达式语法</h3>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403260025195.png" alt="pic1"></p>
<p>这张图使用了刚刚提到过的<code>runnable接口</code>的实现的例子。包括函数签名，这个标志着lambda函数的箭头，还有函数式编程中最重视的函数实现。</p>
<p>这三部分组成了Lambda表达式的完整结构，这一行就可以作为一个<code>runnable接口</code>变量。lambda表达式也可以向我们刚刚创建线程那样作为参数进行传递。</p>
<h4 id="函数签名">函数签名</h4>
<p>函数签名包括函数名、函数的返回值和传入参数。</p>
<p>刚刚提到了，lambda函数是匿名类的进一步简化。lambda的匿名性<strong>省略了函数名</strong>。同时它有一种更强大的省略特性，这种机制被允许的原因是<strong>java编译器的自动类型推断</strong>。</p>
<ul>
<li>返回值可以省略，可以从接口类型判断出返回值。</li>
<li>参数的类型，也可以被省略。</li>
<li>如果只有一个参数，可以省略括号。</li>
<li>把它存成 比较器接口变量，借助这个变量的<code>reverse方法</code>我们可以实现逆序。</li>
</ul>
<h4 id="函数主体">函数主体</h4>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403260025247.png" alt="pic1"></p>
<ul>
<li>
<p>主体只包含一个语句，可以省略大括号。刚刚的实现里，箭头后边都只有一条语句，没有大括号。</p>
</li>
<li>
<p>函数实现也可以语句块作为函数，这里除了比较距离，还比较了年龄这个参数，实现了多重条件的比较。</p>
<blockquote>
<p>函数实现比较复杂，下面介绍如何一步步化简省略定义这种多重条件的比较逻辑。</p>
<p>首先<code>::</code>这个符号，两个冒号，像C++的作用域解析运算符，是<strong>Java 8</strong>的一种更方便的<strong>方法引用</strong>。</p>
<p>我们可以通过使用这种实例方法的引用和<code>Comparator.comparing</code>方法来避免定义比较逻辑——它会自动提取和创建一个基于这个函数的<code>Comparable</code>。</p>
<p>这里看起来没有lambda表达式的结构，是怎么实现的接口呢？具体原因我们放在后边再展开讲。</p>
</blockquote>
</li>
</ul>
<h3 id="Lambda表达式的化简">Lambda表达式的化简</h3>
<p>总结一下刚刚逐步简化的Lambda表达式。它的作用是取代一个类，用来实现接口。</p>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403260025362.png" alt="pic1"></p>
<h3 id="函数式接口">函数式接口</h3>
<p>Lambda表达式的语法是什么支持的呢？这种实现的<strong>对象类型</strong>。再怎么函数式编程，也要在java面向对象的机制中扩展。表达式的类型是函数式接口。</p>
<p>只有一个接口函数需要被实现的接口类型，称为”函数式接口“。为了避免后来的人在这个接口中增加接口函数导致其有多个接口函数需要被实现，变成”非函数接口”，我们可以在这个上面加上一个声明<code>@FunctionalInterface</code>, 这样就无法在里面添加新的接口函数。</p>
<h3 id="函数式接口的前提条件">函数式接口的前提条件</h3>
<ul>
<li>
<p>使用Lambda必须具有接口，且要求<strong>接口中有且仅有一个抽象方法</strong>。</p>
<p>无论是JDK内置的Runnable、Comparator接口还是自定义的接口，只有当接口中的抽象方法存在且唯一时，才可以使用Lambda。</p>
</li>
<li>
<p>使用Lambda必须具有<strong>上下文推断</strong>。</p>
<p>也就是方法的参数或局部变量类型必须为Lambda对应的接口类型，才能使用Lambda作为该接口的实例。上文提到的依托java编译器的自动类型推断的省略机制要求上下文推断。</p>
</li>
</ul>
<h3 id="几种常见的函数式接口">几种常见的函数式接口</h3>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403260028455.png" alt="pic1"></p>
<ul>
<li><code>predicte</code>：推断出参数类型返回值类型，是用来判断真假的函数接口。 函数实现是一个布尔表达式。</li>
<li><code>BinaryOperator</code>：接收两个参数，返回一个值，返回值和参数的数据类型相同。体现一种映射关系，<code>x y -&gt;x+y</code>。</li>
<li><code>comparing</code>：上文提到的 “<code>comparing</code>没有lambda表达式的结构是怎么实现的接口？” 因为这个方法返回了一个函数式接口，使用<code>comparing()</code>的地方，也就是<code>sort()</code>的传入参数就是函数式接口function。<br>
<code>comparing()</code>的传入参数也是函数式接口function。<code>key::lambda</code>是对函数式接口的更一步简化。</li>
</ul>
<h3 id="集合的函数式接口">集合的函数式接口</h3>
<p>java集合框架也新增部分函数接口用于与Lambda表达式对接。</p>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403260025313.png" alt="pic1"></p>
<ul>
<li>作业中很常见，比如说removeif规避了for遍历删除的问题，这里的参数就是Prediect 函数式接口。</li>
<li>创建优先队列的构造参数，是一个比较器接口。</li>
<li>foreach遍历接受函数式接口做参数。</li>
<li>第四单元类重名的异常机制，可以借助这个merge方法，BinaryOperator接口作为重映射函数。</li>
</ul>
<h3 id="作业中使用lambda函数的优化">作业中使用lambda函数的优化</h3>
<h4 id="unit1">unit1</h4>
<ul>
<li>
<p>如果在某些情况下我们只需要实现一些行为/操作而不需要实现状态，OOP 会限制将该行为包装在一个类中以便能够执行它。会导致不必要的冗长代码，其中计算只需要执行一个函数。</p>
</li>
<li>
<p>合并同类项的加法类：代码完美遵循了面向对象地封装概念。美中不足是略为繁琐</p>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403260025901.png" alt="pic1"></p>
</li>
<li>
<p>合并同类项：选用hashmap的merge()方法和lambda函数来实现合并同类项非常简洁。</p>
<ul>
<li>forEach()方法用于对 HashMap 中的每个键值对执行指定的操作。匿名函数 lambda 的表达式 作为 forEach()方法的参数传入。</li>
<li>merge()方法用于合并两个hashmap，使用lambda表达式 (oldValue, newValue) -&gt; (oldValue + newValue) 作为重映射函数。</li>
<li>Java 8的方法引用更方便，方法引用由::双冒号操作符标示,使用BigInteger::add作为重映射函数即可。</li>
</ul>
</li>
<li>
<p>减法：</p>
<ul>
<li>由于hashmap.merge()在插入hashmap2中不存在的key与其对应的value时不会调用重映射函数，故减法不能使用BigInteger::subtract作为映射函数；</li>
<li>解决办法为减数先取反，再与被减数调用quanticAdd()即可</li>
</ul>
</li>
<li>
<p>乘法：</p>
<ul>
<li>将两个BaseKey相乘后的新BaseKey作为merge方法的key参数，系数的乘积作为value参数，重映射函数BigInteger::add</li>
<li>Key为自定义类型BaseKey，重写hashcode()和equal()后便于合并同类项</li>
<li>由于需要维护可变类型BaseKey作为hashmap的key的不可变性，以及value代表的系数为不可变类型BigInteger，没有出现深浅拷贝的Bug</li>
</ul>
</li>
</ul>
<h2 id="三、Stream流式编程">三、Stream流式编程</h2>
<p>Stream 使用类似 SQL 语句从数据库查询数据的方式来提供一种<strong>对 Java 集合运算和表达的高阶抽象</strong>。</p>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403260027312.png" alt="pic1"></p>
<p>Stream API <strong>将要处理的元素集合看作一种流</strong>，流在<strong>管道</strong>中传输，并且可以在管道的节点上进行处理， 比如<strong>筛选，排序，聚合</strong>等。</p>
<h3 id="流式编程特点">流式编程特点</h3>
<ul>
<li>Stream并无数据存储，不会修改背后的数据源。所有惰性操作以<strong>pipeline</strong>的方式执行，<strong>减少迭代次数</strong>.</li>
<li>处理•大量元素时，为了<strong>提高性能</strong>需要<strong>并行处理</strong>，并利用多核架构。并行化的Stream 不需要再写多线程代码，所有对它的操作会<strong>自动并行</strong>进行的。</li>
<li>流的操作可以分为两类：处理操作、聚合操作。
<ul>
<li><strong>处理操作（惰性求值）</strong>：诸如filter、map等处理操作将Stream一层一层的进行抽离，返回一个流给下一层使用。</li>
<li><strong>聚合操作（及早求值）</strong>：从最后一次流中生成一个结果给调用方，得到<strong>最终的结果</strong>而不是Stream。</li>
</ul>
</li>
</ul>
<h3 id="Stream-API">Stream API</h3>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403260028363.png" alt="pic1"></p>
<ul>
<li>filter()：过滤大规模数据集合。接受一个前面提到的 Predicate 断言型函数式接口，传入一个lambda表达式作为过滤逻辑,获得一个新的列表。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Unit4作业</span></span><br><span class="line"><span class="comment">//Elements读取不用使用多层循环嵌套</span></span><br><span class="line">Map&lt;String,MyClass&gt; myClass = Arrays.stream(elements)</span><br><span class="line">    .filter(element -&gt; element <span class="keyword">instanceof</span> UmlClass)</span><br><span class="line">    .map(MyClass::<span class="keyword">new</span>)</span><br><span class="line">    .collect(Collectors.toMap(MyClass::getId,item -&gt; item));</span><br><span class="line"></span><br><span class="line"><span class="comment">//重写MyClass构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">MyClass</span><span class="params">(UmlElement std)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.std = (UmlClass) std;</span><br><span class="line">    <span class="built_in">this</span>.id = std.getId();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>map()：是函数式编程中非常重要的一个概念，能够将对象进行转换</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为每个订单加上12%的税，使用reduce计算总开销</span></span><br><span class="line"><span class="comment">// 老方法：</span></span><br><span class="line"><span class="type">List</span> <span class="variable">costBeforeTax</span> <span class="operator">=</span> Arrays.asList(<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>, <span class="number">400</span>, <span class="number">500</span>);</span><br><span class="line"><span class="type">double</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (Integer cost : costBeforeTax) &#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">price</span> <span class="operator">=</span> cost + <span class="number">.12</span>*cost;</span><br><span class="line">    total = total + price;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;Total : &quot;</span> + total);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新方法：</span></span><br><span class="line"><span class="type">List</span> <span class="variable">costBeforeTax</span> <span class="operator">=</span> Arrays.asList(<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>, <span class="number">400</span>, <span class="number">500</span>);</span><br><span class="line"><span class="type">double</span> <span class="variable">bill</span> <span class="operator">=</span> costBeforeTax.stream().map((cost) -&gt; cost + <span class="number">.12</span>*cost)</span><br><span class="line">                                    .reduce((sum, cost) -&gt; sum + cost).get();</span><br><span class="line">System.out.println(<span class="string">&quot;Total : &quot;</span> + bill); </span><br></pre></td></tr></table></figure>
<ul>
<li>其他例子：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/28112239">https://zhuanlan.zhihu.com/p/28112239</a></li>
</ul>
<h3 id="ForkJoin框架">ForkJoin框架</h3>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403260026893.png" alt="pic1"></p>
<h2 id="四、函数式编程的特点与优势">四、函数式编程的特点与优势</h2>
<h3 id="特点">特点</h3>
<ul>
<li>
<p>函数是输入和输出之间的映射。可以将其视为将输入转换为输出的“黑匣子”。</p>
<p>（1）函数避免改变状态和改变数据。他们观察到的所有状态只是提供给他们的输入。</p>
<p>（2）函数不会改变输入的值，对它们的执行没有副作用。</p>
<p>（3）对于每个输入，都有<strong>相同的输出</strong>。</p>
</li>
<li>
<p>以上特点自然适合并发和并行适用性。计算朝着更多内核和分布式/并行计算的方向发展，事实证明<strong>函数式编程</strong>更适合这些要求。</p>
</li>
<li>
<p>java并不是很典型的函数式编程语言。Apache Spark 是一个用 Scala 编码的大数据平台，它是一种函数式语言。另一个例子是 R，这是数据科学家中最流行的语言，它是函数式的。</p>
</li>
</ul>
<h3 id="优势">优势</h3>
<h4 id="单元测试">单元测试</h4>
<p>因为FP中的每个符号都是final的，没有什么函数会有副作用。谁也不能在运行时修改任何东西，也没有函数可以修改在它作用域之外的值给其他函数继续使用（在指令式编程中可以用类成员或是全局变量做到）。这意味着决定函数执行结果的唯一因素就是它的返回值，而影响其返回值的唯一因素就是它的参数。</p>
<p>测试程序中的函数时只需要关注它的参数就可以。完全不需要担心函数调用的顺序，也不用费心设置外部某些状态值。</p>
<h4 id="调试时的可复现性">调试时的可复现性</h4>
<p>如果一段FP程序没有按照预期设计那样运行，调试的工作非常容易，因为这些错误是百分之一百可以重现的。FP程序中的错误不依赖于之前运行过的不相关的代码。</p>
<p>而在一个指令式程序中，一个bug可能有时能重现而有些时候又不能。因为这些函数的运行依赖于某些外部状态， 而这些外部状态又需要由某些与这个bug完全不相关的代码通过某个特别的执行流程才能修改。</p>
<h4 id="并发执行">并发执行</h4>
<ul>
<li>所有FP程序都是可以并发执行的。由于根本<strong>不需要采用锁机制</strong>，因此完全不需要担心死锁或是并发竞争的发生。</li>
<li>某个FP程序本身只是<strong>单线程</strong>的，编译器也可以将其<strong>优化</strong>成可以在多CPU上运行的并发程序。</li>
<li>这在指令式编程中是无法做到的，因为每一个函数都有可能修改其外部状态，然后接下来的函数又可能依赖于这些状态的值。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://zhhangbian.github.io">pigKiller</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://zhhangbian.github.io/2024/04/02/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-Unit2-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/">https://zhhangbian.github.io/2024/04/02/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-Unit2-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://zhhangbian.github.io" target="_blank">浮泛之舟</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/OO%E8%A1%A5%E5%85%85/">OO补充</a><a class="post-meta__tags" href="/tags/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/">Java多线程</a></div><div class="post_share"><div class="social-share" data-image="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202404022351911.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/04/02/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-Unit1-%E9%80%92%E5%BD%92%E4%B8%8B%E9%99%8D/" title="面向对象-Unit1-递归下降"><img class="cover" src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202404022351911.png" onerror="onerror=null;src='https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202309212200810.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">面向对象-Unit1-递归下降</div></div></a></div><div class="next-post pull-right"><a href="/2024/05/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%90%86%E8%AE%BA-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/" title="操作系统-理论-进程和线程"><img class="cover" src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403252018445.png" onerror="onerror=null;src='https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202309212200810.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">操作系统-理论-进程和线程</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/12/30/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-Pre/" title="面向对象-Pre"><img class="cover" src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202404022351911.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-30</div><div class="title">面向对象-Pre</div></div></a></div><div><a href="/2024/06/25/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-Unit4-UML/" title="面向对象-Unit4-UML"><img class="cover" src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202404022351911.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-25</div><div class="title">面向对象-Unit4-UML</div></div></a></div><div><a href="/2024/04/02/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-Unit1-%E9%80%92%E5%BD%92%E4%B8%8B%E9%99%8D/" title="面向对象-Unit1-递归下降"><img class="cover" src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202404022351911.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-02</div><div class="title">面向对象-Unit1-递归下降</div></div></a></div><div><a href="/2024/06/25/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-Unit3-JML/" title="面向对象-Unit3-JML"><img class="cover" src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202404022351911.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-25</div><div class="title">面向对象-Unit3-JML</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">进程和线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.1.</span> <span class="toc-text">内存模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OS%E8%B0%83%E5%BA%A6"><span class="toc-number">1.2.</span> <span class="toc-text">OS调度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%A1%BA%E5%BA%8F"><span class="toc-number">1.2.1.</span> <span class="toc-text">多线程的顺序</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">Java内存模型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#JMM"><span class="toc-number">2.1.</span> <span class="toc-text">JMM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E8%A7%81%E6%80%A7%E4%BF%9D%E8%AF%81"><span class="toc-number">2.2.</span> <span class="toc-text">可见性保证</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E6%8E%92%E5%BA%8F"><span class="toc-number">2.3.</span> <span class="toc-text">重排序</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">Java多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><span class="toc-number">3.1.</span> <span class="toc-text">基本函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="toc-number">3.1.1.</span> <span class="toc-text">创建线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">3.1.2.</span> <span class="toc-text">线程优先级</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E7%AB%9E%E4%BA%89"><span class="toc-number">3.2.</span> <span class="toc-text">资源竞争</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">3.2.1.</span> <span class="toc-text">线程的状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E9%98%BB%E5%A1%9E"><span class="toc-number">3.2.2.</span> <span class="toc-text">进程的阻塞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B4%E7%95%8C"><span class="toc-number">3.2.3.</span> <span class="toc-text">临界</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81"><span class="toc-number">3.2.4.</span> <span class="toc-text">锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E9%A5%B0%E6%96%B9%E6%B3%95"><span class="toc-number">3.2.4.1.</span> <span class="toc-text">修饰方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%AE%E9%A5%B0%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">3.2.4.1.1.</span> <span class="toc-text">修饰代码块</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AD%89%E5%BE%85-%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6"><span class="toc-number">3.2.4.2.</span> <span class="toc-text">等待&#x2F;通知机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E9%9C%80%E8%A6%81%E5%90%8C%E6%AD%A5"><span class="toc-number">3.2.4.3.</span> <span class="toc-text">不需要同步</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81"><span class="toc-number">3.2.4.4.</span> <span class="toc-text">可重入锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">3.2.4.5.</span> <span class="toc-text">死锁</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB"><span class="toc-number">3.3.</span> <span class="toc-text">资源共享</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile%E5%8E%9F%E7%90%86"><span class="toc-number">3.3.1.</span> <span class="toc-text">volatile原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile%E4%BD%BF%E7%94%A8"><span class="toc-number">3.3.2.</span> <span class="toc-text">volatile使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%80%A7%E6%93%8D%E4%BD%9C"><span class="toc-number">3.3.2.1.</span> <span class="toc-text">原子性操作</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">Java函数式编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%BC%95%E5%85%A5"><span class="toc-number">4.1.</span> <span class="toc-text">一、函数式编程引入</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E7%B1%BB"><span class="toc-number">4.1.1.</span> <span class="toc-text">匿名类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="toc-number">4.1.2.</span> <span class="toc-text">函数式编程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="toc-number">4.1.3.</span> <span class="toc-text">命令式编程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="toc-number">4.1.4.</span> <span class="toc-text">声明式编程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81lambda%E5%87%BD%E6%95%B0"><span class="toc-number">4.2.</span> <span class="toc-text">二、lambda函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%AD%E6%B3%95"><span class="toc-number">4.2.1.</span> <span class="toc-text">Lambda表达式语法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%AD%BE%E5%90%8D"><span class="toc-number">4.2.1.1.</span> <span class="toc-text">函数签名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E4%B8%BB%E4%BD%93"><span class="toc-number">4.2.1.2.</span> <span class="toc-text">函数主体</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%8C%96%E7%AE%80"><span class="toc-number">4.2.2.</span> <span class="toc-text">Lambda表达式的化简</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.2.3.</span> <span class="toc-text">函数式接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%89%8D%E6%8F%90%E6%9D%A1%E4%BB%B6"><span class="toc-number">4.2.4.</span> <span class="toc-text">函数式接口的前提条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.2.5.</span> <span class="toc-text">几种常见的函数式接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.2.6.</span> <span class="toc-text">集合的函数式接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E4%B8%9A%E4%B8%AD%E4%BD%BF%E7%94%A8lambda%E5%87%BD%E6%95%B0%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-number">4.2.7.</span> <span class="toc-text">作业中使用lambda函数的优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#unit1"><span class="toc-number">4.2.7.1.</span> <span class="toc-text">unit1</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81Stream%E6%B5%81%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="toc-number">4.3.</span> <span class="toc-text">三、Stream流式编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E5%BC%8F%E7%BC%96%E7%A8%8B%E7%89%B9%E7%82%B9"><span class="toc-number">4.3.1.</span> <span class="toc-text">流式编程特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Stream-API"><span class="toc-number">4.3.2.</span> <span class="toc-text">Stream API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ForkJoin%E6%A1%86%E6%9E%B6"><span class="toc-number">4.3.3.</span> <span class="toc-text">ForkJoin框架</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E7%9A%84%E7%89%B9%E7%82%B9%E4%B8%8E%E4%BC%98%E5%8A%BF"><span class="toc-number">4.4.</span> <span class="toc-text">四、函数式编程的特点与优势</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">4.4.1.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8A%BF"><span class="toc-number">4.4.2.</span> <span class="toc-text">优势</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-number">4.4.2.1.</span> <span class="toc-text">单元测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E8%AF%95%E6%97%B6%E7%9A%84%E5%8F%AF%E5%A4%8D%E7%8E%B0%E6%80%A7"><span class="toc-number">4.4.2.2.</span> <span class="toc-text">调试时的可复现性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E6%89%A7%E8%A1%8C"><span class="toc-number">4.4.2.3.</span> <span class="toc-text">并发执行</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2024 By pigKiller</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">你终会看到，你的歌声和旗帜在飘扬</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script></div><script src="f12.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>