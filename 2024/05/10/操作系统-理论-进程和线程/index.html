<!DOCTYPE html><html lang="zh-CN" data-theme="light"><script>((function() {var callbacks = [],timeLimit = 50,open = false;setInterval(loop, 1);return {addListener: function(fn) {callbacks.push(fn);},cancleListenr: function(fn) {callbacks = callbacks.filter(function(v) {return v !== fn;});}}
function loop() {var startTime = new Date();debugger;if (new Date() - startTime > timeLimit) {if (!open) {callbacks.forEach(function(fn) {fn.call(null);});}open = true;window.stop();alert('你真坏，请关闭控制台！');document.body.innerHTML = "";} else {open = false;}}})()).addListener(function() {window.location.reload();});</script><script>function toDevtools(){
  let num = 0; 
  let devtools = new Date();
  devtools.toString = function() {
    num++;
    if (num > 1) {
        alert('你真坏，请关闭控制台！')
        window.location.href = "about:blank"
        blast();
    }
  }
  console.log('', devtools);
}
toDevtools();</script><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>操作系统-理论-进程和线程 | 浮泛之舟</title><meta name="author" content="pigKiller"><meta name="copyright" content="pigKiller"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="进程与线程 真并行与假并行 并行与并发 并发Concurrent：设有两个活动a1和a2，如果在某一指定的时间t，无论a1和a2是在同一处理机上还是在不同的处理机上执行，只要a1和a2都处在各自的起点和终点之间的某一处，则称a1和a2是并发执行的。 并行Parallel：如果考虑两个程序,它们在同一时间度量下同时运行在不同的处理机上，则称这两个程序是并行执行的。 对于并发执行：程序的并发执行是指若">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统-理论-进程和线程">
<meta property="og:url" content="https://pigkillermaster.github.io/2024/05/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%90%86%E8%AE%BA-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/index.html">
<meta property="og:site_name" content="浮泛之舟">
<meta property="og:description" content="进程与线程 真并行与假并行 并行与并发 并发Concurrent：设有两个活动a1和a2，如果在某一指定的时间t，无论a1和a2是在同一处理机上还是在不同的处理机上执行，只要a1和a2都处在各自的起点和终点之间的某一处，则称a1和a2是并发执行的。 并行Parallel：如果考虑两个程序,它们在同一时间度量下同时运行在不同的处理机上，则称这两个程序是并行执行的。 对于并发执行：程序的并发执行是指若">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403252018445.png">
<meta property="article:published_time" content="2024-05-10T14:05:26.000Z">
<meta property="article:modified_time" content="2024-06-25T06:57:49.066Z">
<meta property="article:author" content="pigKiller">
<meta property="article:tag" content="OS理论">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403252018445.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://pigkillermaster.github.io/2024/05/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%90%86%E8%AE%BA-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '操作系统-理论-进程和线程',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2024-06-25 14:57:49'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202307102227559.png" onerror="onerror=null;src='https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202309212200810.jpg'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">47</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">32</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">19</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-categories"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403252018445.png')"><nav id="nav"><span id="blog-info"><a href="/" title="浮泛之舟"><span class="site-name">浮泛之舟</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-categories"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">操作系统-理论-进程和线程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-05-10T14:05:26.000Z" title="发表于 2024-05-10 22:05:26">2024-05-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-06-25T06:57:49.066Z" title="更新于 2024-06-25 14:57:49">2024-06-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/OS%E7%90%86%E8%AE%BA/">OS理论</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">19.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>60分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="操作系统-理论-进程和线程"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>进程与线程</h1>
<p>真并行与假并行</p>
<h2 id="并行与并发">并行与并发</h2>
<p>并发Concurrent：设有两个活动a1和a2，如果在某一指定的时间t，无论a1和a2是在<strong>同一处理机上还是在不同的处理机上执行</strong>，只要a1和a2都处在<strong>各自的起点和终点之间的某一处</strong>，则称a1和a2是并发执行的。</p>
<p>并行Parallel：如果考虑两个程序,它们在同一时间度量下<strong>同时运行在不同的处理机上</strong>，则称这两个程序是并行执行的。</p>
<p>对于并发执行：程序的并发执行是指若干个程序（或程序段）同时在系统中运行，这些程序（或程序段）的执行在时间上是重叠的。所谓执行在时间上是重叠的，是指<strong>执行一个程序（或程序段）的第一条指令是在执行另一个程序（或程序段）的最后一条指令完成之前开始</strong>。</p>
<p>程序并发执行时的特征：</p>
<ul>
<li>间断性：并发程序具有“执行—暂停—执行”这种间断性的活动规律。</li>
<li>非封闭性：多个程序共享系统中的资源，这些资源的状态将由多个程序来改变，致使程序之间相互影响。</li>
<li>不可再现性：在初始条件相同的情况下，程序的执行结果依赖于执行的次序。</li>
</ul>
<h3 id="前驱图">前驱图</h3>
<p>程序在运行过程中会有相应的数据依赖，如B的执行必须依赖于A，也就是A必须在B之前完成，写作A-&gt;B。</p>
<p>前趋图是一个有向无循环图，图中的每个结点可以表示一条语句、一个程序段或进程，结点间的有向边表示语句或程序段的执行次序。</p>
<img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202404100902599.png" alt="前驱图" style="zoom: 50%;" />
<p>只要保证相应的依赖关系即可，但由于<strong>OS调度策略不是一直不变的</strong>，具体的执行先后可能有所不同。</p>
<p>这是因为数据的竞争</p>
<h3 id="竞争">竞争</h3>
<p>竞争：多个进程在读写共享数据时的结果依赖于<strong>执行的相对时间</strong></p>
<p>竞争条件：多个进程<strong>并发访问和操作同一数据</strong>且执行<strong>结果与访问的特定顺序有关</strong></p>
<p>如果关注并发是否有确定的结果，那么需要关注数据的其他特性是否满足Bernstein条件</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo stretchy="false">(</mo><mi>S</mi><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">R(Si)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">i</span><span class="mclose">)</span></span></span></span>：Si的读子集, 其值在Si中被引用的变量的集合</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi><mo stretchy="false">(</mo><mi>S</mi><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">W(Si)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">i</span><span class="mclose">)</span></span></span></span>：Si的写子集, 其值在Si中被改变的变量的集合</p>
<p>两个进程S1和S2可并发，当且仅当下列条件同时成立：</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo stretchy="false">(</mo><mi>S</mi><mn>1</mn><mo stretchy="false">)</mo><mo>∩</mo><mi>W</mi><mo stretchy="false">(</mo><mi>S</mi><mn>2</mn><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">Φ</mi></mrow><annotation encoding="application/x-tex">R(S1) \cap W(S2) = \Phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Φ</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi><mo stretchy="false">(</mo><mi>S</mi><mn>1</mn><mo stretchy="false">)</mo><mo>∩</mo><mi>R</mi><mo stretchy="false">(</mo><mi>S</mi><mn>2</mn><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">Φ</mi></mrow><annotation encoding="application/x-tex">W(S1) \cap R(S2) = \Phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Φ</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi><mo stretchy="false">(</mo><mi>S</mi><mn>1</mn><mo stretchy="false">)</mo><mo>∩</mo><mi>W</mi><mo stretchy="false">(</mo><mi>S</mi><mn>2</mn><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">Φ</mi></mrow><annotation encoding="application/x-tex">W(S1) \cap W(S2) = \Phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Φ</span></span></span></span>​</li>
<li>即没有任何读写冲突</li>
</ul>
<h2 id="进程">进程</h2>
<p>==进程是<strong>程序的一次执行</strong>==，是在行为上的一个动作，包含了行为本身和行为相应的数据。其数据包括程序及相应的数据，是一个程序及其数据，在处理机上顺序执行时所发生的活动。</p>
<p>作为行为的抽象，进行是程序在一个数据集合上运行的过程，是<strong>系统进行资源分配和调度的一个独立单位</strong>。</p>
<p>进程的结构特征：<strong>程序段、数据段、进程控制器PCB</strong></p>
<p>进程应该包括：</p>
<ol>
<li>程序的代码</li>
<li>程序的数据</li>
<li>PC的值，用来表明下一条执行的指令</li>
<li>上下文环境：一组通用寄存器的值、堆、栈</li>
<li>一组系统资源（如打开的文件）</li>
</ol>
<p>==进程时资源分配的基本单元，线程是处理机调度的基本单元==</p>
<ul>
<li>动态性：<strong>进程是程序的一次执行过程</strong>。动态性还表现为它因创建而产生，因调度而执行，因无资源而暂停，因撤消而消亡。而程序是静态实体。</li>
<li>并发性：<strong>多个进程实体同时存在于内存中</strong>，能在一段时间内同时运行。</li>
<li>独立性：在传统OS中，进程是独立运行的基本单位</li>
<li>异步性：也叫制约性，进程之间相互制约，进程以各自独立的不可预知的速度向前推进。</li>
<li>结构特征：程序段，数据段，进程控制块PCB</li>
</ul>
<h3 id="进程控制">进程控制</h3>
<p>进程控制主要任务是<strong>创建和撤销</strong>进程，以及实现进程的<strong>状态转换</strong>。由OS的内核实现。</p>
<p>创建进程的方法：</p>
<ol>
<li>提交一个批处理作业</li>
<li>用户登录</li>
<li>由OS创建，用以向一用户提供服务</li>
<li>由已存在的一进程创建</li>
</ol>
<p>撤销进程的方法：</p>
<ol>
<li>用户退出登录</li>
<li>进程执行一中止服务请求</li>
<li>出错及失败因素</li>
<li>正常结束</li>
<li>给定时限到</li>
</ol>
<h3 id="原语">原语</h3>
<p>原语：由若干条指令组成的指令序列，来实现某个特定的操作功能。</p>
<ul>
<li>==指令序列执行是连续的，不可分割==</li>
<li>是操作系统核心组成部分</li>
<li>必须在内核态下执行，且常驻内存</li>
</ul>
<p>创建原语：fork, exec</p>
<ul>
<li>可以通过fork返回的值来判断当前进程是子进程还是父进程。
<ul>
<li>在父进程中，fork返回新创建子进程的进程ID；</li>
<li>在子进程中，fork返回0；</li>
<li>如果出现错误，fork返回一个负值；</li>
<li>==fork返回两次，有三种可能的取值==</li>
</ul>
</li>
<li><strong>父进程的fpid指向子进程的进程id, 子进程没有子进程</strong>，所以其fpid为0.</li>
</ul>
<p>撤消原语：kill</p>
<ul>
<li>释放资源、撤消子进程、重新调度。</li>
</ul>
<img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202404101024494.png" alt="image-20240410102452399" style="zoom: 50%;" />
<h3 id="进程的状态">进程的状态</h3>
<ul>
<li>
<p>就绪状态：进程已获得<strong>除处理机外的所需资源</strong>，等待分配处理机资源，只要分配CPU就可执行。</p>
</li>
<li>
<p>执行状态：占用处理机资源；处于此状态的进程的数目小于等于CPU的数目。</p>
<p>在没有其他进程可以执行时（<strong>如所有进程都在阻塞状态</strong>），通常会自动执行系统的idle进程（相当于空操作）。</p>
</li>
<li>
<p>阻塞状态：正在执行的进程，由于发生某种事件而暂时无法执行，便放弃处理机处于暂停状态。</p>
</li>
</ul>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202404101028975.png" alt="进程状态转换"></p>
<ul>
<li>就绪–&gt;运行
<ul>
<li>时间一到，调度程序选择一个进程运行</li>
</ul>
</li>
<li>运行–&gt;就绪
<ul>
<li>运行进程<strong>用完了时间片</strong></li>
<li>运行进程被中断，因为==一高优先级进程处于就绪状态==</li>
</ul>
</li>
<li>运行–&gt;阻塞
<ul>
<li>当一进程所需的东西必须等待时</li>
<li>OS尚未完成服务</li>
<li>对一资源的访问尚不能进行</li>
<li>初始化IO且必须等待结果</li>
<li>等待某一进程提供输入（IPC）</li>
</ul>
</li>
<li>阻塞–&gt;就绪
<ul>
<li>当所等待的事件发生时</li>
</ul>
</li>
</ul>
<h3 id="进程控制块PCB">进程控制块PCB</h3>
<p>怎么实现进程机制：进程创建、进程管理、进程终止、进程的状态切换</p>
<p>OS为每个进程定义了一个<strong>数据结构</strong>：进程控制块PCB</p>
<p>进程控制块是进程管理和控制的最重要的数据结构，<strong>每一个进程均有一个PCB</strong>。在创建进程时，建立PCB，伴随进程运行的全过程，<strong>直到进程撤消而撤消</strong>。</p>
<p>系统中有相应的指针指向PCB，来戴白哦起到作用的PCB，如<strong>运行指针、就绪队列指针</strong>等。</p>
<h4 id="PCB的作用">PCB的作用</h4>
<ul>
<li>进程创建、撤销</li>
<li>进程的唯一标志</li>
<li><strong>限制系统进程数目</strong></li>
</ul>
<h4 id="PCB的内容">PCB的内容</h4>
<ul>
<li>进程标识符:
<ul>
<li>每个进程都必须有一个<strong>唯一的标识符</strong>，可以是字符串，也可以是一个数字。</li>
<li>Linux系统中就是一个整型数。在进程创建时由系统赋予。</li>
</ul>
</li>
<li>程序和数据地址:
<ul>
<li>把PCB与其程序和数据联系起来。记录到哪里寻找数据和程序</li>
</ul>
</li>
<li>当前状态：
<ul>
<li>为了管理的方便，系统设计时会将相同的状态的进程组成一个队列，如就绪进程队列。</li>
<li>等待进程则要<strong>根据等待的事件</strong>组成多个等待队列，如等待打印机队列、等待磁盘IO完成队列等等。</li>
</ul>
</li>
<li>现场保护区:
<ul>
<li>当进程因某种原因不能继续占用CPU时（等待打印机），释放CPU，这时就要<strong>将CPU的各种状态信息保护起来</strong>，为将来再次得到处理机恢复CPU的各种状态，继续运行。</li>
</ul>
</li>
<li>同步与同步机制：
<ul>
<li>用于实现进程间互斥、同步和通信所需的信号量等。</li>
</ul>
</li>
<li>优先级：
<ul>
<li>进程的优先级反映进程的紧迫程序，通常由用户指定和系统设置。Linux系统采用用户设置和系统计算相结合的方式确定进程的优先级。</li>
</ul>
</li>
<li>资源清单：
<ul>
<li>列出所<strong>拥有的除CPU外的资源记录</strong>，如<strong>拥有的IO设备，打开的文件列表</strong>等。</li>
</ul>
</li>
<li>链接字：
<ul>
<li>根据进程所处的现行状态，进程相应的PCB参加到不同队列中。PCB链接字指出<strong>该进程所在队列中下一个进程PCB的首地址</strong>。</li>
</ul>
</li>
<li>其他信息：
<ul>
<li>如进程记账信息，进程占用CPU的时间等。</li>
</ul>
</li>
</ul>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202406031134964.png" alt="PCB的内容"></p>
<h4 id="PCB的组织方式">PCB的组织方式</h4>
<p>用PCB管理进程：本质是控制了OS执行的程序地址，相关的数据地址，实现了对进程的管理</p>
<ul>
<li>
<p>线性表</p>
<ul>
<li>
<p>线性表方式：不论进程的状态如何，将所有的PCB连续地存放在内存的系统区。</p>
</li>
<li>
<p>这种方式适用于系统中进程数目不多的情况。</p>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202404101036695.png" alt="线性表"></p>
</li>
</ul>
</li>
<li>
<p>链接方式</p>
<ul>
<li>
<p>索引表方式：该方式是线性表方式的改进，系统<strong>按照进程的状态</strong>分别建立不同的表，如就<strong>绪索引表、阻塞索引表</strong>等。</p>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202404101037696.png" alt="image-20240410103727615"></p>
</li>
</ul>
</li>
<li>
<p>索引方式</p>
<ul>
<li>
<p>链接表方式：系统<strong>按照进程的状态</strong>将进程的PCB组成队列，从而形成<strong>就绪队列、阻塞队列、运行队列</strong>等。</p>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202404101037423.png" alt="image-20240410103740342"></p>
</li>
</ul>
</li>
</ul>
<h3 id="进程上下文切换">进程上下文切换</h3>
<p>执行不同的进程进行切换时，通常由调度器执行，保存进程的执行断点，<strong>切换相应的内存映射（页表基址，冲刷TLB）</strong>，故一定会陷入内核。</p>
<p><strong>系统调</strong>用涉及到进程从用户态到内核态的切换（mode switch），这个时候涉及到的切换主要是<strong>寄存器上下文的切换</strong>，和通常所说的进程上下文切换不同，mode switch 的消耗相对要小很多。</p>
<h2 id="线程">线程</h2>
<ul>
<li>进程是OS中行为的抽象，是一个<em>行为</em>，无法同时做多件事。</li>
<li>进程在执行的过程中如果阻塞，例如等待输入，整个进程就会挂起，即使进程中有些工作不依赖于输入的数据，也将无法执行。</li>
</ul>
<p>需要提出一种新的实体，满足以下特性：</p>
<ul>
<li>实体之间可以<strong>并发地执行</strong>；</li>
<li>实体之间<strong>共享相同的地址空间</strong>；</li>
</ul>
<p>进程获取了相应的资源，将对资源的执行进行更细粒度的划分：线程。</p>
<p>引入进程好处：<strong>多个程序可以并发执行</strong>，改善资源使用率，提高系统效率</p>
<p>引入线程好处：减少并发程序执行时所付出的时空开销，使得<strong>并发粒度更细、并发性更好</strong></p>
<p>==进程是资源分配的基本单元，线程是处理机调度的基本单元==</p>
<h3 id="线程的基本概念">线程的基本概念</h3>
<p>进程包含了两个概念：<strong>资源拥有者和可执行单元</strong>。现代操作系统将<strong>资源拥有者称为进程</strong>（process, task）。<strong>可执行单元称为线程</strong>（Thread）。</p>
<p>线程：<strong>将资源与计算分离</strong>，提高并发效率。</p>
<ul>
<li>减小进程切换的开销（线程切换不用陷入内核，陷入内核开销较大）</li>
<li>提高进程内的并发程度</li>
<li>共享资源（同一进程的线程之间可以共享==进程拥有的所有资源==）</li>
</ul>
<p>线程是<strong>进程中的一个实体</strong>，是CPU调度和分派的单位。基本上不拥有资源，可与其他线程共享资源。</p>
<h3 id="线程VS进程">线程VS进程</h3>
<p>进程拥有虚空间、进程映像、处理机保护、文件、IO空间。</p>
<p>线程额外的资源：运行状态、保存上下文（程序计数器）、<strong>执行栈</strong>、资源共享机制。</p>
<ul>
<li>一个进程可以拥有多个线程，而一个线程只能被一个进程拥有</li>
<li>==进程是资源分配的基本单位，线程是处理机调度的基本单位，所有的线程共享其所属进程的所有资源与代码。==</li>
<li>==线程执行过程之中很容易进行协作同步，而进程需要通过消息通信进行同步。==</li>
<li>==线程不能单独执行，但是每一个线程都有程序的入口、执行序列以及程序出口。它必须组成进程才能被执行。==</li>
</ul>
<h3 id="线程的实现方式">线程的实现方式</h3>
<ul>
<li>用户级线程：User level threads（ULT）</li>
<li>内核级线程：Kernel level threads（KLT）</li>
<li>混合实现方式</li>
</ul>
<h4 id="用户级线程">用户级线程</h4>
<p>由用户手管理的线程。线程在用户空间，<strong>通过library模拟的thread</strong>，不需要或仅需要极少的kernel支持</p>
<p>上下文切换很快：不用修改页表</p>
<p><strong>下图很关键</strong>：</p>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202404101057128.png" alt="用户级线程"></p>
<p>用户级线程的优劣：</p>
<ul>
<li>优点
<ul>
<li><strong>线程切换与内核无关</strong>，不用修改页表，效率较高</li>
<li><strong>线程的调度由应用决定</strong>，容易进行优化</li>
<li>可运行在任何操作系统上，只需要<strong>线程库</strong>的支持</li>
</ul>
</li>
<li>不足
<ul>
<li>很多系统调用会引起阻塞，内核会因此而阻塞所有相关的线程。</li>
<li>内核<strong>只能将处理器分配给进程</strong>，即使有多个处理器，也<strong>无法实现一个进程中的多个线程的并行执行</strong>。</li>
</ul>
</li>
</ul>
<p>用户级的线程库的主要功能：</p>
<ul>
<li>创建和销毁线程</li>
<li>线程之间传递消息和数据</li>
<li>调度线程执行</li>
<li>保存和恢复线程上下文</li>
</ul>
<p>标准库是<code>pthread</code></p>
<ul>
<li><code>pthread_create()</code>：创建线程</li>
<li><code>pthread_exit()</code>：终止线程</li>
<li><code>pthread_join()</code>：阻塞线程</li>
<li><code>pthread_yield()</code>：释放锁等待</li>
<li><code>pthread_attr_init()</code>：对线程的属性进行初始化</li>
<li><code>pthread_attr_destory()</code>：销毁线程的属性</li>
</ul>
<h4 id="内核级线程">内核级线程</h4>
<p>OS内核态本身就有多个线程执行相关任务，可以将用户的多个线程在内核也是真正的多线程执行。支持内核线程的操作系统内核称作多线程内核。</p>
<p><strong>下图很关键</strong>：</p>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202404101104577.png" alt="内核级线程"></p>
<p>优劣：</p>
<ul>
<li>优点
<ul>
<li>内核可以在<strong>多个处理器上调度一个进程的多个线程</strong>实现同步并行执行</li>
<li><strong>阻塞发生在线程级别</strong></li>
<li>内核中的一些处理可以通过多线程实现</li>
</ul>
</li>
<li>缺点
<ul>
<li>一个进程中的线程切换需要内核参与，线程的切换涉及到两个模式的切换（进程-进程、线程-线程）</li>
<li>降低效率</li>
</ul>
</li>
</ul>
<h4 id="用户级和内核级的比较">用户级和内核级的比较</h4>
<p>用户级线程的创建、撤消和调度<strong>不需要OS内核的支持</strong>，是在语言或用户库这一级处理的；而<strong>内核支持线程的创建、撤消和调度都需OS内核提供支持</strong>，而且与进程的创建、撤消和调度大体是相同的。</p>
<p>用户级线程<strong>执行系统调用指令</strong>时将导致其<strong>所属进程</strong>被中断，而内核支持线程执行系统调用指令时，只导致<strong>该线程被中断</strong>。</p>
<p>在只有<strong>用户级线程</strong>的系统内，<strong>CPU调度还是以进程为单位</strong>，处于运行状态的进程中的多个线程，由用户程序控制线程的轮换运行；在有内核支持线程的系统内，<strong>CPU调度则以线程为单位</strong>，由OS的线程调度程序负责线程的调度。</p>
<p><strong>用户级线程的程序实体是运行在用户态下的程序</strong>，而内核支持线程的程序实体则是可以运行在任何状态下的程序。</p>
<h4 id="混合实现方式">混合实现方式</h4>
<p>线程在用户空间创建和管理。需要实现<strong>从用户空间的线程到内核空间线程（轻量级进程）的映射</strong>。</p>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202404101107378.png" alt="混合实现方式"></p>
<h3 id="线程模型">线程模型</h3>
<p>内核级和用户级的连接关系。</p>
<h4 id="Many-to-One">Many-to-One</h4>
<p>将多个用户级线程映射到一个内核级线程，线程管理在用户空间完成。此模式中，<strong>用户级线程对操作系统不可见</strong>（即透明）。</p>
<ul>
<li>优点：线程管理是在用户空间进行的，因而效率比较高。</li>
<li>缺点：==当一个线程在使用内核服务时被阻塞，那么<strong>整个进程都会被阻塞</strong>==；==多个线程不能并行地运行在多处理机上。==</li>
</ul>
<img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202404101114802.png" alt="M-O" style="zoom:33%;" />
<h4 id="One-to-One">One-to-One</h4>
<p>将每个用户级线程映射到一个内核级线程。</p>
<ul>
<li>优点：当一个线程被阻塞后，允许另一个线程继续执行，所以并发能力较强。</li>
<li>缺点：每创建一个用户级线程都需要创建一个内核级线程与其对应，这样**==创建线程的开销比较大==**，会影响到应用程序的性能。</li>
</ul>
<img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202404101115754.png" alt="image-20240410111519666" style="zoom:50%;" />
<h4 id="Many-to-Many">Many-to-Many</h4>
<p>将n个用户级线程映射到m个内核级线程上，要求m&lt;=n。</p>
<p>特点：在多对一模型和一对一模型中取了个折中，<strong>克服了多对一模型的并发度不高的缺点</strong>，又克服了一对一模型的<strong>一个用户进程占用太多内核级线程</strong>，开销太大的缺点。又拥有多对一模型和一对一模型各自的优点，可谓集两者之所长。</p>
<img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202404101115512.png" alt="image-20240410111544409" style="zoom:33%;" />
<h1>进程同步</h1>
<p>并发是OS的设计基础，也是所有同步互斥问题产生的原因。</p>
<p>进程的三个特征：</p>
<ul>
<li>间断性：并发：体现在进程的执行是间断性的；进程的相对执行速度是不可测的。</li>
<li>非封闭性：共享：体现在进程/线程之间的制约性（如共享打印机）。</li>
<li>不可再现性：不确定性：进程执行的结果与其执行的相对速度有关，是不确定的。</li>
</ul>
<h2 id="同步与互斥">同步与互斥</h2>
<p>并发执行，不可避免地产生了<strong>多个进程对同一个共享资源访问</strong>，造成了资源的争夺。</p>
<ul>
<li>竞争：两个或多个进程对同一共享数据同时进行访问，而最后的结果是不可预测的，它取决于各个进程对共享数据访问的相对次序。这种情形叫做竞争。</li>
<li>竞争条件：多个进程并发访问和操作同一数据且执行结果与访问的特定顺序有关。</li>
<li>==临界资源：我们将<strong>一次仅允许一个进程访问的资源</strong>称为临界资源==。</li>
<li>临界区：每个进程中<strong>访问临界资源的那段代码</strong>称为临界区。</li>
</ul>
<h3 id="基本概念">基本概念</h3>
<p>进程互斥：某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。互斥<strong>无法限制访问者对资源的访问顺序</strong>，即访问是<strong>无序访问</strong>。</p>
<p>进程同步：是指<strong>在互斥的基础上</strong>，<strong>通过其它机制</strong>实现访问者<strong>对资源的有序访问</strong>。</p>
<p>在大多数情况下，同步已经实现了互斥，特别是所有对资源的写入的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源，如同时读。</p>
<ul>
<li>进程互斥是进程间发生的一种<strong>间接性作用</strong>，一般是程序不希望的。</li>
<li>进程同步是进程间的一种<strong>刻意安排的直接制约关系</strong>。即为完成同一个任务的各进程之间，因需要协调它们的工作而相互等待、相互交换信息所产生的制约关系。</li>
</ul>
<h3 id="机制原则">机制原则</h3>
<p>临界区原则：</p>
<ol>
<li>没有进程在临界区时，想进入临界区的进程可进入。</li>
<li>任何两个进程都不能同时进入临界区（Mutual Exclusion）；</li>
<li>当一个进程运行在它的临界区外面时，<strong>不能妨碍其他的进程进入临界区</strong>（Progress）；</li>
<li>任何一个进程进入临界区的要求应该<strong>在有限时间内得到满足</strong>（Bounded Waiting）。</li>
</ol>
<p>互斥机制的设计原则：</p>
<ol>
<li>空闲让进：临界资源处于空闲状态，允许进程进入临界区。</li>
<li>忙则等待：临界区有正在执行的进程，所有其他进程则不可以进入临界区。</li>
<li>有限等待：对要求访问临界区的进程，应在保证在有限时间内进入临界区，避免死等。</li>
<li>让权等待：当进程长时间不能进入临界区时，<strong>应立即释放处理机，尽量避免忙等</strong>。</li>
</ol>
<h2 id="互斥方法">互斥方法</h2>
<p>**所谓的锁，在计算机里本质上就是一块内存空间。**用一个锁的访问来代表临界区的访问。</p>
<p>世界上本来没有互斥，对于内存的修改是粗暴的，用锁这种方式来由操作系统实现锁、实线进程同步。</p>
<h3 id="基于忙等待的同步方法">基于忙等待的同步方法</h3>
<ul>
<li>当一个程序想要进入临界区时，先检查是否允许进入</li>
<li>若不允许，则进程将原地等待，知道被允许进入
<ul>
<li>空转浪费CPU时间</li>
</ul>
</li>
</ul>
<h4 id="软件方法">软件方法</h4>
<p>如何通过软件完成相应的临界区涉及，达成互斥的效果？</p>
<p>程序可能会同时竞争相应的资源，由于资源的竞争导致可能同时死锁/进入临界区，所以要设置相应的方法。</p>
<p>Dekker算法：使用<code>turn</code>进行让权，保证只有一个能进入临界区</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">P:</span><br><span class="line">pturn = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span> (qturn) &#123;</span><br><span class="line">    <span class="comment">// 让权等待</span></span><br><span class="line">    <span class="keyword">if</span> (turn == <span class="number">1</span>) &#123;</span><br><span class="line">        pturn = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (turn == <span class="number">1</span>);</span><br><span class="line">        pturn = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 临界区</span></span><br><span class="line"><span class="comment">// 谦让给对方</span></span><br><span class="line">turn = <span class="number">1</span>;</span><br><span class="line">pturn = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">Q:</span><br><span class="line">qturn = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span> (pturn) &#123;</span><br><span class="line">    <span class="comment">// 让权等待</span></span><br><span class="line">    <span class="keyword">if</span> (turn == <span class="number">0</span>) &#123;</span><br><span class="line">        qturn = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (turn == <span class="number">0</span>);</span><br><span class="line">        qturn = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 临界区</span></span><br><span class="line">turn = <span class="number">0</span>;</span><br><span class="line">qturn = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<p>Peterson算法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 2</span></span><br><span class="line"><span class="comment">// 轮到谁</span></span><br><span class="line"><span class="type">int</span> turn;</span><br><span class="line"><span class="comment">// 初始值均为false</span></span><br><span class="line"><span class="type">int</span> interested[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// process = 0, 1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">enter_region</span><span class="params">(<span class="type">int</span> process)</span> &#123;</span><br><span class="line">    <span class="comment">// 另一个进程的进程号</span></span><br><span class="line">    <span class="type">int</span> other = <span class="number">1</span> - process;</span><br><span class="line">    <span class="comment">// 本进程感兴趣</span></span><br><span class="line">    interested[process] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 设置标志位</span></span><br><span class="line">    turn = process;</span><br><span class="line">	<span class="comment">// 使用turn进行谦让，不用turn则可能会同时访问</span></span><br><span class="line">    <span class="comment">// 轮到我了并且你不敢兴趣：如果没到我（被抢占）或对方还没退出临界区</span></span><br><span class="line">    <span class="keyword">while</span> (turn == process &amp;&amp; interested[other] == <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">leave_region</span><span class="params">(<span class="type">int</span> process)</span> &#123;</span><br><span class="line">    <span class="comment">// 进程离开临界区</span></span><br><span class="line">    interested[process] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enter_region(i);</span><br><span class="line"><span class="comment">// 临界区</span></span><br><span class="line">leave_region(i);</span><br></pre></td></tr></table></figure>
<h4 id="硬件方法">硬件方法</h4>
<ul>
<li>
<p>中断屏蔽</p>
<ul>
<li>执行<strong>关中断</strong>指令，程序进入临界区进行操作</li>
<li>退出临界区之前，执行<strong>开中断</strong>指令</li>
<li>在多CPU情景下会带来很大的性能损失，单处理器情况下很多日常任务（如时钟中断）是靠中断机制实现的</li>
</ul>
</li>
<li>
<p><code>test-and-set</code>方法实现的自旋锁</p>
<ul>
<li>
<p>使用硬件提供的<code>test_and_set</code>硬件原语提供互斥支持，是一种不可中断的基本原语。</p>
<p>在多进程可以同时存取内存的情况下，如果一个进程正在执行检查并设置，在执行完成前，其他进程不可以执行检查并设置</p>
</li>
<li>
<p>具体的硬件实现是通过<strong>对总线的锁定</strong>来实现对某个内存位置的原子读和更新</p>
</li>
<li>
<pre><code class="language-c">acquire(lock) &#123;
    while(test_and_set(lock) == 1);
&#125;
// 临界区
release(lock) &#123;
    lock = 0;
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- swap指令</span><br><span class="line"></span><br><span class="line">  - 也是不会被中断的原子指令，功能是交换两个字的内容</span><br><span class="line"></span><br><span class="line">### 基于信号量的同步方法</span><br><span class="line"></span><br><span class="line">同步中，进程经常需要等待某个条件的发生，如果使用忙等待的解决方案，势必浪费大量CPU时间。</span><br><span class="line"></span><br><span class="line">- 忙等待：浪费CPU时间</span><br><span class="line">- ==优先级反转：低优先级的进程先进入临界区，高优先级的进程一直忙等==</span><br><span class="line"></span><br><span class="line">解决方法：增加进程间的通信手段，**将忙等变为阻塞**，使用了进程间的通信原语：`sleep`和`wakeup`。`wakeup`原语的调用需要一个参数**被唤醒的进程ID**。</span><br><span class="line"></span><br><span class="line">引入了信号量，是一类特殊的变量，**程序对其的访问都是原子操作**。信号量的**对象是资源**：记录了当前想要使用资源的进程数量和资源数量之间的关系。</span><br><span class="line"></span><br><span class="line">#### 信号量的数据结构</span><br><span class="line"></span><br><span class="line">信号量的具体数据结构为：一个确定的二元组`(s,q)`</span><br><span class="line"></span><br><span class="line">- s是一个具有非负初值的整形变量。</span><br><span class="line">  - s的值是对应资源的数量，即当前可使用该资源的进程的数量</span><br><span class="line">  - 若s大于等于0，则代表可使用的资源的数量</span><br><span class="line">  - 若s小于0，则没有资源可供进程使用，则需要相关的阻塞，此时**`|s|`为被阻塞的进程的数量**</span><br><span class="line">- q是一个初始状态为空的队列</span><br><span class="line">  - q中存储了被阻塞的进程的信息，记录了被阻塞的信息。</span><br><span class="line">  - 强信号量：进程从q中释放时采用FIFO</span><br><span class="line">  - 弱信号量：没有规定进程从阻塞队列中移除顺序</span><br><span class="line"></span><br><span class="line">信号量只有**增加V操作和减少P操作**两种。PV操作属于进程的**低级通信**。</span><br><span class="line"></span><br><span class="line">- 在进入临界区时，必须先进P操作，获得资源并减小信号量，阻塞其他想要竞争的资源。</span><br><span class="line">  - P操作分配资源（给线程），信号量\-\-</span><br><span class="line">- 在出临界区时释放资源，进行V操作。</span><br><span class="line">  - V操作（由线程）释放资源，信号量++</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">struct semaphore &#123;</span><br><span class="line">    int vount;</span><br><span class="line">    queueType queue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 进程获取资源：P操作</span><br><span class="line">void semWait (semaphore s) &#123;</span><br><span class="line">    s.count--;</span><br><span class="line">    if(s.count&lt;0) &#123;</span><br><span class="line">        // 进行阻塞</span><br><span class="line">        // |s.count|表示当前等待的进程个数</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 进程释放资源：V操作</span><br><span class="line">void semSignal (semaphore s) &#123;</span><br><span class="line">    s.count++;</span><br><span class="line">    if(s.count&lt;=0) &#123;</span><br><span class="line">        // 释放了一个资源，则一个被阻塞的进程可接触阻塞</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="信号量的使用">信号量的使用</h4>
<ul>
<li>
<p>互斥</p>
<ul>
<li>可以用==<strong>初始值为1</strong>==的二元信号量来实现进程间的互斥</li>
<li>一个进程在进入临界区之前执行<code>semWait</code>操作</li>
<li>退出临界区后再执行一个<code>semSignal</code>操作</li>
</ul>
</li>
<li>
<p>有限并发</p>
<ul>
<li>是指有n个进程并发的执行一个函数或者一个资源。</li>
<li>一个==初始值为c==的信号量可以实现这种并发。</li>
</ul>
</li>
<li>
<p>进程同步</p>
<ul>
<li>是指当一个进程<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>想要执行一个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>操作时，它只在进程<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">P_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>执行完<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">a_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>后，才会执行<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>操作。</li>
<li>可以用信号量如下实现：将信号量初始为0，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>执行<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>操作前执行一个<code>semWait</code>操作；而<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">P_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>执行<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">a_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>​​​操作后，执行一个<code>semSignal</code>操作。</li>
<li>这是一种先将自己置于阻塞低位，等待被唤醒的操作</li>
</ul>
</li>
<li>
<p>进程汇合</p>
<ul>
<li>
<p>任务<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>b</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">a_1,b_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>均完成后，对应的任务<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>b</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">a_2,b_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>才能发生</p>
</li>
<li>
<p>同名的操作天然满足发生的约束，不同命的操作利用信号量实现</p>
</li>
<li>
<p>将相应的信号量<code>aArrive,bArrive</code>初始化为0</p>
</li>
<li>
<pre><code class="language-c">// aStatemant
&#123;
    a1;
    aArrive.signal();
    bArrive.wait();
    a2;
&#125;
// bStatement
&#123;
    b1;
    bArrive.signal();
    aArrive.wait();
    b2;
&#125;
// 要理解本质的s.count
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 同步原语Barriers</span><br><span class="line"></span><br><span class="line">  - 对汇合进行泛化，相当于多个进程组的同步</span><br><span class="line"></span><br><span class="line">  - 使用两个信号量标记一起进入和一起离开</span><br><span class="line"></span><br><span class="line">  - ```c</span><br><span class="line">    // 记录进程是否达到barrier</span><br><span class="line">    turnstile = Semaphore(0);</span><br><span class="line">    // 记录进程是否离开barrier</span><br><span class="line">    turnstile2 = Semaphore(1);</span><br><span class="line">    // 对同步计数量的写锁</span><br><span class="line">    mutex = Semaphore(1);</span><br><span class="line">    </span><br><span class="line">    mutex.wait();</span><br><span class="line">    	// 到达barrier的进程数量++</span><br><span class="line">        count += 1;</span><br><span class="line">    	if(count == n) &#123;</span><br><span class="line">            // 离开barrier的信号量</span><br><span class="line">            t2.wait();</span><br><span class="line">            t.signal();</span><br><span class="line">        &#125;</span><br><span class="line">    mutex.signal();</span><br><span class="line">    </span><br><span class="line">    // 等待被唤醒</span><br><span class="line">    // 如果count不达到n，不会有任何唤醒</span><br><span class="line">    t.wait();</span><br><span class="line">    // 负责唤醒下一个</span><br><span class="line">    t.signal();</span><br><span class="line">    </span><br><span class="line">    mutex.wait();</span><br><span class="line">    	count -= 1;</span><br><span class="line">    	// 已经全部离开了barrier</span><br><span class="line">    	if(count == 0) &#123;</span><br><span class="line">            t.wait();</span><br><span class="line">            t2.signal();</span><br><span class="line">        &#125;</span><br><span class="line">    mutex.signal();</span><br><span class="line">    </span><br><span class="line">    t2.wait();</span><br><span class="line">    t2.signal();</span><br><span class="line">    // 全部离开了</span><br></pre></td></tr></table></figure>


</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="信号量集机制">信号量集机制</h3>
<p>同时需要多个资源的信号量操作</p>
<h4 id="AND型信号量集机制">AND型信号量集机制</h4>
<p>基本思想：将进程需要的所有共享资源一次全部分配给它；待该进程使用完后再一起释放。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">SP(S1, S2, … ,Sn) &#123;</span><br><span class="line">    <span class="keyword">if</span>(s1 &gt;= <span class="number">1</span> &amp;&amp; s2 &gt;=<span class="number">1</span> &amp;&amp; ... &amp;&amp; sn &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> i <span class="title function_">in</span> <span class="params">(<span class="number">1</span>,n+<span class="number">1</span>)</span> &#123;</span><br><span class="line">            P(si);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 等待被阻塞进程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等待所有临界资源都得到后，在开始进程的行为</span></span><br><span class="line">SV(S1, S2, … ,Sn) &#123;</span><br><span class="line">    <span class="keyword">for</span> i in range(<span class="number">1</span>,n+<span class="number">1</span>) &#123;</span><br><span class="line">        V(si);</span><br><span class="line">        <span class="comment">// 唤醒阻塞进程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="一般“信号量集”机制-SP-S-T-D">一般“信号量集”机制 SP(S,T,D)</h4>
<p>SP(S,T,D)基本思想：在AND型信号量集的基础上进行扩充：</p>
<ul>
<li>
<p>测试值为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">t_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>：用于信号量分配的阈值，即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>i</mi></msub><mo>&lt;</mo><msub><mi>t</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">S_i&lt;t_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，表示资源数量低于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">t_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>时，便不予分配</p>
</li>
<li>
<p>占用值为di：依次分配<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">d_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>个临界资源，即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>i</mi></msub><mo>=</mo><msub><mi>S</mi><mi>i</mi></msub><mo>−</mo><msub><mi>d</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">S_i = S_i - d_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>i</mi></msub><mo>=</mo><msub><mi>S</mi><mi>i</mi></msub><mo>+</mo><msub><mi>d</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">S_i = S_i +d_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>​</p>
</li>
<li>
<pre><code class="language-c">SP(s1, t1, d1, ..., sn, tn, dn) &#123;
    if(s1 &gt;= t1 &amp;&amp; s2 &gt;= t2 &amp;&amp; ... &amp;&amp; sn &gt;= tn) &#123;
        for i in (1,n+1) &#123;
            si = si - di;
        &#125;
    &#125; 
    else &#123;
        // 等待被阻塞进程
    &#125;
&#125;
// 等待所有临界资源都得到后，在开始进程的行为
SV(s1, t1, d1, ..., sn, tn, dn) &#123;
    for i in range(1,n+1) &#123;
        si = si + di;
        // 唤醒阻塞进程
    &#125;
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- $SP(S, d, d)$：表示每次申请d个资源，当资源数量少于d个时，便不予分配</span><br><span class="line"></span><br><span class="line">- $SP(S, 1, 1)$：表示互斥信号量</span><br><span class="line"></span><br><span class="line">- $SP(S, 1, 0)$：可作为一个可控开关</span><br><span class="line"></span><br><span class="line">  当$S&gt;=1$时，允许多个进程进入临界区；当$S=0$时禁止任何进程进入临界区</span><br><span class="line"></span><br><span class="line">### 管程</span><br><span class="line"></span><br><span class="line">&gt; 可以联想Java中的signal和wait操作，基本上是等价的</span><br><span class="line"></span><br><span class="line">信号量这种机制具有一些缺点，如用信号量及PV操作解决问题时，程序编写需要很高的技巧。如果没有合理地安排PV操作的位置，就会导致一些出错的结果，如出现死锁等问题。</span><br><span class="line"></span><br><span class="line">管程是在程序设计语言当中引入的一个成分，是一种**高级同步机制**。管程就是指管理共享变量以及对共享变量的操作过程，让它们支持并发。</span><br><span class="line"></span><br><span class="line">- 管程**是一种语言机制，定义了一种程序结构**，结构内的多个子程序（对象或模块）形成的多个工作线程互斥访问共享资源。这些共享资源一般是硬件设备或一群变量。</span><br><span class="line">  - 管程的名称</span><br><span class="line">  - 局部于管程内部的**共享数据结构（变量）说明**</span><br><span class="line">  - 对该数据结构进行操作的一组**互斥执行的过程**</span><br><span class="line">  - 对局部于管程内部的共享数据**设置初始值的语句**</span><br><span class="line">- 管程实现了在一个时间点，**最多只有一个线程在执行管程的某个子程序**。这种封装好的操作实现简化了程序设计。</span><br><span class="line">- 管程提供了一种机制，线程可以临时放弃互斥访问，等待某些条件得到满足后，重新获得执行权恢复它的互斥访问。</span><br><span class="line"></span><br><span class="line">==**管程和信号量是等价的，所谓等价指的是用管程能够实现信号量，也能用信号量实现管程。**==</span><br><span class="line"></span><br><span class="line">#### 管程的实现</span><br><span class="line"></span><br><span class="line">管程的实现具有**面向对象的思想**，定义了一个共享变量的数据结构和能对数据结构进行的操作（需要保证互斥）。在管程模型里，共享变量和对共享变量的操作是被封装起来的。</span><br><span class="line"></span><br><span class="line">1. 管程的名称；</span><br><span class="line">2. 局部于管程内部的共享数据结构（变量）说明；</span><br><span class="line">3. 对该数据结构进行操作的**一组互斥执行的过程**；</span><br><span class="line">4. 对局部于管程内部的共享数据**设置初始值**的语句。</span><br><span class="line"></span><br><span class="line">管程作为一种同步机制，需要解决三个问题</span><br><span class="line"></span><br><span class="line">1. 互斥：只能有一个进程可对其内部数据结构进行相应的操作，即==**管程进入是互斥的**，**由编译器来保证**（**管程是一个语言机制**）==。</span><br><span class="line"></span><br><span class="line">2. 同步：通过设置条件变量（CV）以及在条件变量上实施的`wait`和`signal`操作，它可以使一个进程或线程，当条件不满足/满足的时候在条件变量上等待/唤醒。</span><br><span class="line"></span><br><span class="line">3. 条件变量：为了**区别等待的不同原因，管程引入了条件变量**。</span><br><span class="line"></span><br><span class="line">   不同的条件变量，对应**不同原因的进程阻塞等待队列**，初始时为空。</span><br><span class="line"></span><br><span class="line">   条件变量上能作`wait`和`signal`原语操作，若条件变量名为X，则调用同步原语的形式为`wait(X)`和`signal(X)`</span><br><span class="line"></span><br><span class="line">#### 管程和信号量的区别</span><br><span class="line"></span><br><span class="line">- **条件变量的值不可增减**，P-V操作的信号量值可增减</span><br><span class="line">  - wait操作一定会阻塞当前进程；但P操作只有当信号量的值小于0时才会阻塞。</span><br><span class="line">  - **如果没有等待的进程，signal将丢失**；而V操作增加了信号量的值，不会丢失。</span><br><span class="line">- 访问条件变量必须拥有管程的锁</span><br><span class="line"></span><br><span class="line">#### 管程模型</span><br><span class="line"></span><br><span class="line">管程只是==保证了同一时刻只有一个进程在管程内活动==，即管程内定义的操作在同一时刻只被一个进程调用（由编译器实现)。</span><br><span class="line"></span><br><span class="line">但是这样并不能保证进程以设计的顺序执行，因此需要设置条件变量，让进入管程而无法继续执行的进程阻塞自己。</span><br><span class="line"></span><br><span class="line">Hasen模型、Hoare模型和MESA模型等解决的问题就是：==当后续的进程P唤醒被阻塞的进程Q时，哪一个应该先执行==：</span><br><span class="line"></span><br><span class="line">- Hoare模型：Q执行完成后P执行</span><br><span class="line">- MESA模型：P执行完成后Q执行（java的方式）</span><br><span class="line">- Hansen管程：规定唤醒操作时管程中**最后一个**可执行的操作</span><br><span class="line"></span><br><span class="line">##### Hoare模型</span><br><span class="line"></span><br><span class="line">###### 数据结构</span><br><span class="line"></span><br><span class="line">入口等待队列(entry queue)：因为管程是**互斥进入的**，所以当一个进程试图进入一个已被占用的管程时它应当**在管程的入口处等待**，因而在管程的入口处应当有一个进程等待队列，称作入口等待队列。</span><br><span class="line"></span><br><span class="line">紧急等待队列：管程内部由于相互唤醒造成的等待队列。</span><br><span class="line"></span><br><span class="line">如果进程Ｐ唤醒进程Ｑ，则Ｐ等待Ｑ继续，如果进程Ｑ在执行又唤醒进程Ｒ，则Ｑ等待Ｒ继续。</span><br><span class="line"></span><br><span class="line">如此，在管程内部，**由于执行唤醒操作，可能会出现多个等待进程**：已被唤醒，但由于管程的互斥进入而等待。因而还需要有一个进程等待队列，这个等待队列被称为**紧急等待队列**。它的优先级应当高于入口等待队列的优先级。</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202404170014411.png&quot; alt=&quot;image-20240417001445265&quot; style=&quot;zoom: 67%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">==每个条件变量表示一种等待原因，每个原因对应一个队列。==</span><br><span class="line"></span><br><span class="line">###### 操作原语</span><br><span class="line"></span><br><span class="line">同步操作原语wait和signal：针对条件变量x，`x.wait()`将自己阻塞在x队列中，`x.signal()`将x队列中的一个进程唤醒。</span><br><span class="line"></span><br><span class="line">- `x.wait()`：</span><br><span class="line">  - 如果紧急等待队列非空，则唤醒第一个等待者：释放了一个资源</span><br><span class="line">  - 否则释放管程的互斥权，执行此操作的进程排入x队列尾部</span><br><span class="line">  - 紧急等待队列与x队列的关系：紧急等待队列是由于管程的互斥进入而等待的队列，而x队列是**因资源被占用而等待**的队列</span><br><span class="line"></span><br><span class="line">- `x.signal()`：</span><br><span class="line">  - 如果x队列为空，则相当于空操作，执行此操作的进程继续</span><br><span class="line">  - 否则唤醒第一个等待者，执行`x.signal()`操作的进程排入紧急等待队列的尾部。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">###### 信号量</span><br><span class="line"></span><br><span class="line">1. 用于互斥的信号量`mutex`：保证管程本身只有一个进程进入</span><br><span class="line">   1. 进程==**调用管程中的任何过程时**==，应执行P(mutex)（\-\-）；进程退出管程时应执行V(mutex)（++）开放管程，以便让其他调用者进入。</span><br><span class="line">   2. 为了使进程在等待资源期间，其他进程能进入管程，故==在**wait操作中也必须执行V(mutex)**==，否则会妨碍其他进程进入管程，导致无法释放资源。</span><br><span class="line">2. 对于每个管程发出signal后挂起自身的信号量`next`</span><br><span class="line">   1. 凡发出signal操作的进程应该用P(next)**挂起自己**（Hoare管程为发出signal的进程等待执行），直到被释放进程退出管程或产生其他等待条件。</span><br><span class="line">   2. 进程在退出管程的过程前，须检查是否有别的进程在信号量next上等待，若有，则用V(next)唤醒它。`next-count`（初值为0），用来记录在next上等待的进程个数。</span><br><span class="line">3. 申请资源未被满足的信号量`x-sem`</span><br><span class="line">   1. 申请资源得不到满足时，执行P(x-sem)挂起。由于释放资源时，需要知道是否有别的进程在等待资源，用计数器`x-count`（初值为0）**记录等待资源的进程数**。</span><br><span class="line">   2. 执行signal操作时，应让等待资源的诸进程中的某个进程立即恢复运行，而不让其他进程抢先进入管程，这可以用V(x-sem)来实现</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">// 编译器对管程外部调用的出入口设置</span><br><span class="line">// 管程入口</span><br><span class="line">P(mutex);</span><br><span class="line">	// 管程的调用</span><br><span class="line">	// 如果有进程在等待队列等待</span><br><span class="line">	if(next_count &gt; 0)</span><br><span class="line">        V(next);</span><br><span class="line">	else</span><br><span class="line">        // 退出管程</span><br><span class="line">        V(mutex);</span><br><span class="line">// 管程出口</span><br><span class="line"></span><br><span class="line">// X.wait</span><br><span class="line">x_count++;</span><br><span class="line">if(next_count &gt; 0)</span><br><span class="line">    V(next);</span><br><span class="line">else</span><br><span class="line">    V(mutex);</span><br><span class="line">P(x_sem);</span><br><span class="line">x_count--;</span><br><span class="line"></span><br><span class="line">// X.signal</span><br><span class="line">if(X_count &gt; 0) &#123;</span><br><span class="line">    next_count++;</span><br><span class="line">    V(x_sem);</span><br><span class="line">    P(next);</span><br><span class="line">    next_count--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
<h2 id="进程通信的方法">进程通信的方法</h2>
<p>低级通信：<strong>只能传递状态和整数值（控制信息）</strong>，包括进程互斥和同步所采用的信号量和管程机制。</p>
<p>缺点：</p>
<ul>
<li>传送信息量小：效率低，每次通信传递的信息量固定，若传递较多信息则需要进行多次通信。</li>
<li>编程复杂：用户直接实现通信的细节，编程复杂，容易出错。</li>
</ul>
<p>高级通信：适用于分布式系统，基于共享内存的多处理机系统，单处理机系统，<strong>能够传送任意数量的数据</strong>，可以解决进程的同步问题和通信问题，主要包括三类：<strong>管道、共享内存、消息系统</strong>。</p>
<ul>
<li>管道（Pipe）及命名管道（Named pipe或FIFO）</li>
<li>消息队列（Message）</li>
<li>共享内存（Shared memory）</li>
<li>信号量（Semaphore）</li>
<li>套接字（Socket）</li>
<li>信号（Signal）</li>
</ul>
<h3 id="管道">管道</h3>
<p>分为有名管道和无名管道。其实质是<strong>内核中的一片缓存</strong></p>
<h4 id="无名管道">无名管道</h4>
<p>无名管道，或者就叫管道，由于无名，故不存储相应的路径，==只能用于具有亲缘关系的进程（父子进程或兄弟进程）之间的通信==。</p>
<p>==<strong>数据只能向一个方向流动</strong>；需要双方通信时，需要建立起两个管道。==</p>
<p>单独构成<strong>一种独立的文件系统</strong>：==管道<strong>对于管道两端的进程而言，就是一个文件</strong>==，但它不是普通的文件，它不属于某种文件系统，而是自立门户，单独构成一种文件系统，并且只存在在内存中。</p>
<p>数据的读出和写入：一个进程向管道中写的内容被管道另一端的进程读出。<strong>写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据</strong>。</p>
<h4 id="有名管道">有名管道</h4>
<p>也叫FIFO，带有先进先出的意思。</p>
<p>提供一个路径名与之关联，==<strong>以FIFO的文件形式存在于文件系统中</strong>==。这样，即使与FIFO的创建进程不存在亲缘关系的进程，==<strong>只要可以访问该路径，就能够彼此通过FIFO相互通信</strong>==：能够访问该路径的进程以及FIFO的创建进程之间。</p>
<p>FIFO严格遵循先进先出，对管道及FIFO的读总是从开始处返回数据，对它们的写则把数据添加到末尾。</p>
<h3 id="消息队列">消息队列</h3>
<p><code>send(destination,&amp;message)</code>和<code>receive(source,&amp;message)</code>是两个通信原语，由OS进行调用。</p>
<p><strong>消息队列是内核中的一个链表</strong>，一个消息就是链表的一个节点。</p>
<p>用户进程将数据传输到内核后，内核另外添加一些包括用户 ID、组 ID、进程 ID、优先级在内的信息后，打成的一个数据包称为消息。</p>
<p>允许一个或多个进程往消息队列中写入或读取消息，但是<strong>一个消息只能被一个进程读取，读取完毕后自动删除</strong>。</p>
<p>消息队列具有一定 FIFO 特性，也可以按照一些特定的方式读取。</p>
<p>消息队列的实现包括打开与创建、发送消息、读取消息、控制消息队列（获取或修改属性、销毁）。</p>
<img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202404170036582.png" alt="消息队列" style="zoom:50%;" />
<p>数据结构为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msqid_ds</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> <span class="title">msg_perm</span>;</span></span><br><span class="line">    <span class="type">msgqnum_t</span> msg_qnum;        <span class="comment">// the number of messages on queue</span></span><br><span class="line">    <span class="type">msglen_t</span>  msg_qbytes;      <span class="comment">// the max number of bytes on queue</span></span><br><span class="line">    <span class="type">pid_t</span>     msg_lspid;       <span class="comment">// the pid of the last msgsnd()</span></span><br><span class="line">    <span class="type">pid_t</span>     msg_lrpid;       <span class="comment">// the pid of the last msgrcv() </span></span><br><span class="line">    <span class="type">time_t</span>    msg_stime;       <span class="comment">// the last msgsnd() time</span></span><br><span class="line">    <span class="type">time_t</span>    msg_ctime;       <span class="comment">// last change time</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="共享内存">共享内存</h3>
<p>共享内存是==最有用的进程间通信方式==，通信效率高，其避免了其它形式的IPC必须执行的开销巨大的<strong>缓冲复制</strong>。</p>
<p>两个不同进程A、B共享内存的意义是，==<strong>同一块物理内存被映射到进程A、B各自的进程地址空间</strong>==。</p>
<p>当多个进程共享同一块内存区域，由于共享内存可以同时读但不能同时写，则==需要同步机制约束==。</p>
<p>进程之间在共享内存时，<strong>保持共享区域直到通信完毕</strong>。</p>
<h2 id="经典的进程同步和互斥问题">经典的进程同步和互斥问题</h2>
<ul>
<li>生产者－消费者问题</li>
<li>读者－写者问题</li>
<li>哲学家进餐问题</li>
</ul>
<h3 id="生产者消费者模型">生产者消费者模型</h3>
<p>本质是若干进程通过有限的共享缓冲区交换数据。</p>
<p>其中，“生产者”进程不断写入，而“消费者”进程不断读出；共享缓冲区共有N个；</p>
<p>==<strong>任何时刻只能有一个进程可对共享缓冲区进行操作</strong>。==</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Semaphore full = <span class="number">0</span>;		<span class="comment">// 产品数量</span></span><br><span class="line">Semaphore empty = n;	<span class="comment">// 空闲原料数量</span></span><br><span class="line">Semaphore mutex = <span class="number">1</span>;	<span class="comment">// 互斥锁</span></span><br><span class="line">ItemType buffer[<span class="number">0.</span>.n<span class="number">-1</span>];</span><br><span class="line"><span class="type">int</span> in = <span class="number">0</span>, out =<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">producer() &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="comment">// 生产产品nextp;</span></span><br><span class="line">        P(empty);</span><br><span class="line">            P(mutex);</span><br><span class="line">                buffer[in] = nextp;</span><br><span class="line">                in = (in + <span class="number">1</span>) MOD n;</span><br><span class="line">            V(mutex);</span><br><span class="line">        V(full);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">consumer() &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        P(full);</span><br><span class="line">            P(mutex);</span><br><span class="line">                nextc = buffer[out];</span><br><span class="line">                out = (out + <span class="number">1</span>) MOD n;</span><br><span class="line">            V(mutex);</span><br><span class="line">        V(empty);</span><br><span class="line">        <span class="comment">// 消费nextc中的产品</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="读者-写者问题">读者-写者问题</h3>
<p>对共享资源的读写操作，任一时刻“写者”最多只允许一个，而“读者”则允许多个。</p>
<p>读写、写写互斥，允许读读</p>
<img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202404241016227.png" alt="image-20240424101618992" style="zoom:67%;" />
<p>读进程的行为：</p>
<ul>
<li>系统中会有多个读进程同时访问共享数据。</li>
<li>可分为三类：第一个进入的读进程（占有资源），最后一个离开的读进程(释放资源)和其他读进程。</li>
<li>需要设置一个计数器readcount来记录读进程的数目。</li>
</ul>
<p>写进程的行为：排他性的使用资源。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> readcount=<span class="number">0</span>; <span class="comment">//“正在读”的进程数，初值是0。</span></span><br><span class="line">semaphore rmutex=<span class="number">1</span>; <span class="comment">//信号量，用于readcount的互斥。</span></span><br><span class="line">semaphore fmutex=<span class="number">1</span>; <span class="comment">//信号量，用于Data访问的互斥。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Reader</span></span><br><span class="line">P(rmutex);</span><br><span class="line">    <span class="keyword">if</span>(readcount == <span class="number">0</span>) &#123;</span><br><span class="line">        P(fmutex);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	readcount = readcount + <span class="number">1</span>;</span><br><span class="line">    V(rmutex);</span><br><span class="line">    	<span class="comment">// read</span></span><br><span class="line">    P(rmutex)</span><br><span class="line">    readcount = readcount - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">if</span>(readcount == <span class="number">0</span>) &#123;</span><br><span class="line">        V(fmutex);</span><br><span class="line">    &#125;</span><br><span class="line">V(rmutex)</span><br><span class="line">    </span><br><span class="line"><span class="comment">// Writer</span></span><br><span class="line">P(fmutex);</span><br><span class="line">	write</span><br><span class="line"><span class="title function_">V</span><span class="params">(fmutex)</span>;</span><br></pre></td></tr></table></figure>
<p>对读者有利，在高负载情况下，写者可能根本没机会写！需要设计一个均衡了读写的方法。</p>
<p>利用queue实现了写者优先算法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">semaphore fmutex = <span class="number">1</span>;		<span class="comment">// fmutex --&gt; access to file;</span></span><br><span class="line">semaphore rdcntmutex = <span class="number">1</span>;	<span class="comment">// rdcntmutex --&gt; access to readcount</span></span><br><span class="line">semaphore wtcntmutex = <span class="number">1</span>;	<span class="comment">// wtcntmutex --&gt; access to writecount</span></span><br><span class="line">semaphore <span class="built_in">queue</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> readcount = <span class="number">0</span>, writecount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">reader</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 设计queue实现写者优先</span></span><br><span class="line">        P(<span class="built_in">queue</span>);</span><br><span class="line">            P(rdcntmutex);</span><br><span class="line">                <span class="keyword">if</span>(readcount == <span class="number">0</span>)</span><br><span class="line">                    P(fmutex);</span><br><span class="line">                readcount = readcount + <span class="number">1</span>;</span><br><span class="line">            V(rdcntmutex);</span><br><span class="line">        V(<span class="built_in">queue</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Do read operation ...</span></span><br><span class="line">        P(rdcntmutex);</span><br><span class="line">            readcount = readcount - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(readcount == <span class="number">0</span>)</span><br><span class="line">            	V(fmutex);</span><br><span class="line">        V(rdcntmutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">writer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        P(wtcntmutex);</span><br><span class="line">            <span class="keyword">if</span>(writecount == <span class="number">0</span>)</span><br><span class="line">                P(<span class="built_in">queue</span>);</span><br><span class="line">            writecount = writecount + <span class="number">1</span>;</span><br><span class="line">        V(wtcntmutex);</span><br><span class="line">        </span><br><span class="line">        P(fmutex);</span><br><span class="line">        <span class="comment">//Do write operation ...</span></span><br><span class="line">        V(fmutex);</span><br><span class="line">        </span><br><span class="line">        P(wtcntmutex); </span><br><span class="line">            writecount = writecount - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>( writecount == <span class="number">0</span>)</span><br><span class="line">                V(<span class="built_in">queue</span>);</span><br><span class="line">        V(wtcntmutex); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>给定读写序列：r1,w1,w2,r2,r3,w3…</p>
<ul>
<li>读者优先：r1,r2,r3,w1,w2,w3…</li>
<li>写者优先：r1,w1,w2,w3,r2,r3…</li>
<li>读写公平：r1,w1,w2,r2,r3,w3…</li>
</ul>
<h3 id="哲学家进餐问题">哲学家进餐问题</h3>
<p>同时获取两个锁的死锁问题：设置获取锁的相应的顺序。</p>
<p>需要破除资源互斥、循环等待、保持等待。</p>
<h1>调度</h1>
<p>CPU调度：控制、协调多个进程对CPU的竞争。N个进程，M个CPU，OS如何进行合适的调度。</p>
<h2 id="基本概念-2">基本概念</h2>
<p>调度必然伴随着进程的切换：</p>
<ul>
<li>用户调用：来自程序的显式请求(如：打开文件)，该进程多半会被阻塞</li>
<li>陷阱：最末一条指令导致出错，会引起进程移至退出状态</li>
<li>中断：外部因素影响当前指令的执行，控制被转移至中断处理程序</li>
</ul>
<p>进程切换的流程：</p>
<ul>
<li>保存处理器的上下文，包括程序计数器和其它寄存器；</li>
<li>用新状态和其它相关信息更新正在运行进程的PCB；</li>
<li>把进程移至合适的队列-就绪、阻塞；</li>
<li>选择另一个要执行的进程；</li>
<li>更新被选中进程的PCB；</li>
<li>从被选中进程中重装入CPU 上下文。</li>
</ul>
<h3 id="调度类型">调度类型</h3>
<p><strong>高级调度</strong>/宏观调度/作业调度：从<strong>用户工作流程</strong>的角度，一次提交的若干个作业，对每个作业进行调度。时间上通常是分钟、小时或天。</p>
<p><strong>中级调度</strong>/内外存交换：从<strong>存储器资源</strong>的角度。将进程的部分或全部换出到外存上，将当前所需部分换入到内存。指令和数据必须在内存里才能被CPU直接访问。</p>
<p><strong>低级调度</strong>/微观调度/<strong>进程或线程调度</strong>：从<strong>CPU资源</strong>的角度，执行的单位。时间上通常是毫秒。因为执行频繁，要求在实现时达到高效率。</p>
<ul>
<li>抢占式</li>
<li>非抢占式
<ul>
<li>时间片原则</li>
<li>优先权原则</li>
<li>短作业优先</li>
</ul>
</li>
</ul>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202404260819724.png" alt="三级调度机制"></p>
<h3 id="性能评价标准">性能评价标准</h3>
<ul>
<li>
<p>==周转时间：作业**从提交到完成（得到结果）**所经历的时间。==</p>
</li>
<li>
<p>周转时间=完成时刻-提交时刻</p>
<ul>
<li>
<p>包括：在收容队列中等待，CPU上执行，就绪队列和阻塞队列中等待，结果输出等待</p>
</li>
<li>
<p>外存等待时间、就绪等待时间、CPU执行时间、IO操作时间</p>
</li>
</ul>
</li>
<li>
<p>==带权周转时间：周转时间/服务时间==</p>
<ul>
<li>权是服务时间的倒数，服务时间越短反而权重越大，更关注同等服务时间下谁的周转时间长</li>
<li>服务时间就是执行时间</li>
</ul>
</li>
<li>
<p>==平均周转时间：作业周转时间之和/作业数==</p>
</li>
<li>
<p>==平均带权周转时间：作业带权周转时间之和/作业数==</p>
</li>
<li>
<p>响应时间：用户输入<strong>一个请求（如击键）到系统给出首次响应</strong>（如屏幕显示）的时间</p>
</li>
<li>
<p>截止时间：开始截止时间和完成截止时间</p>
</li>
<li>
<p>优先级：可以使关键任务达到更好的指标。</p>
</li>
<li>
<p>公平性：不因作业或进程本身的特性而使上述指标过分恶化。如长作业等待很长时间。</p>
</li>
<li>
<p>吞吐量：<strong>单位时间内所完成的作业数</strong>，跟作业本身特性和调度算法都有关系</p>
<ul>
<li>吞吐量=作业数/总执行时间</li>
<li>批处理系统</li>
<li>平均周转时间不是吞吐量的倒数，因为并发执行的作业在时间上可以重叠。</li>
</ul>
</li>
</ul>
<h2 id="基本调度">基本调度</h2>
<h3 id="进程优先级">进程优先级</h3>
<p>优先级表现了进程的重要性和紧迫性</p>
<p>优先数是一个数值，反映了某个优先级</p>
<ul>
<li>
<p>静态优先级：进程创建时指定，运行过程中不再改变</p>
</li>
<li>
<p>动态优先级：进程创建时指定了一个优先级，运行过程中可以动态变化。</p>
<p>如：等待时间较长的进程可提升其优先级。</p>
</li>
</ul>
<h3 id="进程就绪队列">进程就绪队列</h3>
<p>当由多个就绪进程等待调度时，如何组织合适的队列，让进程能够以一定顺序被合理调度</p>
<h4 id="按优先级排队方式">按优先级排队方式</h4>
<p>创建多个进程后按照不同的优先级进行排列，CPU调度优先级较高的进程进行执行。</p>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202404260833930.png" alt="按优先级排队"></p>
<h4 id="动态优先级队列">动态优先级队列</h4>
<blockquote>
<p>这个名字是自己起的</p>
</blockquote>
<p>所有进程创建之后都进入到第一级就绪队列，<strong>随着进程的运行，可能会降低某些进程的优先级</strong>。</p>
<p>如某些进程的时间片用完了，那么就会将其降级。</p>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202404260834779.png" alt="动态优先级队列"></p>
<h3 id="占用CPU的方式">占用CPU的方式</h3>
<p><strong>不可抢占式方式</strong>：一旦处理器分配给一个进程，它就一直占用处理器，直到该进程<strong>自己因调用原语操作或等待IO等原因而进入阻塞状态</strong>，或<strong>时间片用完时</strong>才让出处理器，重新进行</p>
<p><strong>抢占式方式</strong>：就绪队列中==一旦有<strong>优先级高于当前运行进程优先级的进程存在</strong>时==，便立即进行进程调度，把处理器转给优先级高的进程</p>
<h3 id="进程的分类方式">进程的分类方式</h3>
<p>一种方式</p>
<ul>
<li>IO密集型：频繁地进行IO操作，通常会发挥很多时间等待IO操作完成</li>
<li>CPU密集型：计算量大，需要大量的CPU时间</li>
</ul>
<p>另一种方式：</p>
<p>批处理进程（Batch Process)</p>
<ul>
<li>无需与用户交互，通常<strong>在后台运行</strong></li>
<li>不需很快的响应</li>
<li>典型的批处理程序：编译器、科学计算</li>
</ul>
<p>交互式进程（Interactive Process)</p>
<ul>
<li>与用户交互频繁，因此要花很多时间<strong>等待用户输入</strong></li>
<li>响应时间要快，平均延迟要低于50~150ms</li>
<li>典型的交互式进程：Word、触控型GUI</li>
</ul>
<p>实时进程（Real-time Process)</p>
<ul>
<li>有实时要求，<strong>不能被低优先级进程阻塞</strong></li>
<li>响应时间要短且要稳定</li>
<li>典型的实时进程：视频/音频、控制类</li>
</ul>
<h2 id="批处理系统的常用调度算法">批处理系统的常用调度算法</h2>
<p>==批处理系统：无需与用户交互，通常<strong>在后台运行</strong>，不需要很快的响应速度==</p>
<ul>
<li>先来服务FCFS</li>
<li>最短作业优先SJF</li>
<li>最短剩余时间优先FRTF</li>
<li>最高响应比优先HRRF</li>
</ul>
<h3 id="先来服务FCFS">先来服务FCFS</h3>
<p>按照作业<strong>提交或进程变为就绪状态的先后次序</strong>，分派CPU。</p>
<p>==<strong>不可抢占式</strong>==：当前作业或进程占用CPU，<strong>直到执行完或阻塞</strong>，才出让CPU。在作业或进程唤醒后（如IO完成），并不立即恢复执行，通常等到当前作业或进程出让CPU。</p>
<p>最简单的算法</p>
<ul>
<li>比较有利于长作业，而不利于短作业。</li>
<li><strong>有利于CPU繁忙的作业</strong>，不利于IO繁忙的作业：会频繁地陷入等待其他进程的等待时间中。</li>
</ul>
<h3 id="短作业优先SJF">短作业优先SJF</h3>
<p>对FCFS算法的改进，其目标是减少平均周转时间。</p>
<p>对预计执行时间短的作业（进程）优先分派处理机。</p>
<p>为==非抢占式==，通常后来的短作业<strong>不抢先正在执行的作业</strong>。</p>
<p>优点：</p>
<ul>
<li>比FCFS改善平均周转时间和平均带权周转时间，缩短作业的等待时间；</li>
<li>提高系统的吞吐量；</li>
</ul>
<p>缺点：</p>
<ul>
<li><strong>对长作业非常不利，可能长时间得不到执行</strong>；</li>
<li>未能依据作业的紧迫程度来划分执行的优先级；</li>
<li>难以准确估计作业（进程）的执行时间，从而影响调度性能。</li>
</ul>
<h3 id="最短剩余时间优先FRTF">最短剩余时间优先FRTF</h3>
<p>将短作业优先进行改进，改进为==<strong>抢占式</strong>==：当一个新就绪的进程比当前运行进程具有更短的完成时间，<strong>系统抢占当前进程</strong>，选择新就绪的进程执行。</p>
<p>缺点：源源不断的短任务到来，可能<strong>使长的任务长时间得不到运行</strong>，导致产生“饥饿”现象。</p>
<h3 id="最高响应比优先HRRF">最高响应比优先HRRF</h3>
<p>是FCFS算法和SJF算法的折中：<strong>既考虑作业等待时间，又考虑作业的运行时间</strong>，既照顾短作业又不使长作业的等待时间过长，改善了调度性能。</p>
<p>在每次选择作业投入运行时，先计算后备作业队列中每个作业的响应比RP，然后选择其值最大的作业投入运行。</p>
<p>相应比RP定义为：==<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>RP</mtext><mo>=</mo><mfrac><mtext>已等待时间＋要求运行时间</mtext><mtext>要求运行时间</mtext></mfrac><mo>=</mo><mn>1</mn><mo>+</mo><mfrac><mtext>已等待时间</mtext><mtext>要求运行时间</mtext></mfrac></mrow><annotation encoding="application/x-tex">\text{RP}=\frac{\text{已等待时间＋要求运行时间}}{\text{要求运行时间}}=1+\frac{已等待时间}{要求运行时间}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">RP</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord cjk_fallback mtight">要求运行时间</span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord cjk_fallback mtight">已等待时间＋要求运行时间</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">要求运行时间</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">已等待时间</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>==</p>
<ul>
<li>短作业容易得到较高的响应比</li>
<li>长作业等待时间足够长后，也将获得足够高的响应比</li>
<li><strong>饥饿现象不会发生</strong></li>
</ul>
<p>每次计算各道作业的响应比会有一定的时间开销，性能比SJF略差。</p>
<h2 id="交互式系统的调度算法">交互式系统的调度算法</h2>
<p>==交互式系统：与用户交互频繁，因此要花很多时间<strong>等待用户输入</strong>。响应时间要快。==</p>
<ul>
<li>时间片轮转算法RR</li>
<li>优先级算法PS</li>
<li>多级队列算法MQ</li>
<li>多级反馈队列算法MFQ</li>
</ul>
<h3 id="时间片轮转算法RR">时间片轮转算法RR</h3>
<ol>
<li>将系统中所有的就绪进程按照先来服务的顺序，排成一个队列。</li>
<li>每次调度时将CPU分派给<strong>队首进程</strong>，让其执行一个时间片。时间片的长度从几个ms到几百ms。</li>
<li>在一个时间片结束时，发生<strong>时钟中断</strong>。调度程序据此暂停当前进程的执行，<strong>将其送到就绪队列的末尾</strong>，并通过上下文切换执行当前的队首进程。</li>
<li>==进程可以未使用完一个时间片，就出让CPU（如阻塞）==。</li>
</ol>
<p>对于时间片的安排：</p>
<ul>
<li>过长–&gt;退化为FCFS算法，进程在一个时间片内都执行完，响应时间长。</li>
<li>过短–&gt;用户的一次请求需要多个时间片才能处理完，上下文切换次数增加，响应时间长。</li>
</ul>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202404260934685.png" alt="image-20240426093407448"></p>
<p>T（响应时间）=N（进程数目）*q（时间片）</p>
<p>系统的处理能力：应当使用户输入<strong>通常在一个时间片内能处理完</strong>，否则使响应时间、平均周转时间和平均带权周转时间延长。</p>
<h3 id="优先级算法PS">优先级算法PS</h3>
<p>平衡各进程对相应时间的要求，适用于作业调度和进程调度。</p>
<p>分为抢占式和非抢占式。</p>
<ul>
<li>静态优先级：创建进程时就确定，直到进程终止前都不改变
<ul>
<li>进程类型：系统进程优先级较高</li>
<li>对资源的需求：<strong>对CPU和内存需求较少的进程，优先级较高</strong></li>
<li>用户要求：紧迫程度和付费多少</li>
</ul>
</li>
<li>动态优先级：在创建进程时赋予的优先级，在进程运行过程中<strong>可以自动改变</strong>，以便获得更好的调度性能
<ul>
<li>在就绪队列中，<strong>等待时间延长则优先级提高</strong>，从而使优先级较低的进程在等待足够的时间后，其优先级提高到可被调度执行；</li>
<li><strong>进程每执行一个时间片，就降低其优先级</strong>，从而一个进程持续执行时，其优先级降低到出让CPU。</li>
</ul>
</li>
</ul>
<h3 id="多级队列算法MQ">多级队列算法MQ</h3>
<p>引入多个就绪队列，通过<strong>各队列的区别对待</strong>，达到一个综合的调度目标</p>
<p>根据作业或进程的性质或类型的不同，将就绪队列再分为<strong>若干个子队列</strong>。每个作业固定归入一个队列</p>
<p>==不同队列可有<strong>不同的优先级、时间片长度、调度策略</strong>等==。</p>
<p>在运行过程中还可改变进程所在队列。如：系统进程、用户交互进程、批处理进程等</p>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202404271703236.png" alt="多队列算法"></p>
<h3 id="多级反馈队列算法MFQ">多级反馈队列算法MFQ</h3>
<p>设置多个就绪队列，分别赋予不同的优先级。每个队列执行时间片的长度也不同，规定<strong>优先级越低则时间片越长</strong>（如逐级加倍）。为==抢占式==。</p>
<ol>
<li>新进程进入内存后，先投入最高优先级队列的末尾，按FCFS算法调度；</li>
<li>若按高优先级队列一个时间片未能执行完，则降低投入到次优先级队列的末尾，同样按FCFS算法调度；</li>
<li>直至降低到最后的队列，按“时间片轮转”算法调度直到完成。</li>
</ol>
<p>==<strong>仅当较高优先级的队列为空，才调度较低优先级的队列中的进程执行</strong>。==</p>
<p>如果进程执行时有新进程进入较高优先级的队列，则==<strong>抢先执行新进程</strong>==，并把被抢先的进程投入原队列的末尾。</p>
<p>优点：</p>
<ul>
<li>为提高系统吞吐量和缩短平均周转时间而<strong>照顾短进程</strong>：在高优先级队列中优先被执行</li>
<li>为获得较好的IO设备利用率和缩短响应时间而照顾IO型进程</li>
<li>不必估计进程的执行时间，动态调节</li>
</ul>
<p>对于不同类型进程：</p>
<ul>
<li>IO型进程：让其进入最高优先级队列，以<strong>及时响应IO交互</strong>。==通常执行一个小时间片，要求可处理完一次IO请求的数据==，然后转入到阻塞队列。</li>
<li>计算型进程：每次都执行完时间片，进入更低级队列。最终采用最大时间片来执行，减少调度次数。</li>
<li>IO次数不多，而主要是CPU处理的进程：在IO完成后，放回IO请求时离开的队列，以免每次都回到最高优先级队列后再逐次下降。</li>
<li>为适应一个进程在不同时间段的运行特点，==IO完成时，提高优先级；时间片用完时，降低优先级==；</li>
</ul>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202404271709769.png" alt="多级反馈队列"></p>
<h3 id="优先级倒置现象">优先级倒置现象</h3>
<p>优先级倒置：高优先级进程/线程被低优先级进程/线程延迟或阻塞</p>
<p>假设存在ABC三个进程，优先级为A&gt;B&gt;C，存在一种临界资源X，由A和C共享：当C访问X时，A被阻塞，而由相应的优先级算法，B也得不到调度，致使延长了被阻塞的时间。</p>
<p>解决优先级倒置现象的方法有：</p>
<ul>
<li>优先级置顶</li>
<li>优先级继承</li>
</ul>
<h4 id="优先级置顶：低优先级变为最高优先级">优先级置顶：低优先级变为最高优先级</h4>
<p>优先级置顶是解决优先级倒置现象的一种方法。</p>
<p>置顶：访问临界区资源的进程拥有最高的优先级。相应进程进入临界区后，处理机就不允许被抢占。</p>
<ul>
<li>如果系统中的临界区都较短且不多，该方法是可行的。</li>
<li>但如果C的临界区非常长，则高优先级进程A仍会等待很长的时间，其效果无法令人满意。</li>
</ul>
<h4 id="优先级继承：低优先级变为新进入的高优先级">优先级继承：低优先级变为新进入的高优先级</h4>
<p>继承：在低优先级进程访问临界区时，<strong>继承对应的高优先级进程的优先级</strong>，一直保持到退出临界区。</p>
<h2 id="实时系统的调度算法">实时系统的调度算法</h2>
<p>实时系统是一种时间起着主导作用的系统。要求计算机<strong>对外部的输入有较快的反馈</strong>，必须在一个确定的时间范围内恰当地做出反应。</p>
<p>实时系统被分为硬实时系统和软实时系统。</p>
<ul>
<li>硬实时要求<strong>绝对满足截止时间要求</strong>（如：汽车和飞机的控制系统）</li>
<li>软实时可以偶尔不满足（如：视频/音频程序）。</li>
</ul>
<p>实时系统通常将对不同刺激的响应指派给不同的进程（任务），并且每个进程的行为是可提前预测的。</p>
<h3 id="基本概念-3">基本概念</h3>
<p>相关术语：</p>
<ul>
<li>任务集：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>=</mo><mrow><msub><mi>t</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>t</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>t</mi><mi>n</mi></msub></mrow></mrow><annotation encoding="application/x-tex">S={t_1,t_2,...,t_n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8095em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></li>
<li>任务集中的任务周期分别为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>T</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>T</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">T_1,T_2,...,T_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li>
<li>执行时间分别为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>c</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>c</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">c_1,c_2,...,c_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li>
<li>截至周期：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>D</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>D</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">D_1,D_2,...,D_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，通常有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mi>i</mi></msub><mo>=</mo><msub><mi>T</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">D_i=T_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li>
<li>CPU利用率：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><mfrac><msub><mi>c</mi><mi>i</mi></msub><msub><mi>T</mi><mi>i</mi></msub></mfrac></mrow><annotation encoding="application/x-tex">U=\sum_{i=1}^n\frac{c_i}{T_i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2494em;vertical-align:-0.4451em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8043em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7115em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:-0.1389em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4101em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4451em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li>
</ul>
<p>前提条件：</p>
<ul>
<li>任务集S是已知的；</li>
<li>所有任务都是周期性的，周期为T，必须在限定的时限D内完成；</li>
<li><strong>任务之间都是独立的</strong>，每个任务不依赖于其他任务；</li>
<li>每个任务的运行时间c是不变的；</li>
<li>调度、任务切换的时间忽略不计。</li>
</ul>
<h3 id="静态调度算法">静态调度算法</h3>
<p>通过对所有周期性任务的<strong>分析预测</strong>（到达时间、运行时间、结束时间、任务间的优先关系），事先确定一个固定的调度方案。</p>
<ul>
<li>无任何计算，按固定方案进行，开销最小；</li>
<li>无灵活性，只适用于完全固定的任务场景。</li>
</ul>
<h3 id="单调速率调度RMS">单调速率调度RMS</h3>
<p>任务的<strong>周期越小</strong>，其优先级越高，优先级最高的任务最先被调度。如果两个任务的优先级一样，当调度它们时，RM算法将随机选择一个调度</p>
<p>单调速率（RM）调度算法采用==抢占式的、静态优先级的策略==，调度周期性任务。</p>
<p>其中心思想为：有一被调度任务集S，对于周期T最短的任务，其任务优先级P最高，即<strong>优先级与周期成反比</strong>。</p>
<p>当较低优先级的进程正在运行且较高优先级的进程可以运行时，<strong>较高优先级进程会抢占低优先级</strong>。</p>
<p>RM算法有如下的限制：</p>
<ol>
<li>所有具有硬时限的任务均为周期任务，且<strong>周期等于时限</strong>。</li>
<li>所有具有硬时限的任务必须在其<strong>时限到来前结束</strong>。</li>
<li>所有具有硬时限的任务<strong>相互独立</strong>。</li>
<li>所有具有硬时限的任务均具有恒定的运行时间。</li>
<li>系统中所有非周期任务均为软实时任务，它们的执行超越死限对系统正常运行没有影响</li>
</ol>
<p>已被证明是单处理器下的<strong>最优静态调度算法</strong>，具有开销小、灵活性好的特点。</p>
<h3 id="最早截止期调度EDF">最早截止期调度EDF</h3>
<p>任务的<strong>绝对截止时间越早</strong>，其优先级越高，优先级最高的任务最先被调度。如果两个任务的优先级一样，当调度它们时，EDF算法将随机选择一个调度。</p>
<p>这里的截止时间是，当前运行情况下，进程需要进行强制切换的截止时期，会随着进程的周期性运行周期性变化。</p>
<p>在每个任务的周期处进行调度。</p>
<h2 id="多处理机调度">多处理机调度</h2>
<p>多处理机的==调度单位广泛采用线程==。注重<strong>整体的运行效率</strong>，也因而有更多样的调度算法。</p>
<h3 id="非对称多处理系统AMP">非对称多处理系统AMP</h3>
<p>多处理器系统中各个处理器的地位不同。采用主-从处理机系统，由<strong>主处理机管理一个公共就绪队列</strong>，并分派进程给从处理机执行。</p>
<p>各个处理机有固定分工，如执行OS的系统功能，IO处理，应用程序。</p>
<p>非对称式具有有潜在的不可靠性，如主机故障造成系统崩溃。</p>
<h3 id="对称式多处理系统SMP">对称式多处理系统SMP</h3>
<p>多处理器系统中，各个处理器的地位相同。</p>
<p>按控制方式，SMP调度算法可分为集中控制和分散控制。</p>
<h4 id="集中控制">集中控制</h4>
<ul>
<li>静态调度
<ul>
<li>每个CPU设立一个就绪队列，进程从开始执行到完成，都在同一个CPU上。</li>
<li>优点：调度算法开销小。</li>
<li>缺点：容易出现忙闲不均</li>
</ul>
</li>
<li>动态调度
<ul>
<li>各个CPU<strong>采用一个公共就绪队列</strong>，队首进程每次分派到<strong>当前空闲的CPU</strong>上执行。可防止系统中多个处理器忙闲不均。</li>
</ul>
</li>
</ul>
<h4 id="分散控制">分散控制</h4>
<ul>
<li>
<p>自调度：各个处理机自行在就绪队列中取任务。</p>
<ul>
<li>
<p>各个CPU采用一个<strong>公共就绪队列</strong>，每个处理机都可以从队列中选择适当进程来执行。需要对就绪队列的数据结构进行<strong>互斥访问控制</strong>。</p>
<p>生产者-消费者模型</p>
</li>
<li>
<p>是最常用的算法，实现时易于移植，==<strong>采用单处理机的调度技术</strong>==。</p>
</li>
<li>
<p>优点：不需要专门的处理机从事任务分派工作。</p>
</li>
<li>
<p>缺点: 当处理机个数较多时，<strong>对就绪队列的访问可能成为系统的瓶颈</strong>。</p>
</li>
</ul>
</li>
<li>
<p>成组调度</p>
<ul>
<li>将一个进程中的<strong>一组线程</strong>，每次分派时同时到一组处理机上执行，在剥夺处理机时也同时<strong>对这一组线程进行</strong>。</li>
<li>优点：
<ul>
<li>通常这样的一组线程<strong>在应用逻辑上相互合作</strong>，成组调度<strong>提高了这些线程的执行并行度</strong>，有利于减少阻塞和加快推进速度，最终提高系统吞吐量。</li>
<li>每次调度可以完成多个线程的分派，在系统内线程总数相同时能够减少调度次数，从而减少调度算法的开销。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>专用处理机调度</p>
<ul>
<li>为进程中的<strong>每个线程都固定分配一个CPU</strong>，直到该线程执行完成。</li>
<li>适用于CPU数量众多的高度并行系统，单个CPU利用率已不太重要</li>
<li>缺点：线程阻塞时，造成CPU的闲置。</li>
<li>优点：<strong>线程执行时不需切换</strong>，相应的开销可以大大减小，推进速度更快。</li>
</ul>
</li>
</ul>
<h1>死锁</h1>
<p>定义：由于资源占用的互斥，当某个进程提出资源申请之后，使得一些进程在无外力协助的情况下，永远分配不到必需的资源而无法运行。</p>
<ul>
<li>可剥夺资源：是指某进程在获得这类资源后，该资源可以再被其他进程或系统剥夺。如CPU，内存；</li>
<li>非可剥夺资源：当系统把这类资源分配给某进程后，再不能强行收回，<strong>只能在进程用完后自行释放</strong>。如磁带机、打印机；</li>
<li>临时性资源：这是指由一个进程产生，被另一个进程使用，<strong>短时间后便无用的资源</strong>，故也称为消耗性资源。如消息、中断；</li>
</ul>
<h2 id="死锁的产生">死锁的产生</h2>
<p>进程推进顺序不当竞争资源不当可能会造成死锁</p>
<p>死锁的四个必要条件：</p>
<ol>
<li>互斥条件：指进程对所分配到的资源进行<strong>排它性使用</strong>，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。</li>
<li>请求和保持条件：指进程<strong>已经保持至少一个资源，但又提出了新的资源请求</strong>，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。</li>
<li>不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，<strong>只能在使用完时由自己释放</strong>。</li>
<li><strong>环路等待条件</strong>：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><msub><mi>P</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>P</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>P</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>P</mi><mi>n</mi></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{P_0,P_1,P_2,...,P_n\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span>中的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">P_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>正在等待一个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">P_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>占用的资源；<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">P_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>正在等待<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">P_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>占用的资源，……，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">P_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>正在等待已被<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">P_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>占用的资源。</li>
</ol>
<h2 id="处理死锁的基本方法">处理死锁的基本方法</h2>
<h3 id="预防死锁">预防死锁</h3>
<ol>
<li>
<p>打破互斥条件：即<strong>允许进程同时访问某些资源</strong>。</p>
</li>
<li>
<p>打破占有且申请条件：可以实行资源预先分配策略。</p>
<p>只有当系统能够满足当前进程的全部资源需求时，<strong>才一次性地将所申请的资源全部分配给该进程，否则不分配任何资源</strong>。</p>
<p>由于运行的进程已占有了它所需的全部资源，所以不会发生占有资源又申请资源的现象，因此不会发生死锁。</p>
<p>缺点为：</p>
<ul>
<li>很多是否进程所需要的资源是不可预测的，无法直到可能用到的全部资源</li>
<li>资源利用率低</li>
<li>降低了进程的并发性</li>
</ul>
</li>
<li>
<p>打破不可剥夺条件：即<strong>允许进程强行从占有者那里夺取某些资源</strong>。</p>
<p>当一个进程已占有了某些资源，它又申请新的资源，当不能立即被满足时，<strong>须释放所占有的全部资源，以后再重新申请</strong>。</p>
<p>它所释放的资源可以分配给其它进程。这就相当于该进程占有的资源被隐蔽地强占了。</p>
<p>这种预防死锁的方法实现起来困难，会降低系统性能。</p>
</li>
<li>
<p>打破循环等待条件：实行资源有序分配策略。</p>
<p>==把资源事先分类编号，按号有序分配，使进程在申请，占用资源时不会形成环路。==</p>
<p>所有进程对资源的请求必须严格按资源序号递增的顺序提出。进程占用了小号资源，才能申请大号资源，就不会产生环路，从而预防了死锁。</p>
<p>资源的利用率和系统吞吐量都有很大提高，但存在以下缺点：</p>
<ul>
<li>限制了进程对资源的请求，<strong>同时给系统中所有资源合理编号也是件困难事</strong>，并增加了系统开销；</li>
<li>为了遵循按编号申请的次序，暂不使用的资源也需要提前申请，从而增加了进程对资源的占用时间。</li>
</ul>
</li>
</ol>
<h3 id="避免死锁">避免死锁</h3>
<p><strong>死锁预防</strong>是排除死锁的<strong>静态策略</strong>，它使产生死锁的四个必要条件不能同时具备，从而对进程申请资源的活动加以限制，以保证死锁不会发生。</p>
<p><strong>死锁避免</strong>是排除死锁的<strong>动态策略</strong>，它不限制进程有关资源的申请，而是对进程所发出的<strong>每一个申请资源命令加以动态地检查</strong>，并根据检查结果决定是否进行资源分配。即分配资源时判断是否会出现死锁，有则加以避免。如不会死锁，则分配资源。</p>
<p>安全序列：若对于每一个进程<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，它需要的<strong>附加资源</strong>可以被系统中<strong>当前可用资源</strong>加上所有其他进程<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">P_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>当前占有资源之和所满足，则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><msub><mi>P</mi><mn>1</mn></msub><mtext>，</mtext><msub><mi>P</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>P</mi><mi>n</mi></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{P_1，P_2,...,P_n\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">，</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span>为一个安全序列。</p>
<p>所谓系统是安全的，是指系统中的所有进程能够<strong>按照某一种次序分配资源</strong>，并且依次地运行完毕，这种<strong>进程序列</strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><msub><mi>P</mi><mn>1</mn></msub><mtext>，</mtext><msub><mi>P</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>P</mi><mi>n</mi></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{P_1，P_2,...,P_n\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">，</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span>就是<strong>安全序列</strong>。如果存在这样一个安全序列，则系统是安全的；如果系统不存在这样一个安全序列，则系统是不安全的。</p>
<ul>
<li>安全状态：系统存在一个进程执行序列<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&lt;</mo><msub><mi>p</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>p</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>p</mi><mi>n</mi></msub><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">&lt;p_1,p_2,...p_n&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span></span></span></span>可顺利完成</li>
<li>不安全状态：不存在可完成的序列</li>
</ul>
<h4 id="银行家算法">银行家算法</h4>
<p>设n为进程数量，m为资源类型数量：</p>
<ul>
<li>可利用资源向量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>v</mi><mi>a</mi><mi>i</mi><mi>l</mi><mi>a</mi><mi>b</mi><mi>l</mi><mi>e</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mo stretchy="false">)</mo><mrow><mi>m</mi><mo>∗</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">Available=()_{m*1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">ai</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">ab</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mbin mtight">∗</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>v</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">Av[i]=k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>表示系统中还有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">R_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>类资源k个</li>
<li>最大需求矩阵<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi>a</mi><mi>x</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mo stretchy="false">)</mo><mrow><mi>n</mi><mo>∗</mo><mi>m</mi></mrow></msub></mrow><annotation encoding="application/x-tex">Max=()_{n * m}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1757em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">∗</span><span class="mord mathnormal mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">M[i][j]=k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>表示第i个进程对<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">R_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>​类资源的最大需求为k</li>
<li>分配矩阵<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>l</mi><mi>l</mi><mi>o</mi><mi>c</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mo stretchy="false">)</mo><mrow><mi>n</mi><mo>∗</mo><mi>m</mi></mrow></msub></mrow><annotation encoding="application/x-tex">Allocation=()_{n*m}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.01968em;">ll</span><span class="mord mathnormal">oc</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1757em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">∗</span><span class="mord mathnormal mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>l</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">Al[i][j]=k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>表示第i个进程<strong>已经被分配到</strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">R_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>类资源k个</li>
<li>需求矩阵<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mi>e</mi><mi>e</mi><mi>d</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mo stretchy="false">)</mo><mrow><mi>n</mi><mo>∗</mo><mi>m</mi></mrow></msub></mrow><annotation encoding="application/x-tex">Need=()_{n*m}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal">ee</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1757em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">∗</span><span class="mord mathnormal mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">N[i][j]=k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>表示第i个进程还需要<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">R_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>​类资源k个</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mi>e</mi><mi>e</mi><mi>d</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>M</mi><mi>a</mi><mi>x</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>−</mo><mi>A</mi><mi>l</mi><mi>l</mi><mi>o</mi><mi>c</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">Need[i][j]=Max[i][j]-Allocation[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal">ee</span><span class="mord mathnormal">d</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.01968em;">ll</span><span class="mord mathnormal">oc</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span></li>
</ul>
<p>判断安全状态的步骤：对于第i个进程</p>
<ol>
<li>
<p>如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi>a</mi><mi>x</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>&lt;</mo><mo>=</mo><mi>N</mi><mi>e</mi><mi>e</mi><mi>d</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">Max[i]&lt;=Need[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal">ee</span><span class="mord mathnormal">d</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span>，则转向步骤2，否则认为出错</p>
</li>
<li>
<p>如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi>a</mi><mi>x</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>&lt;</mo><mo>=</mo><mi>A</mi><mi>v</mi><mi>a</mi><mi>i</mi><mi>l</mi><mi>a</mi><mi>b</mi><mi>l</mi><mi>e</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">Max[i]&lt;=Available[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">ai</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">ab</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span>，则转向步骤3，否则认为出错</p>
</li>
<li>
<p>尝试把资源分配给第i个进程。完成分配后，检查系统是否安全</p>
<p>安全：之后的所有进程能够顺利结束</p>
</li>
</ol>
<h4 id="进程资源图">进程资源图</h4>
<p>用有向图描述系统资源和进程的状态。</p>
<p>定义图<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo>=</mo><mo stretchy="false">(</mo><mi>N</mi><mo separator="true">,</mo><mi>E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">G=(N,E)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span>​，其中N为点的集合，代表进程和资源，E为边的集合，代表资源的分配和释放。</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>=</mo><mi>P</mi><mo>∪</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">N=P\cup R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>，P为进程集合，R为资源集合</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>p</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>r</mi><mi>j</mi></msub><mo stretchy="false">)</mo><mtext>或</mtext><mi>e</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>r</mi><mi>j</mi></msub><mo separator="true">,</mo><msub><mi>p</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">e=(p_i,r_j)或e=(r_j,p_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord cjk_fallback">或</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，分别代表进程请求资源和进程释放资源</li>
</ul>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202404272214459.png" alt="进程-资源图"></p>
<h4 id="资源分配图算法RAG">资源分配图算法RAG</h4>
<p>有向图G的顶点为资源或进程，从资源R到进程P的边表示R已分配给P，<strong>从进程P到资源R的边表示P正因请求R而处于等待状态</strong>。</p>
<ul>
<li>封锁进程：是指某个进程由于<strong>请求了超过了系统中现有的未分配资源数目的资源</strong>，而被系统封锁的进程。</li>
<li>非封锁进程：即没有被系统封锁的进程</li>
</ul>
<p>资源分配图的化简方法：假设某个RAG中存在一个进程Pi，此刻Pi是非封锁进程，那么可以进行如下化简：</p>
<ol>
<li>当Pi有请求边时，首先将其请求边变成分配边（即满足Pi的资源请求）</li>
<li>一旦Pi的所有资源请求都得到满足，Pi就能在有限的时间内运行结束，并<strong>释放其所占用的全部资源</strong></li>
<li>此时Pi只有分配边，删去这些分配边（实际上相当于消去了Pi的所有请求边和分配边），使Pi成为孤立结点。</li>
<li>反复进行1-3</li>
</ol>
<p>系统中某个时刻t为死锁状态的充要条件是t时刻系统的<strong>资源分配图是不可完全化简的</strong>：</p>
<ul>
<li>在经过一系列的简化后，若能消去图中的所有边，使所有的进程都成为<strong>孤立结点</strong>，则称该图是可完全化简的；</li>
<li>反之的是不可完全化简的。</li>
</ul>
<h4 id="资源向量-矩阵-算法">资源向量(矩阵)算法</h4>
<p>每类资源多个的死锁检测</p>
<ul>
<li>E：存在资源向量：表示各类资源<strong>存在的总量</strong></li>
<li>A：可用资源向量：表示当前<strong>未分配可使用</strong>的资源数</li>
<li>C：当前分配矩阵：第i个<strong>行向量</strong>对应第i个进程已经分配到的<strong>各类资源数量</strong></li>
<li>R：请求矩阵：第i个行向量表示进程i<strong>所需要的资源数量</strong></li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><msub><mi>C</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>+</mo><msub><mi>A</mi><mi>j</mi></msub><mo>=</mo><msub><mi>E</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">\sum_{i=1}^nC_{ij}+A_{j}=E_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.104em;vertical-align:-0.2997em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8043em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span></li>
</ul>
<p>检测算法：</p>
<ol>
<li>寻找进程Pi，其在R矩阵中对应的第i行小于等于A</li>
<li>如果找到，将C矩阵的第i行加入A，释放资源，并标记该进程执行完毕，转到第1步。</li>
<li>如果找不到，结束。</li>
<li>算法结束时，如存在未标记进程，则他们为死锁进程。</li>
</ol>
<h3 id="死锁恢复">死锁恢复</h3>
<ul>
<li>
<p>资源抢占法</p>
<p>挂起一些占有资源的进程，剥夺它们的资源以解除死锁，将资源分配给另一个死锁进程使其能够执行完毕，然后再激活被挂起的进程。</p>
</li>
<li>
<p>杀死进程法</p>
<ul>
<li>
<p>杀死一个或者若干进程，<strong>释放其资源，直到打破死循</strong>。</p>
</li>
<li>
<p>根据资源占有情况，杀死环内进或者环外进程</p>
</li>
<li>
<p>杀死重新执行无副作用的进程</p>
</li>
</ul>
</li>
<li>
<p>回滚法</p>
<ul>
<li>设置检查点，根据死锁时所需要的资源，将一个拥有资源的进程<strong>滚回到一个未占用资源的检查点状态</strong>，从而使得其他死锁进程能够获得相应的资源。</li>
<li>定期创建检查点
<ul>
<li>保存存储镜像和资源获取的状态</li>
<li>需要占用存储资源</li>
</ul>
</li>
<li>检测到死锁后
<ul>
<li>恢复到资源未分配时的检查点</li>
<li>将资源分配给其他进程，继续执行</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="小结">小结</h3>
<p><img src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202404272235782.png" alt="image-20240427223500463"></p>
<h2 id="活锁与饥饿">活锁与饥饿</h2>
<p>活锁（livelock）：是指任务或者执行者<strong>没有被阻塞</strong>，由于某些条件没有满足，导致<strong>一直重复尝试</strong>，失败，尝试，失败。</p>
<p>活锁和死锁的区别在于，处于<strong>活锁的实体是在不断的改变状态</strong>，即所谓的“活”，而处于死锁的实体表现为等待；活锁有可能自行解开，死锁则不能。避免活锁的简单方法是采用先来先服务的策略。</p>
<p>饥饿（starvation)：某些进程可能由于<strong>资源分配策略的不公平导致长时间等待</strong>。当等待时间给进程推进和响应带来明显影响时，称发生了进程饥饿，当饥饿到一定程度的进程所赋予的任务即使完成也不再具有实际意义时称该进程被饿死(starve to death)。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://pigkillermaster.github.io">pigKiller</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://pigkillermaster.github.io/2024/05/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%90%86%E8%AE%BA-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/">https://pigkillermaster.github.io/2024/05/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%90%86%E8%AE%BA-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://pigkillermaster.github.io" target="_blank">浮泛之舟</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/OS%E7%90%86%E8%AE%BA/">OS理论</a></div><div class="post_share"><div class="social-share" data-image="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403252018445.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/04/02/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-Unit2-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/" title="面向对象-Unit2-Java多线程"><img class="cover" src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202404022351911.png" onerror="onerror=null;src='https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202309212200810.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">面向对象-Unit2-Java多线程</div></div></a></div><div class="next-post pull-right"><a href="/2024/05/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%90%86%E8%AE%BA-IO%E7%AE%A1%E7%90%86/" title="操作系统-理论-IO管理"><img class="cover" src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403252018445.png" onerror="onerror=null;src='https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202309212200810.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">操作系统-理论-IO管理</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/03/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%90%86%E8%AE%BA-%E5%86%85%E5%AD%98/" title="操作系统-理论-内存"><img class="cover" src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403252018445.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-25</div><div class="title">操作系统-理论-内存</div></div></a></div><div><a href="/2024/03/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%90%86%E8%AE%BA-%E5%90%AF%E5%8A%A8/" title="操作系统-理论-启动"><img class="cover" src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403252018445.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-25</div><div class="title">操作系统-理论-启动</div></div></a></div><div><a href="/2024/05/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%90%86%E8%AE%BA-IO%E7%AE%A1%E7%90%86/" title="操作系统-理论-IO管理"><img class="cover" src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403252018445.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-10</div><div class="title">操作系统-理论-IO管理</div></div></a></div><div><a href="/2024/03/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%90%86%E8%AE%BA-%E5%BC%95%E8%AE%BA/" title="操作系统-理论-引论"><img class="cover" src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403252018445.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-25</div><div class="title">操作系统-理论-引论</div></div></a></div><div><a href="/2024/06/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%90%86%E8%AE%BA-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/" title="操作系统-理论-文件系统"><img class="cover" src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403252018445.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-25</div><div class="title">操作系统-理论-文件系统</div></div></a></div><div><a href="/2024/06/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%90%86%E8%AE%BA-%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/" title="操作系统-理论-磁盘管理"><img class="cover" src="https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202403252018445.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-25</div><div class="title">操作系统-理论-磁盘管理</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">进程与线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%B9%B6%E5%8F%91"><span class="toc-number">1.1.</span> <span class="toc-text">并行与并发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E9%A9%B1%E5%9B%BE"><span class="toc-number">1.1.1.</span> <span class="toc-text">前驱图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AB%9E%E4%BA%89"><span class="toc-number">1.1.2.</span> <span class="toc-text">竞争</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.2.</span> <span class="toc-text">进程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">1.2.1.</span> <span class="toc-text">进程控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E8%AF%AD"><span class="toc-number">1.2.2.</span> <span class="toc-text">原语</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">1.2.3.</span> <span class="toc-text">进程的状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97PCB"><span class="toc-number">1.2.4.</span> <span class="toc-text">进程控制块PCB</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#PCB%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">PCB的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PCB%E7%9A%84%E5%86%85%E5%AE%B9"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">PCB的内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PCB%E7%9A%84%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F"><span class="toc-number">1.2.4.3.</span> <span class="toc-text">PCB的组织方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="toc-number">1.2.5.</span> <span class="toc-text">进程上下文切换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.3.</span> <span class="toc-text">线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.3.1.</span> <span class="toc-text">线程的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8BVS%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.3.2.</span> <span class="toc-text">线程VS进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">1.3.3.</span> <span class="toc-text">线程的实现方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%BA%A7%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">用户级线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E7%BA%A7%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">内核级线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%BA%A7%E5%92%8C%E5%86%85%E6%A0%B8%E7%BA%A7%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">1.3.3.3.</span> <span class="toc-text">用户级和内核级的比较</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B7%E5%90%88%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">1.3.3.4.</span> <span class="toc-text">混合实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.3.4.</span> <span class="toc-text">线程模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Many-to-One"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">Many-to-One</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#One-to-One"><span class="toc-number">1.3.4.2.</span> <span class="toc-text">One-to-One</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Many-to-Many"><span class="toc-number">1.3.4.3.</span> <span class="toc-text">Many-to-Many</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">进程同步</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5"><span class="toc-number">2.1.</span> <span class="toc-text">同步与互斥</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.1.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%BA%E5%88%B6%E5%8E%9F%E5%88%99"><span class="toc-number">2.1.2.</span> <span class="toc-text">机制原则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E6%96%B9%E6%B3%95"><span class="toc-number">2.2.</span> <span class="toc-text">互斥方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E5%BF%99%E7%AD%89%E5%BE%85%E7%9A%84%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95"><span class="toc-number">2.2.1.</span> <span class="toc-text">基于忙等待的同步方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%96%B9%E6%B3%95"><span class="toc-number">2.2.1.1.</span> <span class="toc-text">软件方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E6%96%B9%E6%B3%95"><span class="toc-number">2.2.1.2.</span> <span class="toc-text">硬件方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">2.2.1.3.</span> <span class="toc-text">信号量的使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E9%9B%86%E6%9C%BA%E5%88%B6"><span class="toc-number">2.2.2.</span> <span class="toc-text">信号量集机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AND%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F%E9%9B%86%E6%9C%BA%E5%88%B6"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">AND型信号量集机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E8%88%AC%E2%80%9C%E4%BF%A1%E5%8F%B7%E9%87%8F%E9%9B%86%E2%80%9D%E6%9C%BA%E5%88%B6-SP-S-T-D"><span class="toc-number">2.2.2.2.</span> <span class="toc-text">一般“信号量集”机制 SP(S,T,D)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">2.3.</span> <span class="toc-text">进程通信的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E9%81%93"><span class="toc-number">2.3.1.</span> <span class="toc-text">管道</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E5%90%8D%E7%AE%A1%E9%81%93"><span class="toc-number">2.3.1.1.</span> <span class="toc-text">无名管道</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E5%90%8D%E7%AE%A1%E9%81%93"><span class="toc-number">2.3.1.2.</span> <span class="toc-text">有名管道</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">2.3.2.</span> <span class="toc-text">消息队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98"><span class="toc-number">2.3.3.</span> <span class="toc-text">共享内存</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E5%92%8C%E4%BA%92%E6%96%A5%E9%97%AE%E9%A2%98"><span class="toc-number">2.4.</span> <span class="toc-text">经典的进程同步和互斥问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.4.1.</span> <span class="toc-text">生产者消费者模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E8%80%85-%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">2.4.2.</span> <span class="toc-text">读者-写者问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90%E9%97%AE%E9%A2%98"><span class="toc-number">2.4.3.</span> <span class="toc-text">哲学家进餐问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">调度</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-2"><span class="toc-number">3.1.</span> <span class="toc-text">基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.1.1.</span> <span class="toc-text">调度类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E8%AF%84%E4%BB%B7%E6%A0%87%E5%87%86"><span class="toc-number">3.1.2.</span> <span class="toc-text">性能评价标准</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%B0%83%E5%BA%A6"><span class="toc-number">3.2.</span> <span class="toc-text">基本调度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">3.2.1.</span> <span class="toc-text">进程优先级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%B0%B1%E7%BB%AA%E9%98%9F%E5%88%97"><span class="toc-number">3.2.2.</span> <span class="toc-text">进程就绪队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%89%E4%BC%98%E5%85%88%E7%BA%A7%E6%8E%92%E9%98%9F%E6%96%B9%E5%BC%8F"><span class="toc-number">3.2.2.1.</span> <span class="toc-text">按优先级排队方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97"><span class="toc-number">3.2.2.2.</span> <span class="toc-text">动态优先级队列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%A0%E7%94%A8CPU%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">3.2.3.</span> <span class="toc-text">占用CPU的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%86%E7%B1%BB%E6%96%B9%E5%BC%8F"><span class="toc-number">3.2.4.</span> <span class="toc-text">进程的分类方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B8%B8%E7%94%A8%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">3.3.</span> <span class="toc-text">批处理系统的常用调度算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%88%E6%9D%A5%E6%9C%8D%E5%8A%A1FCFS"><span class="toc-number">3.3.1.</span> <span class="toc-text">先来服务FCFS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%AD%E4%BD%9C%E4%B8%9A%E4%BC%98%E5%85%88SJF"><span class="toc-number">3.3.2.</span> <span class="toc-text">短作业优先SJF</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E5%89%A9%E4%BD%99%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88FRTF"><span class="toc-number">3.3.3.</span> <span class="toc-text">最短剩余时间优先FRTF</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E9%AB%98%E5%93%8D%E5%BA%94%E6%AF%94%E4%BC%98%E5%85%88HRRF"><span class="toc-number">3.3.4.</span> <span class="toc-text">最高响应比优先HRRF</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%A4%E4%BA%92%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">3.4.</span> <span class="toc-text">交互式系统的调度算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC%E7%AE%97%E6%B3%95RR"><span class="toc-number">3.4.1.</span> <span class="toc-text">时间片轮转算法RR</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E7%AE%97%E6%B3%95PS"><span class="toc-number">3.4.2.</span> <span class="toc-text">优先级算法PS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E9%98%9F%E5%88%97%E7%AE%97%E6%B3%95MQ"><span class="toc-number">3.4.3.</span> <span class="toc-text">多级队列算法MQ</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97%E7%AE%97%E6%B3%95MFQ"><span class="toc-number">3.4.4.</span> <span class="toc-text">多级反馈队列算法MFQ</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E5%80%92%E7%BD%AE%E7%8E%B0%E8%B1%A1"><span class="toc-number">3.4.5.</span> <span class="toc-text">优先级倒置现象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E7%BD%AE%E9%A1%B6%EF%BC%9A%E4%BD%8E%E4%BC%98%E5%85%88%E7%BA%A7%E5%8F%98%E4%B8%BA%E6%9C%80%E9%AB%98%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">3.4.5.1.</span> <span class="toc-text">优先级置顶：低优先级变为最高优先级</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E7%BB%A7%E6%89%BF%EF%BC%9A%E4%BD%8E%E4%BC%98%E5%85%88%E7%BA%A7%E5%8F%98%E4%B8%BA%E6%96%B0%E8%BF%9B%E5%85%A5%E7%9A%84%E9%AB%98%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">3.4.5.2.</span> <span class="toc-text">优先级继承：低优先级变为新进入的高优先级</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E6%97%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">3.5.</span> <span class="toc-text">实时系统的调度算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-3"><span class="toc-number">3.5.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">3.5.2.</span> <span class="toc-text">静态调度算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E8%B0%83%E9%80%9F%E7%8E%87%E8%B0%83%E5%BA%A6RMS"><span class="toc-number">3.5.3.</span> <span class="toc-text">单调速率调度RMS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E6%97%A9%E6%88%AA%E6%AD%A2%E6%9C%9F%E8%B0%83%E5%BA%A6EDF"><span class="toc-number">3.5.4.</span> <span class="toc-text">最早截止期调度EDF</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6"><span class="toc-number">3.6.</span> <span class="toc-text">多处理机调度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%A4%9A%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9FAMP"><span class="toc-number">3.6.1.</span> <span class="toc-text">非对称多处理系统AMP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E7%A7%B0%E5%BC%8F%E5%A4%9A%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9FSMP"><span class="toc-number">3.6.2.</span> <span class="toc-text">对称式多处理系统SMP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E4%B8%AD%E6%8E%A7%E5%88%B6"><span class="toc-number">3.6.2.1.</span> <span class="toc-text">集中控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%95%A3%E6%8E%A7%E5%88%B6"><span class="toc-number">3.6.2.2.</span> <span class="toc-text">分散控制</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E4%BA%A7%E7%94%9F"><span class="toc-number">4.1.</span> <span class="toc-text">死锁的产生</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%AD%BB%E9%94%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95"><span class="toc-number">4.2.</span> <span class="toc-text">处理死锁的基本方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%84%E9%98%B2%E6%AD%BB%E9%94%81"><span class="toc-number">4.2.1.</span> <span class="toc-text">预防死锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81"><span class="toc-number">4.2.2.</span> <span class="toc-text">避免死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95"><span class="toc-number">4.2.2.1.</span> <span class="toc-text">银行家算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E8%B5%84%E6%BA%90%E5%9B%BE"><span class="toc-number">4.2.2.2.</span> <span class="toc-text">进程资源图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E5%9B%BE%E7%AE%97%E6%B3%95RAG"><span class="toc-number">4.2.2.3.</span> <span class="toc-text">资源分配图算法RAG</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E5%90%91%E9%87%8F-%E7%9F%A9%E9%98%B5-%E7%AE%97%E6%B3%95"><span class="toc-number">4.2.2.4.</span> <span class="toc-text">资源向量(矩阵)算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E6%81%A2%E5%A4%8D"><span class="toc-number">4.2.3.</span> <span class="toc-text">死锁恢复</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">4.2.4.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B4%BB%E9%94%81%E4%B8%8E%E9%A5%A5%E9%A5%BF"><span class="toc-number">4.3.</span> <span class="toc-text">活锁与饥饿</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2024 By pigKiller</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">你终会看到，你的歌声和旗帜在飘扬</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script></div><script src="f12.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>